(function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload"))
        return;
    for (const s of document.querySelectorAll('link[rel="modulepreload"]'))
        r(s);
    new MutationObserver(s => {
        for (const o of s)
            if (o.type === "childList")
                for (const u of o.addedNodes)
                    u.tagName === "LINK" && u.rel === "modulepreload" && r(u)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function t(s) {
        const o = {};
        return s.integrity && (o.integrity = s.integrity),
        s.referrerPolicy && (o.referrerPolicy = s.referrerPolicy),
        s.crossOrigin === "use-credentials" ? o.credentials = "include" : s.crossOrigin === "anonymous" ? o.credentials = "omit" : o.credentials = "same-origin",
        o
    }
    function r(s) {
        if (s.ep)
            return;
        s.ep = !0;
        const o = t(s);
        fetch(s.href, o)
    }
}
)();
function ME(n) {
    return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
}
var um = {
    exports: {}
}
  , Sc = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qx;
function s1() {
    if (qx)
        return Sc;
    qx = 1;
    var n = Symbol.for("react.transitional.element")
      , e = Symbol.for("react.fragment");
    function t(r, s, o) {
        var u = null;
        if (o !== void 0 && (u = "" + o),
        s.key !== void 0 && (u = "" + s.key),
        "key"in s) {
            o = {};
            for (var d in s)
                d !== "key" && (o[d] = s[d])
        } else
            o = s;
        return s = o.ref,
        {
            $$typeof: n,
            type: r,
            key: u,
            ref: s !== void 0 ? s : null,
            props: o
        }
    }
    return Sc.Fragment = e,
    Sc.jsx = t,
    Sc.jsxs = t,
    Sc
}
var Yx;
function o1() {
    return Yx || (Yx = 1,
    um.exports = s1()),
    um.exports
}
var Z = o1()
  , dm = {
    exports: {}
}
  , Bt = {};
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Zx;
function l1() {
    if (Zx)
        return Bt;
    Zx = 1;
    var n = Symbol.for("react.transitional.element")
      , e = Symbol.for("react.portal")
      , t = Symbol.for("react.fragment")
      , r = Symbol.for("react.strict_mode")
      , s = Symbol.for("react.profiler")
      , o = Symbol.for("react.consumer")
      , u = Symbol.for("react.context")
      , d = Symbol.for("react.forward_ref")
      , f = Symbol.for("react.suspense")
      , h = Symbol.for("react.memo")
      , m = Symbol.for("react.lazy")
      , g = Symbol.iterator;
    function _(k) {
        return k === null || typeof k != "object" ? null : (k = g && k[g] || k["@@iterator"],
        typeof k == "function" ? k : null)
    }
    var x = {
        isMounted: function() {
            return !1
        },
        enqueueForceUpdate: function() {},
        enqueueReplaceState: function() {},
        enqueueSetState: function() {}
    }
      , E = Object.assign
      , M = {};
    function b(k, ee, ge) {
        this.props = k,
        this.context = ee,
        this.refs = M,
        this.updater = ge || x
    }
    b.prototype.isReactComponent = {},
    b.prototype.setState = function(k, ee) {
        if (typeof k != "object" && typeof k != "function" && k != null)
            throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, k, ee, "setState")
    }
    ,
    b.prototype.forceUpdate = function(k) {
        this.updater.enqueueForceUpdate(this, k, "forceUpdate")
    }
    ;
    function y() {}
    y.prototype = b.prototype;
    function T(k, ee, ge) {
        this.props = k,
        this.context = ee,
        this.refs = M,
        this.updater = ge || x
    }
    var D = T.prototype = new y;
    D.constructor = T,
    E(D, b.prototype),
    D.isPureReactComponent = !0;
    var C = Array.isArray
      , P = {
        H: null,
        A: null,
        T: null,
        S: null,
        V: null
    }
      , A = Object.prototype.hasOwnProperty;
    function F(k, ee, ge, pe, te, we) {
        return ge = we.ref,
        {
            $$typeof: n,
            type: k,
            key: ee,
            ref: ge !== void 0 ? ge : null,
            props: we
        }
    }
    function z(k, ee) {
        return F(k.type, ee, void 0, void 0, void 0, k.props)
    }
    function U(k) {
        return typeof k == "object" && k !== null && k.$$typeof === n
    }
    function R(k) {
        var ee = {
            "=": "=0",
            ":": "=2"
        };
        return "$" + k.replace(/[=:]/g, function(ge) {
            return ee[ge]
        })
    }
    var V = /\/+/g;
    function Q(k, ee) {
        return typeof k == "object" && k !== null && k.key != null ? R("" + k.key) : ee.toString(36)
    }
    function X() {}
    function oe(k) {
        switch (k.status) {
        case "fulfilled":
            return k.value;
        case "rejected":
            throw k.reason;
        default:
            switch (typeof k.status == "string" ? k.then(X, X) : (k.status = "pending",
            k.then(function(ee) {
                k.status === "pending" && (k.status = "fulfilled",
                k.value = ee)
            }, function(ee) {
                k.status === "pending" && (k.status = "rejected",
                k.reason = ee)
            })),
            k.status) {
            case "fulfilled":
                return k.value;
            case "rejected":
                throw k.reason
            }
        }
        throw k
    }
    function le(k, ee, ge, pe, te) {
        var we = typeof k;
        (we === "undefined" || we === "boolean") && (k = null);
        var Se = !1;
        if (k === null)
            Se = !0;
        else
            switch (we) {
            case "bigint":
            case "string":
            case "number":
                Se = !0;
                break;
            case "object":
                switch (k.$$typeof) {
                case n:
                case e:
                    Se = !0;
                    break;
                case m:
                    return Se = k._init,
                    le(Se(k._payload), ee, ge, pe, te)
                }
            }
        if (Se)
            return te = te(k),
            Se = pe === "" ? "." + Q(k, 0) : pe,
            C(te) ? (ge = "",
            Se != null && (ge = Se.replace(V, "$&/") + "/"),
            le(te, ee, ge, "", function(_t) {
                return _t
            })) : te != null && (U(te) && (te = z(te, ge + (te.key == null || k && k.key === te.key ? "" : ("" + te.key).replace(V, "$&/") + "/") + Se)),
            ee.push(te)),
            1;
        Se = 0;
        var De = pe === "" ? "." : pe + ":";
        if (C(k))
            for (var Ve = 0; Ve < k.length; Ve++)
                pe = k[Ve],
                we = De + Q(pe, Ve),
                Se += le(pe, ee, ge, we, te);
        else if (Ve = _(k),
        typeof Ve == "function")
            for (k = Ve.call(k),
            Ve = 0; !(pe = k.next()).done; )
                pe = pe.value,
                we = De + Q(pe, Ve++),
                Se += le(pe, ee, ge, we, te);
        else if (we === "object") {
            if (typeof k.then == "function")
                return le(oe(k), ee, ge, pe, te);
            throw ee = String(k),
            Error("Objects are not valid as a React child (found: " + (ee === "[object Object]" ? "object with keys {" + Object.keys(k).join(", ") + "}" : ee) + "). If you meant to render a collection of children, use an array instead.")
        }
        return Se
    }
    function O(k, ee, ge) {
        if (k == null)
            return k;
        var pe = []
          , te = 0;
        return le(k, pe, "", "", function(we) {
            return ee.call(ge, we, te++)
        }),
        pe
    }
    function W(k) {
        if (k._status === -1) {
            var ee = k._result;
            ee = ee(),
            ee.then(function(ge) {
                (k._status === 0 || k._status === -1) && (k._status = 1,
                k._result = ge)
            }, function(ge) {
                (k._status === 0 || k._status === -1) && (k._status = 2,
                k._result = ge)
            }),
            k._status === -1 && (k._status = 0,
            k._result = ee)
        }
        if (k._status === 1)
            return k._result.default;
        throw k._result
    }
    var H = typeof reportError == "function" ? reportError : function(k) {
        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
            var ee = new window.ErrorEvent("error",{
                bubbles: !0,
                cancelable: !0,
                message: typeof k == "object" && k !== null && typeof k.message == "string" ? String(k.message) : String(k),
                error: k
            });
            if (!window.dispatchEvent(ee))
                return
        } else if (typeof process == "object" && typeof process.emit == "function") {
            process.emit("uncaughtException", k);
            return
        }
        console.error(k)
    }
    ;
    function Me() {}
    return Bt.Children = {
        map: O,
        forEach: function(k, ee, ge) {
            O(k, function() {
                ee.apply(this, arguments)
            }, ge)
        },
        count: function(k) {
            var ee = 0;
            return O(k, function() {
                ee++
            }),
            ee
        },
        toArray: function(k) {
            return O(k, function(ee) {
                return ee
            }) || []
        },
        only: function(k) {
            if (!U(k))
                throw Error("React.Children.only expected to receive a single React element child.");
            return k
        }
    },
    Bt.Component = b,
    Bt.Fragment = t,
    Bt.Profiler = s,
    Bt.PureComponent = T,
    Bt.StrictMode = r,
    Bt.Suspense = f,
    Bt.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = P,
    Bt.__COMPILER_RUNTIME = {
        __proto__: null,
        c: function(k) {
            return P.H.useMemoCache(k)
        }
    },
    Bt.cache = function(k) {
        return function() {
            return k.apply(null, arguments)
        }
    }
    ,
    Bt.cloneElement = function(k, ee, ge) {
        if (k == null)
            throw Error("The argument must be a React element, but you passed " + k + ".");
        var pe = E({}, k.props)
          , te = k.key
          , we = void 0;
        if (ee != null)
            for (Se in ee.ref !== void 0 && (we = void 0),
            ee.key !== void 0 && (te = "" + ee.key),
            ee)
                !A.call(ee, Se) || Se === "key" || Se === "__self" || Se === "__source" || Se === "ref" && ee.ref === void 0 || (pe[Se] = ee[Se]);
        var Se = arguments.length - 2;
        if (Se === 1)
            pe.children = ge;
        else if (1 < Se) {
            for (var De = Array(Se), Ve = 0; Ve < Se; Ve++)
                De[Ve] = arguments[Ve + 2];
            pe.children = De
        }
        return F(k.type, te, void 0, void 0, we, pe)
    }
    ,
    Bt.createContext = function(k) {
        return k = {
            $$typeof: u,
            _currentValue: k,
            _currentValue2: k,
            _threadCount: 0,
            Provider: null,
            Consumer: null
        },
        k.Provider = k,
        k.Consumer = {
            $$typeof: o,
            _context: k
        },
        k
    }
    ,
    Bt.createElement = function(k, ee, ge) {
        var pe, te = {}, we = null;
        if (ee != null)
            for (pe in ee.key !== void 0 && (we = "" + ee.key),
            ee)
                A.call(ee, pe) && pe !== "key" && pe !== "__self" && pe !== "__source" && (te[pe] = ee[pe]);
        var Se = arguments.length - 2;
        if (Se === 1)
            te.children = ge;
        else if (1 < Se) {
            for (var De = Array(Se), Ve = 0; Ve < Se; Ve++)
                De[Ve] = arguments[Ve + 2];
            te.children = De
        }
        if (k && k.defaultProps)
            for (pe in Se = k.defaultProps,
            Se)
                te[pe] === void 0 && (te[pe] = Se[pe]);
        return F(k, we, void 0, void 0, null, te)
    }
    ,
    Bt.createRef = function() {
        return {
            current: null
        }
    }
    ,
    Bt.forwardRef = function(k) {
        return {
            $$typeof: d,
            render: k
        }
    }
    ,
    Bt.isValidElement = U,
    Bt.lazy = function(k) {
        return {
            $$typeof: m,
            _payload: {
                _status: -1,
                _result: k
            },
            _init: W
        }
    }
    ,
    Bt.memo = function(k, ee) {
        return {
            $$typeof: h,
            type: k,
            compare: ee === void 0 ? null : ee
        }
    }
    ,
    Bt.startTransition = function(k) {
        var ee = P.T
          , ge = {};
        P.T = ge;
        try {
            var pe = k()
              , te = P.S;
            te !== null && te(ge, pe),
            typeof pe == "object" && pe !== null && typeof pe.then == "function" && pe.then(Me, H)
        } catch (we) {
            H(we)
        } finally {
            P.T = ee
        }
    }
    ,
    Bt.unstable_useCacheRefresh = function() {
        return P.H.useCacheRefresh()
    }
    ,
    Bt.use = function(k) {
        return P.H.use(k)
    }
    ,
    Bt.useActionState = function(k, ee, ge) {
        return P.H.useActionState(k, ee, ge)
    }
    ,
    Bt.useCallback = function(k, ee) {
        return P.H.useCallback(k, ee)
    }
    ,
    Bt.useContext = function(k) {
        return P.H.useContext(k)
    }
    ,
    Bt.useDebugValue = function() {}
    ,
    Bt.useDeferredValue = function(k, ee) {
        return P.H.useDeferredValue(k, ee)
    }
    ,
    Bt.useEffect = function(k, ee, ge) {
        var pe = P.H;
        if (typeof ge == "function")
            throw Error("useEffect CRUD overload is not enabled in this build of React.");
        return pe.useEffect(k, ee)
    }
    ,
    Bt.useId = function() {
        return P.H.useId()
    }
    ,
    Bt.useImperativeHandle = function(k, ee, ge) {
        return P.H.useImperativeHandle(k, ee, ge)
    }
    ,
    Bt.useInsertionEffect = function(k, ee) {
        return P.H.useInsertionEffect(k, ee)
    }
    ,
    Bt.useLayoutEffect = function(k, ee) {
        return P.H.useLayoutEffect(k, ee)
    }
    ,
    Bt.useMemo = function(k, ee) {
        return P.H.useMemo(k, ee)
    }
    ,
    Bt.useOptimistic = function(k, ee) {
        return P.H.useOptimistic(k, ee)
    }
    ,
    Bt.useReducer = function(k, ee, ge) {
        return P.H.useReducer(k, ee, ge)
    }
    ,
    Bt.useRef = function(k) {
        return P.H.useRef(k)
    }
    ,
    Bt.useState = function(k) {
        return P.H.useState(k)
    }
    ,
    Bt.useSyncExternalStore = function(k, ee, ge) {
        return P.H.useSyncExternalStore(k, ee, ge)
    }
    ,
    Bt.useTransition = function() {
        return P.H.useTransition()
    }
    ,
    Bt.version = "19.1.0",
    Bt
}
var $x;
function jf() {
    return $x || ($x = 1,
    dm.exports = l1()),
    dm.exports
}
var $ = jf();
const K = ME($);
var fm = {
    exports: {}
}
  , Ec = {}
  , hm = {
    exports: {}
}
  , pm = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Kx;
function c1() {
    return Kx || (Kx = 1,
    function(n) {
        function e(O, W) {
            var H = O.length;
            O.push(W);
            e: for (; 0 < H; ) {
                var Me = H - 1 >>> 1
                  , k = O[Me];
                if (0 < s(k, W))
                    O[Me] = W,
                    O[H] = k,
                    H = Me;
                else
                    break e
            }
        }
        function t(O) {
            return O.length === 0 ? null : O[0]
        }
        function r(O) {
            if (O.length === 0)
                return null;
            var W = O[0]
              , H = O.pop();
            if (H !== W) {
                O[0] = H;
                e: for (var Me = 0, k = O.length, ee = k >>> 1; Me < ee; ) {
                    var ge = 2 * (Me + 1) - 1
                      , pe = O[ge]
                      , te = ge + 1
                      , we = O[te];
                    if (0 > s(pe, H))
                        te < k && 0 > s(we, pe) ? (O[Me] = we,
                        O[te] = H,
                        Me = te) : (O[Me] = pe,
                        O[ge] = H,
                        Me = ge);
                    else if (te < k && 0 > s(we, H))
                        O[Me] = we,
                        O[te] = H,
                        Me = te;
                    else
                        break e
                }
            }
            return W
        }
        function s(O, W) {
            var H = O.sortIndex - W.sortIndex;
            return H !== 0 ? H : O.id - W.id
        }
        if (n.unstable_now = void 0,
        typeof performance == "object" && typeof performance.now == "function") {
            var o = performance;
            n.unstable_now = function() {
                return o.now()
            }
        } else {
            var u = Date
              , d = u.now();
            n.unstable_now = function() {
                return u.now() - d
            }
        }
        var f = []
          , h = []
          , m = 1
          , g = null
          , _ = 3
          , x = !1
          , E = !1
          , M = !1
          , b = !1
          , y = typeof setTimeout == "function" ? setTimeout : null
          , T = typeof clearTimeout == "function" ? clearTimeout : null
          , D = typeof setImmediate < "u" ? setImmediate : null;
        function C(O) {
            for (var W = t(h); W !== null; ) {
                if (W.callback === null)
                    r(h);
                else if (W.startTime <= O)
                    r(h),
                    W.sortIndex = W.expirationTime,
                    e(f, W);
                else
                    break;
                W = t(h)
            }
        }
        function P(O) {
            if (M = !1,
            C(O),
            !E)
                if (t(f) !== null)
                    E = !0,
                    A || (A = !0,
                    Q());
                else {
                    var W = t(h);
                    W !== null && le(P, W.startTime - O)
                }
        }
        var A = !1
          , F = -1
          , z = 5
          , U = -1;
        function R() {
            return b ? !0 : !(n.unstable_now() - U < z)
        }
        function V() {
            if (b = !1,
            A) {
                var O = n.unstable_now();
                U = O;
                var W = !0;
                try {
                    e: {
                        E = !1,
                        M && (M = !1,
                        T(F),
                        F = -1),
                        x = !0;
                        var H = _;
                        try {
                            t: {
                                for (C(O),
                                g = t(f); g !== null && !(g.expirationTime > O && R()); ) {
                                    var Me = g.callback;
                                    if (typeof Me == "function") {
                                        g.callback = null,
                                        _ = g.priorityLevel;
                                        var k = Me(g.expirationTime <= O);
                                        if (O = n.unstable_now(),
                                        typeof k == "function") {
                                            g.callback = k,
                                            C(O),
                                            W = !0;
                                            break t
                                        }
                                        g === t(f) && r(f),
                                        C(O)
                                    } else
                                        r(f);
                                    g = t(f)
                                }
                                if (g !== null)
                                    W = !0;
                                else {
                                    var ee = t(h);
                                    ee !== null && le(P, ee.startTime - O),
                                    W = !1
                                }
                            }
                            break e
                        } finally {
                            g = null,
                            _ = H,
                            x = !1
                        }
                        W = void 0
                    }
                } finally {
                    W ? Q() : A = !1
                }
            }
        }
        var Q;
        if (typeof D == "function")
            Q = function() {
                D(V)
            }
            ;
        else if (typeof MessageChannel < "u") {
            var X = new MessageChannel
              , oe = X.port2;
            X.port1.onmessage = V,
            Q = function() {
                oe.postMessage(null)
            }
        } else
            Q = function() {
                y(V, 0)
            }
            ;
        function le(O, W) {
            F = y(function() {
                O(n.unstable_now())
            }, W)
        }
        n.unstable_IdlePriority = 5,
        n.unstable_ImmediatePriority = 1,
        n.unstable_LowPriority = 4,
        n.unstable_NormalPriority = 3,
        n.unstable_Profiling = null,
        n.unstable_UserBlockingPriority = 2,
        n.unstable_cancelCallback = function(O) {
            O.callback = null
        }
        ,
        n.unstable_forceFrameRate = function(O) {
            0 > O || 125 < O ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : z = 0 < O ? Math.floor(1e3 / O) : 5
        }
        ,
        n.unstable_getCurrentPriorityLevel = function() {
            return _
        }
        ,
        n.unstable_next = function(O) {
            switch (_) {
            case 1:
            case 2:
            case 3:
                var W = 3;
                break;
            default:
                W = _
            }
            var H = _;
            _ = W;
            try {
                return O()
            } finally {
                _ = H
            }
        }
        ,
        n.unstable_requestPaint = function() {
            b = !0
        }
        ,
        n.unstable_runWithPriority = function(O, W) {
            switch (O) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                O = 3
            }
            var H = _;
            _ = O;
            try {
                return W()
            } finally {
                _ = H
            }
        }
        ,
        n.unstable_scheduleCallback = function(O, W, H) {
            var Me = n.unstable_now();
            switch (typeof H == "object" && H !== null ? (H = H.delay,
            H = typeof H == "number" && 0 < H ? Me + H : Me) : H = Me,
            O) {
            case 1:
                var k = -1;
                break;
            case 2:
                k = 250;
                break;
            case 5:
                k = 1073741823;
                break;
            case 4:
                k = 1e4;
                break;
            default:
                k = 5e3
            }
            return k = H + k,
            O = {
                id: m++,
                callback: W,
                priorityLevel: O,
                startTime: H,
                expirationTime: k,
                sortIndex: -1
            },
            H > Me ? (O.sortIndex = H,
            e(h, O),
            t(f) === null && O === t(h) && (M ? (T(F),
            F = -1) : M = !0,
            le(P, H - Me))) : (O.sortIndex = k,
            e(f, O),
            E || x || (E = !0,
            A || (A = !0,
            Q()))),
            O
        }
        ,
        n.unstable_shouldYield = R,
        n.unstable_wrapCallback = function(O) {
            var W = _;
            return function() {
                var H = _;
                _ = W;
                try {
                    return O.apply(this, arguments)
                } finally {
                    _ = H
                }
            }
        }
    }(pm)),
    pm
}
var Qx;
function u1() {
    return Qx || (Qx = 1,
    hm.exports = c1()),
    hm.exports
}
var mm = {
    exports: {}
}
  , gi = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Jx;
function d1() {
    if (Jx)
        return gi;
    Jx = 1;
    var n = jf();
    function e(f) {
        var h = "https://react.dev/errors/" + f;
        if (1 < arguments.length) {
            h += "?args[]=" + encodeURIComponent(arguments[1]);
            for (var m = 2; m < arguments.length; m++)
                h += "&args[]=" + encodeURIComponent(arguments[m])
        }
        return "Minified React error #" + f + "; visit " + h + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    function t() {}
    var r = {
        d: {
            f: t,
            r: function() {
                throw Error(e(522))
            },
            D: t,
            C: t,
            L: t,
            m: t,
            X: t,
            S: t,
            M: t
        },
        p: 0,
        findDOMNode: null
    }
      , s = Symbol.for("react.portal");
    function o(f, h, m) {
        var g = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {
            $$typeof: s,
            key: g == null ? null : "" + g,
            children: f,
            containerInfo: h,
            implementation: m
        }
    }
    var u = n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    function d(f, h) {
        if (f === "font")
            return "";
        if (typeof h == "string")
            return h === "use-credentials" ? h : ""
    }
    return gi.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = r,
    gi.createPortal = function(f, h) {
        var m = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
        if (!h || h.nodeType !== 1 && h.nodeType !== 9 && h.nodeType !== 11)
            throw Error(e(299));
        return o(f, h, null, m)
    }
    ,
    gi.flushSync = function(f) {
        var h = u.T
          , m = r.p;
        try {
            if (u.T = null,
            r.p = 2,
            f)
                return f()
        } finally {
            u.T = h,
            r.p = m,
            r.d.f()
        }
    }
    ,
    gi.preconnect = function(f, h) {
        typeof f == "string" && (h ? (h = h.crossOrigin,
        h = typeof h == "string" ? h === "use-credentials" ? h : "" : void 0) : h = null,
        r.d.C(f, h))
    }
    ,
    gi.prefetchDNS = function(f) {
        typeof f == "string" && r.d.D(f)
    }
    ,
    gi.preinit = function(f, h) {
        if (typeof f == "string" && h && typeof h.as == "string") {
            var m = h.as
              , g = d(m, h.crossOrigin)
              , _ = typeof h.integrity == "string" ? h.integrity : void 0
              , x = typeof h.fetchPriority == "string" ? h.fetchPriority : void 0;
            m === "style" ? r.d.S(f, typeof h.precedence == "string" ? h.precedence : void 0, {
                crossOrigin: g,
                integrity: _,
                fetchPriority: x
            }) : m === "script" && r.d.X(f, {
                crossOrigin: g,
                integrity: _,
                fetchPriority: x,
                nonce: typeof h.nonce == "string" ? h.nonce : void 0
            })
        }
    }
    ,
    gi.preinitModule = function(f, h) {
        if (typeof f == "string")
            if (typeof h == "object" && h !== null) {
                if (h.as == null || h.as === "script") {
                    var m = d(h.as, h.crossOrigin);
                    r.d.M(f, {
                        crossOrigin: m,
                        integrity: typeof h.integrity == "string" ? h.integrity : void 0,
                        nonce: typeof h.nonce == "string" ? h.nonce : void 0
                    })
                }
            } else
                h == null && r.d.M(f)
    }
    ,
    gi.preload = function(f, h) {
        if (typeof f == "string" && typeof h == "object" && h !== null && typeof h.as == "string") {
            var m = h.as
              , g = d(m, h.crossOrigin);
            r.d.L(f, m, {
                crossOrigin: g,
                integrity: typeof h.integrity == "string" ? h.integrity : void 0,
                nonce: typeof h.nonce == "string" ? h.nonce : void 0,
                type: typeof h.type == "string" ? h.type : void 0,
                fetchPriority: typeof h.fetchPriority == "string" ? h.fetchPriority : void 0,
                referrerPolicy: typeof h.referrerPolicy == "string" ? h.referrerPolicy : void 0,
                imageSrcSet: typeof h.imageSrcSet == "string" ? h.imageSrcSet : void 0,
                imageSizes: typeof h.imageSizes == "string" ? h.imageSizes : void 0,
                media: typeof h.media == "string" ? h.media : void 0
            })
        }
    }
    ,
    gi.preloadModule = function(f, h) {
        if (typeof f == "string")
            if (h) {
                var m = d(h.as, h.crossOrigin);
                r.d.m(f, {
                    as: typeof h.as == "string" && h.as !== "script" ? h.as : void 0,
                    crossOrigin: m,
                    integrity: typeof h.integrity == "string" ? h.integrity : void 0
                })
            } else
                r.d.m(f)
    }
    ,
    gi.requestFormReset = function(f) {
        r.d.r(f)
    }
    ,
    gi.unstable_batchedUpdates = function(f, h) {
        return f(h)
    }
    ,
    gi.useFormState = function(f, h, m) {
        return u.H.useFormState(f, h, m)
    }
    ,
    gi.useFormStatus = function() {
        return u.H.useHostTransitionStatus()
    }
    ,
    gi.version = "19.1.0",
    gi
}
var eb;
function wE() {
    if (eb)
        return mm.exports;
    eb = 1;
    function n() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
            try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)
            } catch (e) {
                console.error(e)
            }
    }
    return n(),
    mm.exports = d1(),
    mm.exports
}
/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var tb;
function f1() {
    if (tb)
        return Ec;
    tb = 1;
    var n = u1()
      , e = jf()
      , t = wE();
    function r(i) {
        var a = "https://react.dev/errors/" + i;
        if (1 < arguments.length) {
            a += "?args[]=" + encodeURIComponent(arguments[1]);
            for (var l = 2; l < arguments.length; l++)
                a += "&args[]=" + encodeURIComponent(arguments[l])
        }
        return "Minified React error #" + i + "; visit " + a + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    function s(i) {
        return !(!i || i.nodeType !== 1 && i.nodeType !== 9 && i.nodeType !== 11)
    }
    function o(i) {
        var a = i
          , l = i;
        if (i.alternate)
            for (; a.return; )
                a = a.return;
        else {
            i = a;
            do
                a = i,
                (a.flags & 4098) !== 0 && (l = a.return),
                i = a.return;
            while (i)
        }
        return a.tag === 3 ? l : null
    }
    function u(i) {
        if (i.tag === 13) {
            var a = i.memoizedState;
            if (a === null && (i = i.alternate,
            i !== null && (a = i.memoizedState)),
            a !== null)
                return a.dehydrated
        }
        return null
    }
    function d(i) {
        if (o(i) !== i)
            throw Error(r(188))
    }
    function f(i) {
        var a = i.alternate;
        if (!a) {
            if (a = o(i),
            a === null)
                throw Error(r(188));
            return a !== i ? null : i
        }
        for (var l = i, c = a; ; ) {
            var p = l.return;
            if (p === null)
                break;
            var v = p.alternate;
            if (v === null) {
                if (c = p.return,
                c !== null) {
                    l = c;
                    continue
                }
                break
            }
            if (p.child === v.child) {
                for (v = p.child; v; ) {
                    if (v === l)
                        return d(p),
                        i;
                    if (v === c)
                        return d(p),
                        a;
                    v = v.sibling
                }
                throw Error(r(188))
            }
            if (l.return !== c.return)
                l = p,
                c = v;
            else {
                for (var w = !1, L = p.child; L; ) {
                    if (L === l) {
                        w = !0,
                        l = p,
                        c = v;
                        break
                    }
                    if (L === c) {
                        w = !0,
                        c = p,
                        l = v;
                        break
                    }
                    L = L.sibling
                }
                if (!w) {
                    for (L = v.child; L; ) {
                        if (L === l) {
                            w = !0,
                            l = v,
                            c = p;
                            break
                        }
                        if (L === c) {
                            w = !0,
                            c = v,
                            l = p;
                            break
                        }
                        L = L.sibling
                    }
                    if (!w)
                        throw Error(r(189))
                }
            }
            if (l.alternate !== c)
                throw Error(r(190))
        }
        if (l.tag !== 3)
            throw Error(r(188));
        return l.stateNode.current === l ? i : a
    }
    function h(i) {
        var a = i.tag;
        if (a === 5 || a === 26 || a === 27 || a === 6)
            return i;
        for (i = i.child; i !== null; ) {
            if (a = h(i),
            a !== null)
                return a;
            i = i.sibling
        }
        return null
    }
    var m = Object.assign
      , g = Symbol.for("react.element")
      , _ = Symbol.for("react.transitional.element")
      , x = Symbol.for("react.portal")
      , E = Symbol.for("react.fragment")
      , M = Symbol.for("react.strict_mode")
      , b = Symbol.for("react.profiler")
      , y = Symbol.for("react.provider")
      , T = Symbol.for("react.consumer")
      , D = Symbol.for("react.context")
      , C = Symbol.for("react.forward_ref")
      , P = Symbol.for("react.suspense")
      , A = Symbol.for("react.suspense_list")
      , F = Symbol.for("react.memo")
      , z = Symbol.for("react.lazy")
      , U = Symbol.for("react.activity")
      , R = Symbol.for("react.memo_cache_sentinel")
      , V = Symbol.iterator;
    function Q(i) {
        return i === null || typeof i != "object" ? null : (i = V && i[V] || i["@@iterator"],
        typeof i == "function" ? i : null)
    }
    var X = Symbol.for("react.client.reference");
    function oe(i) {
        if (i == null)
            return null;
        if (typeof i == "function")
            return i.$$typeof === X ? null : i.displayName || i.name || null;
        if (typeof i == "string")
            return i;
        switch (i) {
        case E:
            return "Fragment";
        case b:
            return "Profiler";
        case M:
            return "StrictMode";
        case P:
            return "Suspense";
        case A:
            return "SuspenseList";
        case U:
            return "Activity"
        }
        if (typeof i == "object")
            switch (i.$$typeof) {
            case x:
                return "Portal";
            case D:
                return (i.displayName || "Context") + ".Provider";
            case T:
                return (i._context.displayName || "Context") + ".Consumer";
            case C:
                var a = i.render;
                return i = i.displayName,
                i || (i = a.displayName || a.name || "",
                i = i !== "" ? "ForwardRef(" + i + ")" : "ForwardRef"),
                i;
            case F:
                return a = i.displayName || null,
                a !== null ? a : oe(i.type) || "Memo";
            case z:
                a = i._payload,
                i = i._init;
                try {
                    return oe(i(a))
                } catch {}
            }
        return null
    }
    var le = Array.isArray
      , O = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
      , W = t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE
      , H = {
        pending: !1,
        data: null,
        method: null,
        action: null
    }
      , Me = []
      , k = -1;
    function ee(i) {
        return {
            current: i
        }
    }
    function ge(i) {
        0 > k || (i.current = Me[k],
        Me[k] = null,
        k--)
    }
    function pe(i, a) {
        k++,
        Me[k] = i.current,
        i.current = a
    }
    var te = ee(null)
      , we = ee(null)
      , Se = ee(null)
      , De = ee(null);
    function Ve(i, a) {
        switch (pe(Se, a),
        pe(we, i),
        pe(te, null),
        a.nodeType) {
        case 9:
        case 11:
            i = (i = a.documentElement) && (i = i.namespaceURI) ? bx(i) : 0;
            break;
        default:
            if (i = a.tagName,
            a = a.namespaceURI)
                a = bx(a),
                i = Sx(a, i);
            else
                switch (i) {
                case "svg":
                    i = 1;
                    break;
                case "math":
                    i = 2;
                    break;
                default:
                    i = 0
                }
        }
        ge(te),
        pe(te, i)
    }
    function _t() {
        ge(te),
        ge(we),
        ge(Se)
    }
    function He(i) {
        i.memoizedState !== null && pe(De, i);
        var a = te.current
          , l = Sx(a, i.type);
        a !== l && (pe(we, i),
        pe(te, l))
    }
    function Pt(i) {
        we.current === i && (ge(te),
        ge(we)),
        De.current === i && (ge(De),
        vc._currentValue = H)
    }
    var kt = Object.prototype.hasOwnProperty
      , nt = n.unstable_scheduleCallback
      , G = n.unstable_cancelCallback
      , Zt = n.unstable_shouldYield
      , ot = n.unstable_requestPaint
      , it = n.unstable_now
      , rt = n.unstable_getCurrentPriorityLevel
      , pt = n.unstable_ImmediatePriority
      , Xe = n.unstable_UserBlockingPriority
      , B = n.unstable_NormalPriority
      , S = n.unstable_LowPriority
      , I = n.unstable_IdlePriority
      , q = n.log
      , se = n.unstable_setDisableYieldValue
      , J = null
      , de = null;
    function _e(i) {
        if (typeof q == "function" && se(i),
        de && typeof de.setStrictMode == "function")
            try {
                de.setStrictMode(J, i)
            } catch {}
    }
    var Ae = Math.clz32 ? Math.clz32 : $e
      , lt = Math.log
      , Le = Math.LN2;
    function $e(i) {
        return i >>>= 0,
        i === 0 ? 32 : 31 - (lt(i) / Le | 0) | 0
    }
    var ht = 256
      , yt = 4194304;
    function qe(i) {
        var a = i & 42;
        if (a !== 0)
            return a;
        switch (i & -i) {
        case 1:
            return 1;
        case 2:
            return 2;
        case 4:
            return 4;
        case 8:
            return 8;
        case 16:
            return 16;
        case 32:
            return 32;
        case 64:
            return 64;
        case 128:
            return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return i & 4194048;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
            return i & 62914560;
        case 67108864:
            return 67108864;
        case 134217728:
            return 134217728;
        case 268435456:
            return 268435456;
        case 536870912:
            return 536870912;
        case 1073741824:
            return 0;
        default:
            return i
        }
    }
    function Lt(i, a, l) {
        var c = i.pendingLanes;
        if (c === 0)
            return 0;
        var p = 0
          , v = i.suspendedLanes
          , w = i.pingedLanes;
        i = i.warmLanes;
        var L = c & 134217727;
        return L !== 0 ? (c = L & ~v,
        c !== 0 ? p = qe(c) : (w &= L,
        w !== 0 ? p = qe(w) : l || (l = L & ~i,
        l !== 0 && (p = qe(l))))) : (L = c & ~v,
        L !== 0 ? p = qe(L) : w !== 0 ? p = qe(w) : l || (l = c & ~i,
        l !== 0 && (p = qe(l)))),
        p === 0 ? 0 : a !== 0 && a !== p && (a & v) === 0 && (v = p & -p,
        l = a & -a,
        v >= l || v === 32 && (l & 4194048) !== 0) ? a : p
    }
    function Tt(i, a) {
        return (i.pendingLanes & ~(i.suspendedLanes & ~i.pingedLanes) & a) === 0
    }
    function qt(i, a) {
        switch (i) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
            return a + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
            return a + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
            return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
            return -1;
        default:
            return -1
        }
    }
    function re() {
        var i = ht;
        return ht <<= 1,
        (ht & 4194048) === 0 && (ht = 256),
        i
    }
    function Ye() {
        var i = yt;
        return yt <<= 1,
        (yt & 62914560) === 0 && (yt = 4194304),
        i
    }
    function Te(i) {
        for (var a = [], l = 0; 31 > l; l++)
            a.push(i);
        return a
    }
    function Ne(i, a) {
        i.pendingLanes |= a,
        a !== 268435456 && (i.suspendedLanes = 0,
        i.pingedLanes = 0,
        i.warmLanes = 0)
    }
    function Ke(i, a, l, c, p, v) {
        var w = i.pendingLanes;
        i.pendingLanes = l,
        i.suspendedLanes = 0,
        i.pingedLanes = 0,
        i.warmLanes = 0,
        i.expiredLanes &= l,
        i.entangledLanes &= l,
        i.errorRecoveryDisabledLanes &= l,
        i.shellSuspendCounter = 0;
        var L = i.entanglements
          , Y = i.expirationTimes
          , me = i.hiddenUpdates;
        for (l = w & ~l; 0 < l; ) {
            var Re = 31 - Ae(l)
              , Pe = 1 << Re;
            L[Re] = 0,
            Y[Re] = -1;
            var ve = me[Re];
            if (ve !== null)
                for (me[Re] = null,
                Re = 0; Re < ve.length; Re++) {
                    var be = ve[Re];
                    be !== null && (be.lane &= -536870913)
                }
            l &= ~Pe
        }
        c !== 0 && Ce(i, c, 0),
        v !== 0 && p === 0 && i.tag !== 0 && (i.suspendedLanes |= v & ~(w & ~a))
    }
    function Ce(i, a, l) {
        i.pendingLanes |= a,
        i.suspendedLanes &= ~a;
        var c = 31 - Ae(a);
        i.entangledLanes |= a,
        i.entanglements[c] = i.entanglements[c] | 1073741824 | l & 4194090
    }
    function at(i, a) {
        var l = i.entangledLanes |= a;
        for (i = i.entanglements; l; ) {
            var c = 31 - Ae(l)
              , p = 1 << c;
            p & a | i[c] & a && (i[c] |= a),
            l &= ~p
        }
    }
    function zt(i) {
        switch (i) {
        case 2:
            i = 1;
            break;
        case 8:
            i = 4;
            break;
        case 32:
            i = 16;
            break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
            i = 128;
            break;
        case 268435456:
            i = 134217728;
            break;
        default:
            i = 0
        }
        return i
    }
    function nn(i) {
        return i &= -i,
        2 < i ? 8 < i ? (i & 134217727) !== 0 ? 32 : 268435456 : 8 : 2
    }
    function j() {
        var i = W.p;
        return i !== 0 ? i : (i = window.event,
        i === void 0 ? 32 : Vx(i.type))
    }
    function ie(i, a) {
        var l = W.p;
        try {
            return W.p = i,
            a()
        } finally {
            W.p = l
        }
    }
    var fe = Math.random().toString(36).slice(2)
      , Ue = "__reactFiber$" + fe
      , ze = "__reactProps$" + fe
      , je = "__reactContainer$" + fe
      , bt = "__reactEvents$" + fe
      , Qe = "__reactListeners$" + fe
      , xt = "__reactHandles$" + fe
      , mt = "__reactResources$" + fe
      , Rt = "__reactMarker$" + fe;
    function ft(i) {
        delete i[Ue],
        delete i[ze],
        delete i[bt],
        delete i[Qe],
        delete i[xt]
    }
    function Dt(i) {
        var a = i[Ue];
        if (a)
            return a;
        for (var l = i.parentNode; l; ) {
            if (a = l[je] || l[Ue]) {
                if (l = a.alternate,
                a.child !== null || l !== null && l.child !== null)
                    for (i = Tx(i); i !== null; ) {
                        if (l = i[Ue])
                            return l;
                        i = Tx(i)
                    }
                return a
            }
            i = l,
            l = i.parentNode
        }
        return null
    }
    function rn(i) {
        if (i = i[Ue] || i[je]) {
            var a = i.tag;
            if (a === 5 || a === 6 || a === 13 || a === 26 || a === 27 || a === 3)
                return i
        }
        return null
    }
    function En(i) {
        var a = i.tag;
        if (a === 5 || a === 26 || a === 27 || a === 6)
            return i.stateNode;
        throw Error(r(33))
    }
    function Cn(i) {
        var a = i[mt];
        return a || (a = i[mt] = {
            hoistableStyles: new Map,
            hoistableScripts: new Map
        }),
        a
    }
    function on(i) {
        i[Rt] = !0
    }
    var $t = new Set
      , br = {};
    function si(i, a) {
        N(i, a),
        N(i + "Capture", a)
    }
    function N(i, a) {
        for (br[i] = a,
        i = 0; i < a.length; i++)
            $t.add(a[i])
    }
    var ae = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$")
      , ye = {}
      , xe = {};
    function ue(i) {
        return kt.call(xe, i) ? !0 : kt.call(ye, i) ? !1 : ae.test(i) ? xe[i] = !0 : (ye[i] = !0,
        !1)
    }
    function ke(i, a, l) {
        if (ue(a))
            if (l === null)
                i.removeAttribute(a);
            else {
                switch (typeof l) {
                case "undefined":
                case "function":
                case "symbol":
                    i.removeAttribute(a);
                    return;
                case "boolean":
                    var c = a.toLowerCase().slice(0, 5);
                    if (c !== "data-" && c !== "aria-") {
                        i.removeAttribute(a);
                        return
                    }
                }
                i.setAttribute(a, "" + l)
            }
    }
    function Ge(i, a, l) {
        if (l === null)
            i.removeAttribute(a);
        else {
            switch (typeof l) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
                i.removeAttribute(a);
                return
            }
            i.setAttribute(a, "" + l)
        }
    }
    function Ie(i, a, l, c) {
        if (c === null)
            i.removeAttribute(l);
        else {
            switch (typeof c) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
                i.removeAttribute(l);
                return
            }
            i.setAttributeNS(a, l, "" + c)
        }
    }
    var We, Mt;
    function St(i) {
        if (We === void 0)
            try {
                throw Error()
            } catch (l) {
                var a = l.stack.trim().match(/\n( *(at )?)/);
                We = a && a[1] || "",
                Mt = -1 < l.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < l.stack.indexOf("@") ? "@unknown:0:0" : ""
            }
        return `
` + We + i + Mt
    }
    var gt = !1;
    function Et(i, a) {
        if (!i || gt)
            return "";
        gt = !0;
        var l = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
            var c = {
                DetermineComponentFrameRoot: function() {
                    try {
                        if (a) {
                            var Pe = function() {
                                throw Error()
                            };
                            if (Object.defineProperty(Pe.prototype, "props", {
                                set: function() {
                                    throw Error()
                                }
                            }),
                            typeof Reflect == "object" && Reflect.construct) {
                                try {
                                    Reflect.construct(Pe, [])
                                } catch (be) {
                                    var ve = be
                                }
                                Reflect.construct(i, [], Pe)
                            } else {
                                try {
                                    Pe.call()
                                } catch (be) {
                                    ve = be
                                }
                                i.call(Pe.prototype)
                            }
                        } else {
                            try {
                                throw Error()
                            } catch (be) {
                                ve = be
                            }
                            (Pe = i()) && typeof Pe.catch == "function" && Pe.catch(function() {})
                        }
                    } catch (be) {
                        if (be && ve && typeof be.stack == "string")
                            return [be.stack, ve.stack]
                    }
                    return [null, null]
                }
            };
            c.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
            var p = Object.getOwnPropertyDescriptor(c.DetermineComponentFrameRoot, "name");
            p && p.configurable && Object.defineProperty(c.DetermineComponentFrameRoot, "name", {
                value: "DetermineComponentFrameRoot"
            });
            var v = c.DetermineComponentFrameRoot()
              , w = v[0]
              , L = v[1];
            if (w && L) {
                var Y = w.split(`
`)
                  , me = L.split(`
`);
                for (p = c = 0; c < Y.length && !Y[c].includes("DetermineComponentFrameRoot"); )
                    c++;
                for (; p < me.length && !me[p].includes("DetermineComponentFrameRoot"); )
                    p++;
                if (c === Y.length || p === me.length)
                    for (c = Y.length - 1,
                    p = me.length - 1; 1 <= c && 0 <= p && Y[c] !== me[p]; )
                        p--;
                for (; 1 <= c && 0 <= p; c--,
                p--)
                    if (Y[c] !== me[p]) {
                        if (c !== 1 || p !== 1)
                            do
                                if (c--,
                                p--,
                                0 > p || Y[c] !== me[p]) {
                                    var Re = `
` + Y[c].replace(" at new ", " at ");
                                    return i.displayName && Re.includes("<anonymous>") && (Re = Re.replace("<anonymous>", i.displayName)),
                                    Re
                                }
                            while (1 <= c && 0 <= p);
                        break
                    }
            }
        } finally {
            gt = !1,
            Error.prepareStackTrace = l
        }
        return (l = i ? i.displayName || i.name : "") ? St(l) : ""
    }
    function jt(i) {
        switch (i.tag) {
        case 26:
        case 27:
        case 5:
            return St(i.type);
        case 16:
            return St("Lazy");
        case 13:
            return St("Suspense");
        case 19:
            return St("SuspenseList");
        case 0:
        case 15:
            return Et(i.type, !1);
        case 11:
            return Et(i.type.render, !1);
        case 1:
            return Et(i.type, !0);
        case 31:
            return St("Activity");
        default:
            return ""
        }
    }
    function Tn(i) {
        try {
            var a = "";
            do
                a += jt(i),
                i = i.return;
            while (i);
            return a
        } catch (l) {
            return `
Error generating stack: ` + l.message + `
` + l.stack
        }
    }
    function Kt(i) {
        switch (typeof i) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
            return i;
        case "object":
            return i;
        default:
            return ""
        }
    }
    function an(i) {
        var a = i.type;
        return (i = i.nodeName) && i.toLowerCase() === "input" && (a === "checkbox" || a === "radio")
    }
    function At(i) {
        var a = an(i) ? "checked" : "value"
          , l = Object.getOwnPropertyDescriptor(i.constructor.prototype, a)
          , c = "" + i[a];
        if (!i.hasOwnProperty(a) && typeof l < "u" && typeof l.get == "function" && typeof l.set == "function") {
            var p = l.get
              , v = l.set;
            return Object.defineProperty(i, a, {
                configurable: !0,
                get: function() {
                    return p.call(this)
                },
                set: function(w) {
                    c = "" + w,
                    v.call(this, w)
                }
            }),
            Object.defineProperty(i, a, {
                enumerable: l.enumerable
            }),
            {
                getValue: function() {
                    return c
                },
                setValue: function(w) {
                    c = "" + w
                },
                stopTracking: function() {
                    i._valueTracker = null,
                    delete i[a]
                }
            }
        }
    }
    function Nn(i) {
        i._valueTracker || (i._valueTracker = At(i))
    }
    function cn(i) {
        if (!i)
            return !1;
        var a = i._valueTracker;
        if (!a)
            return !0;
        var l = a.getValue()
          , c = "";
        return i && (c = an(i) ? i.checked ? "true" : "false" : i.value),
        i = c,
        i !== l ? (a.setValue(i),
        !0) : !1
    }
    function hi(i) {
        if (i = i || (typeof document < "u" ? document : void 0),
        typeof i > "u")
            return null;
        try {
            return i.activeElement || i.body
        } catch {
            return i.body
        }
    }
    var Da = /[\n"\\]/g;
    function An(i) {
        return i.replace(Da, function(a) {
            return "\\" + a.charCodeAt(0).toString(16) + " "
        })
    }
    function Vr(i, a, l, c, p, v, w, L) {
        i.name = "",
        w != null && typeof w != "function" && typeof w != "symbol" && typeof w != "boolean" ? i.type = w : i.removeAttribute("type"),
        a != null ? w === "number" ? (a === 0 && i.value === "" || i.value != a) && (i.value = "" + Kt(a)) : i.value !== "" + Kt(a) && (i.value = "" + Kt(a)) : w !== "submit" && w !== "reset" || i.removeAttribute("value"),
        a != null ? pi(i, w, Kt(a)) : l != null ? pi(i, w, Kt(l)) : c != null && i.removeAttribute("value"),
        p == null && v != null && (i.defaultChecked = !!v),
        p != null && (i.checked = p && typeof p != "function" && typeof p != "symbol"),
        L != null && typeof L != "function" && typeof L != "symbol" && typeof L != "boolean" ? i.name = "" + Kt(L) : i.removeAttribute("name")
    }
    function Mn(i, a, l, c, p, v, w, L) {
        if (v != null && typeof v != "function" && typeof v != "symbol" && typeof v != "boolean" && (i.type = v),
        a != null || l != null) {
            if (!(v !== "submit" && v !== "reset" || a != null))
                return;
            l = l != null ? "" + Kt(l) : "",
            a = a != null ? "" + Kt(a) : l,
            L || a === i.value || (i.value = a),
            i.defaultValue = a
        }
        c = c ?? p,
        c = typeof c != "function" && typeof c != "symbol" && !!c,
        i.checked = L ? i.checked : !!c,
        i.defaultChecked = !!c,
        w != null && typeof w != "function" && typeof w != "symbol" && typeof w != "boolean" && (i.name = w)
    }
    function pi(i, a, l) {
        a === "number" && hi(i.ownerDocument) === i || i.defaultValue === "" + l || (i.defaultValue = "" + l)
    }
    function qn(i, a, l, c) {
        if (i = i.options,
        a) {
            a = {};
            for (var p = 0; p < l.length; p++)
                a["$" + l[p]] = !0;
            for (l = 0; l < i.length; l++)
                p = a.hasOwnProperty("$" + i[l].value),
                i[l].selected !== p && (i[l].selected = p),
                p && c && (i[l].defaultSelected = !0)
        } else {
            for (l = "" + Kt(l),
            a = null,
            p = 0; p < i.length; p++) {
                if (i[p].value === l) {
                    i[p].selected = !0,
                    c && (i[p].defaultSelected = !0);
                    return
                }
                a !== null || i[p].disabled || (a = i[p])
            }
            a !== null && (a.selected = !0)
        }
    }
    function ti(i, a, l) {
        if (a != null && (a = "" + Kt(a),
        a !== i.value && (i.value = a),
        l == null)) {
            i.defaultValue !== a && (i.defaultValue = a);
            return
        }
        i.defaultValue = l != null ? "" + Kt(l) : ""
    }
    function oi(i, a, l, c) {
        if (a == null) {
            if (c != null) {
                if (l != null)
                    throw Error(r(92));
                if (le(c)) {
                    if (1 < c.length)
                        throw Error(r(93));
                    c = c[0]
                }
                l = c
            }
            l == null && (l = ""),
            a = l
        }
        l = Kt(a),
        i.defaultValue = l,
        c = i.textContent,
        c === l && c !== "" && c !== null && (i.value = c)
    }
    function Sr(i, a) {
        if (a) {
            var l = i.firstChild;
            if (l && l === i.lastChild && l.nodeType === 3) {
                l.nodeValue = a;
                return
            }
        }
        i.textContent = a
    }
    var Hr = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
    function b_(i, a, l) {
        var c = a.indexOf("--") === 0;
        l == null || typeof l == "boolean" || l === "" ? c ? i.setProperty(a, "") : a === "float" ? i.cssFloat = "" : i[a] = "" : c ? i.setProperty(a, l) : typeof l != "number" || l === 0 || Hr.has(a) ? a === "float" ? i.cssFloat = l : i[a] = ("" + l).trim() : i[a] = l + "px"
    }
    function S_(i, a, l) {
        if (a != null && typeof a != "object")
            throw Error(r(62));
        if (i = i.style,
        l != null) {
            for (var c in l)
                !l.hasOwnProperty(c) || a != null && a.hasOwnProperty(c) || (c.indexOf("--") === 0 ? i.setProperty(c, "") : c === "float" ? i.cssFloat = "" : i[c] = "");
            for (var p in a)
                c = a[p],
                a.hasOwnProperty(p) && l[p] !== c && b_(i, p, c)
        } else
            for (var v in a)
                a.hasOwnProperty(v) && b_(i, v, a[v])
    }
    function ch(i) {
        if (i.indexOf("-") === -1)
            return !1;
        switch (i) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
            return !1;
        default:
            return !0
        }
    }
    var rT = new Map([["acceptCharset", "accept-charset"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"], ["crossOrigin", "crossorigin"], ["accentHeight", "accent-height"], ["alignmentBaseline", "alignment-baseline"], ["arabicForm", "arabic-form"], ["baselineShift", "baseline-shift"], ["capHeight", "cap-height"], ["clipPath", "clip-path"], ["clipRule", "clip-rule"], ["colorInterpolation", "color-interpolation"], ["colorInterpolationFilters", "color-interpolation-filters"], ["colorProfile", "color-profile"], ["colorRendering", "color-rendering"], ["dominantBaseline", "dominant-baseline"], ["enableBackground", "enable-background"], ["fillOpacity", "fill-opacity"], ["fillRule", "fill-rule"], ["floodColor", "flood-color"], ["floodOpacity", "flood-opacity"], ["fontFamily", "font-family"], ["fontSize", "font-size"], ["fontSizeAdjust", "font-size-adjust"], ["fontStretch", "font-stretch"], ["fontStyle", "font-style"], ["fontVariant", "font-variant"], ["fontWeight", "font-weight"], ["glyphName", "glyph-name"], ["glyphOrientationHorizontal", "glyph-orientation-horizontal"], ["glyphOrientationVertical", "glyph-orientation-vertical"], ["horizAdvX", "horiz-adv-x"], ["horizOriginX", "horiz-origin-x"], ["imageRendering", "image-rendering"], ["letterSpacing", "letter-spacing"], ["lightingColor", "lighting-color"], ["markerEnd", "marker-end"], ["markerMid", "marker-mid"], ["markerStart", "marker-start"], ["overlinePosition", "overline-position"], ["overlineThickness", "overline-thickness"], ["paintOrder", "paint-order"], ["panose-1", "panose-1"], ["pointerEvents", "pointer-events"], ["renderingIntent", "rendering-intent"], ["shapeRendering", "shape-rendering"], ["stopColor", "stop-color"], ["stopOpacity", "stop-opacity"], ["strikethroughPosition", "strikethrough-position"], ["strikethroughThickness", "strikethrough-thickness"], ["strokeDasharray", "stroke-dasharray"], ["strokeDashoffset", "stroke-dashoffset"], ["strokeLinecap", "stroke-linecap"], ["strokeLinejoin", "stroke-linejoin"], ["strokeMiterlimit", "stroke-miterlimit"], ["strokeOpacity", "stroke-opacity"], ["strokeWidth", "stroke-width"], ["textAnchor", "text-anchor"], ["textDecoration", "text-decoration"], ["textRendering", "text-rendering"], ["transformOrigin", "transform-origin"], ["underlinePosition", "underline-position"], ["underlineThickness", "underline-thickness"], ["unicodeBidi", "unicode-bidi"], ["unicodeRange", "unicode-range"], ["unitsPerEm", "units-per-em"], ["vAlphabetic", "v-alphabetic"], ["vHanging", "v-hanging"], ["vIdeographic", "v-ideographic"], ["vMathematical", "v-mathematical"], ["vectorEffect", "vector-effect"], ["vertAdvY", "vert-adv-y"], ["vertOriginX", "vert-origin-x"], ["vertOriginY", "vert-origin-y"], ["wordSpacing", "word-spacing"], ["writingMode", "writing-mode"], ["xmlnsXlink", "xmlns:xlink"], ["xHeight", "x-height"]])
      , aT = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
    function xu(i) {
        return aT.test("" + i) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : i
    }
    var uh = null;
    function dh(i) {
        return i = i.target || i.srcElement || window,
        i.correspondingUseElement && (i = i.correspondingUseElement),
        i.nodeType === 3 ? i.parentNode : i
    }
    var lo = null
      , co = null;
    function E_(i) {
        var a = rn(i);
        if (a && (i = a.stateNode)) {
            var l = i[ze] || null;
            e: switch (i = a.stateNode,
            a.type) {
            case "input":
                if (Vr(i, l.value, l.defaultValue, l.defaultValue, l.checked, l.defaultChecked, l.type, l.name),
                a = l.name,
                l.type === "radio" && a != null) {
                    for (l = i; l.parentNode; )
                        l = l.parentNode;
                    for (l = l.querySelectorAll('input[name="' + An("" + a) + '"][type="radio"]'),
                    a = 0; a < l.length; a++) {
                        var c = l[a];
                        if (c !== i && c.form === i.form) {
                            var p = c[ze] || null;
                            if (!p)
                                throw Error(r(90));
                            Vr(c, p.value, p.defaultValue, p.defaultValue, p.checked, p.defaultChecked, p.type, p.name)
                        }
                    }
                    for (a = 0; a < l.length; a++)
                        c = l[a],
                        c.form === i.form && cn(c)
                }
                break e;
            case "textarea":
                ti(i, l.value, l.defaultValue);
                break e;
            case "select":
                a = l.value,
                a != null && qn(i, !!l.multiple, a, !1)
            }
        }
    }
    var fh = !1;
    function M_(i, a, l) {
        if (fh)
            return i(a, l);
        fh = !0;
        try {
            var c = i(a);
            return c
        } finally {
            if (fh = !1,
            (lo !== null || co !== null) && (ad(),
            lo && (a = lo,
            i = co,
            co = lo = null,
            E_(a),
            i)))
                for (a = 0; a < i.length; a++)
                    E_(i[a])
        }
    }
    function Dl(i, a) {
        var l = i.stateNode;
        if (l === null)
            return null;
        var c = l[ze] || null;
        if (c === null)
            return null;
        l = c[a];
        e: switch (a) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
            (c = !c.disabled) || (i = i.type,
            c = !(i === "button" || i === "input" || i === "select" || i === "textarea")),
            i = !c;
            break e;
        default:
            i = !1
        }
        if (i)
            return null;
        if (l && typeof l != "function")
            throw Error(r(231, a, typeof l));
        return l
    }
    var Gr = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
      , hh = !1;
    if (Gr)
        try {
            var Ul = {};
            Object.defineProperty(Ul, "passive", {
                get: function() {
                    hh = !0
                }
            }),
            window.addEventListener("test", Ul, Ul),
            window.removeEventListener("test", Ul, Ul)
        } catch {
            hh = !1
        }
    var Ua = null
      , ph = null
      , bu = null;
    function w_() {
        if (bu)
            return bu;
        var i, a = ph, l = a.length, c, p = "value"in Ua ? Ua.value : Ua.textContent, v = p.length;
        for (i = 0; i < l && a[i] === p[i]; i++)
            ;
        var w = l - i;
        for (c = 1; c <= w && a[l - c] === p[v - c]; c++)
            ;
        return bu = p.slice(i, 1 < c ? 1 - c : void 0)
    }
    function Su(i) {
        var a = i.keyCode;
        return "charCode"in i ? (i = i.charCode,
        i === 0 && a === 13 && (i = 13)) : i = a,
        i === 10 && (i = 13),
        32 <= i || i === 13 ? i : 0
    }
    function Eu() {
        return !0
    }
    function T_() {
        return !1
    }
    function Ai(i) {
        function a(l, c, p, v, w) {
            this._reactName = l,
            this._targetInst = p,
            this.type = c,
            this.nativeEvent = v,
            this.target = w,
            this.currentTarget = null;
            for (var L in i)
                i.hasOwnProperty(L) && (l = i[L],
                this[L] = l ? l(v) : v[L]);
            return this.isDefaultPrevented = (v.defaultPrevented != null ? v.defaultPrevented : v.returnValue === !1) ? Eu : T_,
            this.isPropagationStopped = T_,
            this
        }
        return m(a.prototype, {
            preventDefault: function() {
                this.defaultPrevented = !0;
                var l = this.nativeEvent;
                l && (l.preventDefault ? l.preventDefault() : typeof l.returnValue != "unknown" && (l.returnValue = !1),
                this.isDefaultPrevented = Eu)
            },
            stopPropagation: function() {
                var l = this.nativeEvent;
                l && (l.stopPropagation ? l.stopPropagation() : typeof l.cancelBubble != "unknown" && (l.cancelBubble = !0),
                this.isPropagationStopped = Eu)
            },
            persist: function() {},
            isPersistent: Eu
        }),
        a
    }
    var Ss = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(i) {
            return i.timeStamp || Date.now()
        },
        defaultPrevented: 0,
        isTrusted: 0
    }, Mu = Ai(Ss), Ll = m({}, Ss, {
        view: 0,
        detail: 0
    }), sT = Ai(Ll), mh, gh, Nl, wu = m({}, Ll, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: _h,
        button: 0,
        buttons: 0,
        relatedTarget: function(i) {
            return i.relatedTarget === void 0 ? i.fromElement === i.srcElement ? i.toElement : i.fromElement : i.relatedTarget
        },
        movementX: function(i) {
            return "movementX"in i ? i.movementX : (i !== Nl && (Nl && i.type === "mousemove" ? (mh = i.screenX - Nl.screenX,
            gh = i.screenY - Nl.screenY) : gh = mh = 0,
            Nl = i),
            mh)
        },
        movementY: function(i) {
            return "movementY"in i ? i.movementY : gh
        }
    }), A_ = Ai(wu), oT = m({}, wu, {
        dataTransfer: 0
    }), lT = Ai(oT), cT = m({}, Ll, {
        relatedTarget: 0
    }), vh = Ai(cT), uT = m({}, Ss, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    }), dT = Ai(uT), fT = m({}, Ss, {
        clipboardData: function(i) {
            return "clipboardData"in i ? i.clipboardData : window.clipboardData
        }
    }), hT = Ai(fT), pT = m({}, Ss, {
        data: 0
    }), R_ = Ai(pT), mT = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
    }, gT = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
    }, vT = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
    };
    function _T(i) {
        var a = this.nativeEvent;
        return a.getModifierState ? a.getModifierState(i) : (i = vT[i]) ? !!a[i] : !1
    }
    function _h() {
        return _T
    }
    var yT = m({}, Ll, {
        key: function(i) {
            if (i.key) {
                var a = mT[i.key] || i.key;
                if (a !== "Unidentified")
                    return a
            }
            return i.type === "keypress" ? (i = Su(i),
            i === 13 ? "Enter" : String.fromCharCode(i)) : i.type === "keydown" || i.type === "keyup" ? gT[i.keyCode] || "Unidentified" : ""
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: _h,
        charCode: function(i) {
            return i.type === "keypress" ? Su(i) : 0
        },
        keyCode: function(i) {
            return i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0
        },
        which: function(i) {
            return i.type === "keypress" ? Su(i) : i.type === "keydown" || i.type === "keyup" ? i.keyCode : 0
        }
    })
      , xT = Ai(yT)
      , bT = m({}, wu, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
    })
      , C_ = Ai(bT)
      , ST = m({}, Ll, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: _h
    })
      , ET = Ai(ST)
      , MT = m({}, Ss, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
    })
      , wT = Ai(MT)
      , TT = m({}, wu, {
        deltaX: function(i) {
            return "deltaX"in i ? i.deltaX : "wheelDeltaX"in i ? -i.wheelDeltaX : 0
        },
        deltaY: function(i) {
            return "deltaY"in i ? i.deltaY : "wheelDeltaY"in i ? -i.wheelDeltaY : "wheelDelta"in i ? -i.wheelDelta : 0
        },
        deltaZ: 0,
        deltaMode: 0
    })
      , AT = Ai(TT)
      , RT = m({}, Ss, {
        newState: 0,
        oldState: 0
    })
      , CT = Ai(RT)
      , DT = [9, 13, 27, 32]
      , yh = Gr && "CompositionEvent"in window
      , Ol = null;
    Gr && "documentMode"in document && (Ol = document.documentMode);
    var UT = Gr && "TextEvent"in window && !Ol
      , D_ = Gr && (!yh || Ol && 8 < Ol && 11 >= Ol)
      , U_ = " "
      , L_ = !1;
    function N_(i, a) {
        switch (i) {
        case "keyup":
            return DT.indexOf(a.keyCode) !== -1;
        case "keydown":
            return a.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
            return !0;
        default:
            return !1
        }
    }
    function O_(i) {
        return i = i.detail,
        typeof i == "object" && "data"in i ? i.data : null
    }
    var uo = !1;
    function LT(i, a) {
        switch (i) {
        case "compositionend":
            return O_(a);
        case "keypress":
            return a.which !== 32 ? null : (L_ = !0,
            U_);
        case "textInput":
            return i = a.data,
            i === U_ && L_ ? null : i;
        default:
            return null
        }
    }
    function NT(i, a) {
        if (uo)
            return i === "compositionend" || !yh && N_(i, a) ? (i = w_(),
            bu = ph = Ua = null,
            uo = !1,
            i) : null;
        switch (i) {
        case "paste":
            return null;
        case "keypress":
            if (!(a.ctrlKey || a.altKey || a.metaKey) || a.ctrlKey && a.altKey) {
                if (a.char && 1 < a.char.length)
                    return a.char;
                if (a.which)
                    return String.fromCharCode(a.which)
            }
            return null;
        case "compositionend":
            return D_ && a.locale !== "ko" ? null : a.data;
        default:
            return null
        }
    }
    var OT = {
        color: !0,
        date: !0,
        datetime: !0,
        "datetime-local": !0,
        email: !0,
        month: !0,
        number: !0,
        password: !0,
        range: !0,
        search: !0,
        tel: !0,
        text: !0,
        time: !0,
        url: !0,
        week: !0
    };
    function P_(i) {
        var a = i && i.nodeName && i.nodeName.toLowerCase();
        return a === "input" ? !!OT[i.type] : a === "textarea"
    }
    function I_(i, a, l, c) {
        lo ? co ? co.push(c) : co = [c] : lo = c,
        a = dd(a, "onChange"),
        0 < a.length && (l = new Mu("onChange","change",null,l,c),
        i.push({
            event: l,
            listeners: a
        }))
    }
    var Pl = null
      , Il = null;
    function PT(i) {
        gx(i, 0)
    }
    function Tu(i) {
        var a = En(i);
        if (cn(a))
            return i
    }
    function z_(i, a) {
        if (i === "change")
            return a
    }
    var k_ = !1;
    if (Gr) {
        var xh;
        if (Gr) {
            var bh = "oninput"in document;
            if (!bh) {
                var F_ = document.createElement("div");
                F_.setAttribute("oninput", "return;"),
                bh = typeof F_.oninput == "function"
            }
            xh = bh
        } else
            xh = !1;
        k_ = xh && (!document.documentMode || 9 < document.documentMode)
    }
    function B_() {
        Pl && (Pl.detachEvent("onpropertychange", V_),
        Il = Pl = null)
    }
    function V_(i) {
        if (i.propertyName === "value" && Tu(Il)) {
            var a = [];
            I_(a, Il, i, dh(i)),
            M_(PT, a)
        }
    }
    function IT(i, a, l) {
        i === "focusin" ? (B_(),
        Pl = a,
        Il = l,
        Pl.attachEvent("onpropertychange", V_)) : i === "focusout" && B_()
    }
    function zT(i) {
        if (i === "selectionchange" || i === "keyup" || i === "keydown")
            return Tu(Il)
    }
    function kT(i, a) {
        if (i === "click")
            return Tu(a)
    }
    function FT(i, a) {
        if (i === "input" || i === "change")
            return Tu(a)
    }
    function BT(i, a) {
        return i === a && (i !== 0 || 1 / i === 1 / a) || i !== i && a !== a
    }
    var Pi = typeof Object.is == "function" ? Object.is : BT;
    function zl(i, a) {
        if (Pi(i, a))
            return !0;
        if (typeof i != "object" || i === null || typeof a != "object" || a === null)
            return !1;
        var l = Object.keys(i)
          , c = Object.keys(a);
        if (l.length !== c.length)
            return !1;
        for (c = 0; c < l.length; c++) {
            var p = l[c];
            if (!kt.call(a, p) || !Pi(i[p], a[p]))
                return !1
        }
        return !0
    }
    function H_(i) {
        for (; i && i.firstChild; )
            i = i.firstChild;
        return i
    }
    function G_(i, a) {
        var l = H_(i);
        i = 0;
        for (var c; l; ) {
            if (l.nodeType === 3) {
                if (c = i + l.textContent.length,
                i <= a && c >= a)
                    return {
                        node: l,
                        offset: a - i
                    };
                i = c
            }
            e: {
                for (; l; ) {
                    if (l.nextSibling) {
                        l = l.nextSibling;
                        break e
                    }
                    l = l.parentNode
                }
                l = void 0
            }
            l = H_(l)
        }
    }
    function j_(i, a) {
        return i && a ? i === a ? !0 : i && i.nodeType === 3 ? !1 : a && a.nodeType === 3 ? j_(i, a.parentNode) : "contains"in i ? i.contains(a) : i.compareDocumentPosition ? !!(i.compareDocumentPosition(a) & 16) : !1 : !1
    }
    function W_(i) {
        i = i != null && i.ownerDocument != null && i.ownerDocument.defaultView != null ? i.ownerDocument.defaultView : window;
        for (var a = hi(i.document); a instanceof i.HTMLIFrameElement; ) {
            try {
                var l = typeof a.contentWindow.location.href == "string"
            } catch {
                l = !1
            }
            if (l)
                i = a.contentWindow;
            else
                break;
            a = hi(i.document)
        }
        return a
    }
    function Sh(i) {
        var a = i && i.nodeName && i.nodeName.toLowerCase();
        return a && (a === "input" && (i.type === "text" || i.type === "search" || i.type === "tel" || i.type === "url" || i.type === "password") || a === "textarea" || i.contentEditable === "true")
    }
    var VT = Gr && "documentMode"in document && 11 >= document.documentMode
      , fo = null
      , Eh = null
      , kl = null
      , Mh = !1;
    function X_(i, a, l) {
        var c = l.window === l ? l.document : l.nodeType === 9 ? l : l.ownerDocument;
        Mh || fo == null || fo !== hi(c) || (c = fo,
        "selectionStart"in c && Sh(c) ? c = {
            start: c.selectionStart,
            end: c.selectionEnd
        } : (c = (c.ownerDocument && c.ownerDocument.defaultView || window).getSelection(),
        c = {
            anchorNode: c.anchorNode,
            anchorOffset: c.anchorOffset,
            focusNode: c.focusNode,
            focusOffset: c.focusOffset
        }),
        kl && zl(kl, c) || (kl = c,
        c = dd(Eh, "onSelect"),
        0 < c.length && (a = new Mu("onSelect","select",null,a,l),
        i.push({
            event: a,
            listeners: c
        }),
        a.target = fo)))
    }
    function Es(i, a) {
        var l = {};
        return l[i.toLowerCase()] = a.toLowerCase(),
        l["Webkit" + i] = "webkit" + a,
        l["Moz" + i] = "moz" + a,
        l
    }
    var ho = {
        animationend: Es("Animation", "AnimationEnd"),
        animationiteration: Es("Animation", "AnimationIteration"),
        animationstart: Es("Animation", "AnimationStart"),
        transitionrun: Es("Transition", "TransitionRun"),
        transitionstart: Es("Transition", "TransitionStart"),
        transitioncancel: Es("Transition", "TransitionCancel"),
        transitionend: Es("Transition", "TransitionEnd")
    }
      , wh = {}
      , q_ = {};
    Gr && (q_ = document.createElement("div").style,
    "AnimationEvent"in window || (delete ho.animationend.animation,
    delete ho.animationiteration.animation,
    delete ho.animationstart.animation),
    "TransitionEvent"in window || delete ho.transitionend.transition);
    function Ms(i) {
        if (wh[i])
            return wh[i];
        if (!ho[i])
            return i;
        var a = ho[i], l;
        for (l in a)
            if (a.hasOwnProperty(l) && l in q_)
                return wh[i] = a[l];
        return i
    }
    var Y_ = Ms("animationend")
      , Z_ = Ms("animationiteration")
      , $_ = Ms("animationstart")
      , HT = Ms("transitionrun")
      , GT = Ms("transitionstart")
      , jT = Ms("transitioncancel")
      , K_ = Ms("transitionend")
      , Q_ = new Map
      , Th = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    Th.push("scrollEnd");
    function cr(i, a) {
        Q_.set(i, a),
        si(a, [i])
    }
    var J_ = new WeakMap;
    function Yi(i, a) {
        if (typeof i == "object" && i !== null) {
            var l = J_.get(i);
            return l !== void 0 ? l : (a = {
                value: i,
                source: a,
                stack: Tn(a)
            },
            J_.set(i, a),
            a)
        }
        return {
            value: i,
            source: a,
            stack: Tn(a)
        }
    }
    var Zi = []
      , po = 0
      , Ah = 0;
    function Au() {
        for (var i = po, a = Ah = po = 0; a < i; ) {
            var l = Zi[a];
            Zi[a++] = null;
            var c = Zi[a];
            Zi[a++] = null;
            var p = Zi[a];
            Zi[a++] = null;
            var v = Zi[a];
            if (Zi[a++] = null,
            c !== null && p !== null) {
                var w = c.pending;
                w === null ? p.next = p : (p.next = w.next,
                w.next = p),
                c.pending = p
            }
            v !== 0 && e0(l, p, v)
        }
    }
    function Ru(i, a, l, c) {
        Zi[po++] = i,
        Zi[po++] = a,
        Zi[po++] = l,
        Zi[po++] = c,
        Ah |= c,
        i.lanes |= c,
        i = i.alternate,
        i !== null && (i.lanes |= c)
    }
    function Rh(i, a, l, c) {
        return Ru(i, a, l, c),
        Cu(i)
    }
    function mo(i, a) {
        return Ru(i, null, null, a),
        Cu(i)
    }
    function e0(i, a, l) {
        i.lanes |= l;
        var c = i.alternate;
        c !== null && (c.lanes |= l);
        for (var p = !1, v = i.return; v !== null; )
            v.childLanes |= l,
            c = v.alternate,
            c !== null && (c.childLanes |= l),
            v.tag === 22 && (i = v.stateNode,
            i === null || i._visibility & 1 || (p = !0)),
            i = v,
            v = v.return;
        return i.tag === 3 ? (v = i.stateNode,
        p && a !== null && (p = 31 - Ae(l),
        i = v.hiddenUpdates,
        c = i[p],
        c === null ? i[p] = [a] : c.push(a),
        a.lane = l | 536870912),
        v) : null
    }
    function Cu(i) {
        if (50 < cc)
            throw cc = 0,
            Op = null,
            Error(r(185));
        for (var a = i.return; a !== null; )
            i = a,
            a = i.return;
        return i.tag === 3 ? i.stateNode : null
    }
    var go = {};
    function WT(i, a, l, c) {
        this.tag = i,
        this.key = l,
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
        this.index = 0,
        this.refCleanup = this.ref = null,
        this.pendingProps = a,
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
        this.mode = c,
        this.subtreeFlags = this.flags = 0,
        this.deletions = null,
        this.childLanes = this.lanes = 0,
        this.alternate = null
    }
    function Ii(i, a, l, c) {
        return new WT(i,a,l,c)
    }
    function Ch(i) {
        return i = i.prototype,
        !(!i || !i.isReactComponent)
    }
    function jr(i, a) {
        var l = i.alternate;
        return l === null ? (l = Ii(i.tag, a, i.key, i.mode),
        l.elementType = i.elementType,
        l.type = i.type,
        l.stateNode = i.stateNode,
        l.alternate = i,
        i.alternate = l) : (l.pendingProps = a,
        l.type = i.type,
        l.flags = 0,
        l.subtreeFlags = 0,
        l.deletions = null),
        l.flags = i.flags & 65011712,
        l.childLanes = i.childLanes,
        l.lanes = i.lanes,
        l.child = i.child,
        l.memoizedProps = i.memoizedProps,
        l.memoizedState = i.memoizedState,
        l.updateQueue = i.updateQueue,
        a = i.dependencies,
        l.dependencies = a === null ? null : {
            lanes: a.lanes,
            firstContext: a.firstContext
        },
        l.sibling = i.sibling,
        l.index = i.index,
        l.ref = i.ref,
        l.refCleanup = i.refCleanup,
        l
    }
    function t0(i, a) {
        i.flags &= 65011714;
        var l = i.alternate;
        return l === null ? (i.childLanes = 0,
        i.lanes = a,
        i.child = null,
        i.subtreeFlags = 0,
        i.memoizedProps = null,
        i.memoizedState = null,
        i.updateQueue = null,
        i.dependencies = null,
        i.stateNode = null) : (i.childLanes = l.childLanes,
        i.lanes = l.lanes,
        i.child = l.child,
        i.subtreeFlags = 0,
        i.deletions = null,
        i.memoizedProps = l.memoizedProps,
        i.memoizedState = l.memoizedState,
        i.updateQueue = l.updateQueue,
        i.type = l.type,
        a = l.dependencies,
        i.dependencies = a === null ? null : {
            lanes: a.lanes,
            firstContext: a.firstContext
        }),
        i
    }
    function Du(i, a, l, c, p, v) {
        var w = 0;
        if (c = i,
        typeof i == "function")
            Ch(i) && (w = 1);
        else if (typeof i == "string")
            w = qA(i, l, te.current) ? 26 : i === "html" || i === "head" || i === "body" ? 27 : 5;
        else
            e: switch (i) {
            case U:
                return i = Ii(31, l, a, p),
                i.elementType = U,
                i.lanes = v,
                i;
            case E:
                return ws(l.children, p, v, a);
            case M:
                w = 8,
                p |= 24;
                break;
            case b:
                return i = Ii(12, l, a, p | 2),
                i.elementType = b,
                i.lanes = v,
                i;
            case P:
                return i = Ii(13, l, a, p),
                i.elementType = P,
                i.lanes = v,
                i;
            case A:
                return i = Ii(19, l, a, p),
                i.elementType = A,
                i.lanes = v,
                i;
            default:
                if (typeof i == "object" && i !== null)
                    switch (i.$$typeof) {
                    case y:
                    case D:
                        w = 10;
                        break e;
                    case T:
                        w = 9;
                        break e;
                    case C:
                        w = 11;
                        break e;
                    case F:
                        w = 14;
                        break e;
                    case z:
                        w = 16,
                        c = null;
                        break e
                    }
                w = 29,
                l = Error(r(130, i === null ? "null" : typeof i, "")),
                c = null
            }
        return a = Ii(w, l, a, p),
        a.elementType = i,
        a.type = c,
        a.lanes = v,
        a
    }
    function ws(i, a, l, c) {
        return i = Ii(7, i, c, a),
        i.lanes = l,
        i
    }
    function Dh(i, a, l) {
        return i = Ii(6, i, null, a),
        i.lanes = l,
        i
    }
    function Uh(i, a, l) {
        return a = Ii(4, i.children !== null ? i.children : [], i.key, a),
        a.lanes = l,
        a.stateNode = {
            containerInfo: i.containerInfo,
            pendingChildren: null,
            implementation: i.implementation
        },
        a
    }
    var vo = []
      , _o = 0
      , Uu = null
      , Lu = 0
      , $i = []
      , Ki = 0
      , Ts = null
      , Wr = 1
      , Xr = "";
    function As(i, a) {
        vo[_o++] = Lu,
        vo[_o++] = Uu,
        Uu = i,
        Lu = a
    }
    function n0(i, a, l) {
        $i[Ki++] = Wr,
        $i[Ki++] = Xr,
        $i[Ki++] = Ts,
        Ts = i;
        var c = Wr;
        i = Xr;
        var p = 32 - Ae(c) - 1;
        c &= ~(1 << p),
        l += 1;
        var v = 32 - Ae(a) + p;
        if (30 < v) {
            var w = p - p % 5;
            v = (c & (1 << w) - 1).toString(32),
            c >>= w,
            p -= w,
            Wr = 1 << 32 - Ae(a) + p | l << p | c,
            Xr = v + i
        } else
            Wr = 1 << v | l << p | c,
            Xr = i
    }
    function Lh(i) {
        i.return !== null && (As(i, 1),
        n0(i, 1, 0))
    }
    function Nh(i) {
        for (; i === Uu; )
            Uu = vo[--_o],
            vo[_o] = null,
            Lu = vo[--_o],
            vo[_o] = null;
        for (; i === Ts; )
            Ts = $i[--Ki],
            $i[Ki] = null,
            Xr = $i[--Ki],
            $i[Ki] = null,
            Wr = $i[--Ki],
            $i[Ki] = null
    }
    var yi = null
      , On = null
      , hn = !1
      , Rs = null
      , Er = !1
      , Oh = Error(r(519));
    function Cs(i) {
        var a = Error(r(418, ""));
        throw Vl(Yi(a, i)),
        Oh
    }
    function i0(i) {
        var a = i.stateNode
          , l = i.type
          , c = i.memoizedProps;
        switch (a[Ue] = i,
        a[ze] = c,
        l) {
        case "dialog":
            Jt("cancel", a),
            Jt("close", a);
            break;
        case "iframe":
        case "object":
        case "embed":
            Jt("load", a);
            break;
        case "video":
        case "audio":
            for (l = 0; l < dc.length; l++)
                Jt(dc[l], a);
            break;
        case "source":
            Jt("error", a);
            break;
        case "img":
        case "image":
        case "link":
            Jt("error", a),
            Jt("load", a);
            break;
        case "details":
            Jt("toggle", a);
            break;
        case "input":
            Jt("invalid", a),
            Mn(a, c.value, c.defaultValue, c.checked, c.defaultChecked, c.type, c.name, !0),
            Nn(a);
            break;
        case "select":
            Jt("invalid", a);
            break;
        case "textarea":
            Jt("invalid", a),
            oi(a, c.value, c.defaultValue, c.children),
            Nn(a)
        }
        l = c.children,
        typeof l != "string" && typeof l != "number" && typeof l != "bigint" || a.textContent === "" + l || c.suppressHydrationWarning === !0 || xx(a.textContent, l) ? (c.popover != null && (Jt("beforetoggle", a),
        Jt("toggle", a)),
        c.onScroll != null && Jt("scroll", a),
        c.onScrollEnd != null && Jt("scrollend", a),
        c.onClick != null && (a.onclick = fd),
        a = !0) : a = !1,
        a || Cs(i)
    }
    function r0(i) {
        for (yi = i.return; yi; )
            switch (yi.tag) {
            case 5:
            case 13:
                Er = !1;
                return;
            case 27:
            case 3:
                Er = !0;
                return;
            default:
                yi = yi.return
            }
    }
    function Fl(i) {
        if (i !== yi)
            return !1;
        if (!hn)
            return r0(i),
            hn = !0,
            !1;
        var a = i.tag, l;
        if ((l = a !== 3 && a !== 27) && ((l = a === 5) && (l = i.type,
        l = !(l !== "form" && l !== "button") || $p(i.type, i.memoizedProps)),
        l = !l),
        l && On && Cs(i),
        r0(i),
        a === 13) {
            if (i = i.memoizedState,
            i = i !== null ? i.dehydrated : null,
            !i)
                throw Error(r(317));
            e: {
                for (i = i.nextSibling,
                a = 0; i; ) {
                    if (i.nodeType === 8)
                        if (l = i.data,
                        l === "/$") {
                            if (a === 0) {
                                On = dr(i.nextSibling);
                                break e
                            }
                            a--
                        } else
                            l !== "$" && l !== "$!" && l !== "$?" || a++;
                    i = i.nextSibling
                }
                On = null
            }
        } else
            a === 27 ? (a = On,
            qa(i.type) ? (i = em,
            em = null,
            On = i) : On = a) : On = yi ? dr(i.stateNode.nextSibling) : null;
        return !0
    }
    function Bl() {
        On = yi = null,
        hn = !1
    }
    function a0() {
        var i = Rs;
        return i !== null && (Di === null ? Di = i : Di.push.apply(Di, i),
        Rs = null),
        i
    }
    function Vl(i) {
        Rs === null ? Rs = [i] : Rs.push(i)
    }
    var Ph = ee(null)
      , Ds = null
      , qr = null;
    function La(i, a, l) {
        pe(Ph, a._currentValue),
        a._currentValue = l
    }
    function Yr(i) {
        i._currentValue = Ph.current,
        ge(Ph)
    }
    function Ih(i, a, l) {
        for (; i !== null; ) {
            var c = i.alternate;
            if ((i.childLanes & a) !== a ? (i.childLanes |= a,
            c !== null && (c.childLanes |= a)) : c !== null && (c.childLanes & a) !== a && (c.childLanes |= a),
            i === l)
                break;
            i = i.return
        }
    }
    function zh(i, a, l, c) {
        var p = i.child;
        for (p !== null && (p.return = i); p !== null; ) {
            var v = p.dependencies;
            if (v !== null) {
                var w = p.child;
                v = v.firstContext;
                e: for (; v !== null; ) {
                    var L = v;
                    v = p;
                    for (var Y = 0; Y < a.length; Y++)
                        if (L.context === a[Y]) {
                            v.lanes |= l,
                            L = v.alternate,
                            L !== null && (L.lanes |= l),
                            Ih(v.return, l, i),
                            c || (w = null);
                            break e
                        }
                    v = L.next
                }
            } else if (p.tag === 18) {
                if (w = p.return,
                w === null)
                    throw Error(r(341));
                w.lanes |= l,
                v = w.alternate,
                v !== null && (v.lanes |= l),
                Ih(w, l, i),
                w = null
            } else
                w = p.child;
            if (w !== null)
                w.return = p;
            else
                for (w = p; w !== null; ) {
                    if (w === i) {
                        w = null;
                        break
                    }
                    if (p = w.sibling,
                    p !== null) {
                        p.return = w.return,
                        w = p;
                        break
                    }
                    w = w.return
                }
            p = w
        }
    }
    function Hl(i, a, l, c) {
        i = null;
        for (var p = a, v = !1; p !== null; ) {
            if (!v) {
                if ((p.flags & 524288) !== 0)
                    v = !0;
                else if ((p.flags & 262144) !== 0)
                    break
            }
            if (p.tag === 10) {
                var w = p.alternate;
                if (w === null)
                    throw Error(r(387));
                if (w = w.memoizedProps,
                w !== null) {
                    var L = p.type;
                    Pi(p.pendingProps.value, w.value) || (i !== null ? i.push(L) : i = [L])
                }
            } else if (p === De.current) {
                if (w = p.alternate,
                w === null)
                    throw Error(r(387));
                w.memoizedState.memoizedState !== p.memoizedState.memoizedState && (i !== null ? i.push(vc) : i = [vc])
            }
            p = p.return
        }
        i !== null && zh(a, i, l, c),
        a.flags |= 262144
    }
    function Nu(i) {
        for (i = i.firstContext; i !== null; ) {
            if (!Pi(i.context._currentValue, i.memoizedValue))
                return !0;
            i = i.next
        }
        return !1
    }
    function Us(i) {
        Ds = i,
        qr = null,
        i = i.dependencies,
        i !== null && (i.firstContext = null)
    }
    function mi(i) {
        return s0(Ds, i)
    }
    function Ou(i, a) {
        return Ds === null && Us(i),
        s0(i, a)
    }
    function s0(i, a) {
        var l = a._currentValue;
        if (a = {
            context: a,
            memoizedValue: l,
            next: null
        },
        qr === null) {
            if (i === null)
                throw Error(r(308));
            qr = a,
            i.dependencies = {
                lanes: 0,
                firstContext: a
            },
            i.flags |= 524288
        } else
            qr = qr.next = a;
        return l
    }
    var XT = typeof AbortController < "u" ? AbortController : function() {
        var i = []
          , a = this.signal = {
            aborted: !1,
            addEventListener: function(l, c) {
                i.push(c)
            }
        };
        this.abort = function() {
            a.aborted = !0,
            i.forEach(function(l) {
                return l()
            })
        }
    }
      , qT = n.unstable_scheduleCallback
      , YT = n.unstable_NormalPriority
      , Yn = {
        $$typeof: D,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0
    };
    function kh() {
        return {
            controller: new XT,
            data: new Map,
            refCount: 0
        }
    }
    function Gl(i) {
        i.refCount--,
        i.refCount === 0 && qT(YT, function() {
            i.controller.abort()
        })
    }
    var jl = null
      , Fh = 0
      , yo = 0
      , xo = null;
    function ZT(i, a) {
        if (jl === null) {
            var l = jl = [];
            Fh = 0,
            yo = Vp(),
            xo = {
                status: "pending",
                value: void 0,
                then: function(c) {
                    l.push(c)
                }
            }
        }
        return Fh++,
        a.then(o0, o0),
        a
    }
    function o0() {
        if (--Fh === 0 && jl !== null) {
            xo !== null && (xo.status = "fulfilled");
            var i = jl;
            jl = null,
            yo = 0,
            xo = null;
            for (var a = 0; a < i.length; a++)
                (0,
                i[a])()
        }
    }
    function $T(i, a) {
        var l = []
          , c = {
            status: "pending",
            value: null,
            reason: null,
            then: function(p) {
                l.push(p)
            }
        };
        return i.then(function() {
            c.status = "fulfilled",
            c.value = a;
            for (var p = 0; p < l.length; p++)
                (0,
                l[p])(a)
        }, function(p) {
            for (c.status = "rejected",
            c.reason = p,
            p = 0; p < l.length; p++)
                (0,
                l[p])(void 0)
        }),
        c
    }
    var l0 = O.S;
    O.S = function(i, a) {
        typeof a == "object" && a !== null && typeof a.then == "function" && ZT(i, a),
        l0 !== null && l0(i, a)
    }
    ;
    var Ls = ee(null);
    function Bh() {
        var i = Ls.current;
        return i !== null ? i : Rn.pooledCache
    }
    function Pu(i, a) {
        a === null ? pe(Ls, Ls.current) : pe(Ls, a.pool)
    }
    function c0() {
        var i = Bh();
        return i === null ? null : {
            parent: Yn._currentValue,
            pool: i
        }
    }
    var Wl = Error(r(460))
      , u0 = Error(r(474))
      , Iu = Error(r(542))
      , Vh = {
        then: function() {}
    };
    function d0(i) {
        return i = i.status,
        i === "fulfilled" || i === "rejected"
    }
    function zu() {}
    function f0(i, a, l) {
        switch (l = i[l],
        l === void 0 ? i.push(a) : l !== a && (a.then(zu, zu),
        a = l),
        a.status) {
        case "fulfilled":
            return a.value;
        case "rejected":
            throw i = a.reason,
            p0(i),
            i;
        default:
            if (typeof a.status == "string")
                a.then(zu, zu);
            else {
                if (i = Rn,
                i !== null && 100 < i.shellSuspendCounter)
                    throw Error(r(482));
                i = a,
                i.status = "pending",
                i.then(function(c) {
                    if (a.status === "pending") {
                        var p = a;
                        p.status = "fulfilled",
                        p.value = c
                    }
                }, function(c) {
                    if (a.status === "pending") {
                        var p = a;
                        p.status = "rejected",
                        p.reason = c
                    }
                })
            }
            switch (a.status) {
            case "fulfilled":
                return a.value;
            case "rejected":
                throw i = a.reason,
                p0(i),
                i
            }
            throw Xl = a,
            Wl
        }
    }
    var Xl = null;
    function h0() {
        if (Xl === null)
            throw Error(r(459));
        var i = Xl;
        return Xl = null,
        i
    }
    function p0(i) {
        if (i === Wl || i === Iu)
            throw Error(r(483))
    }
    var Na = !1;
    function Hh(i) {
        i.updateQueue = {
            baseState: i.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
                pending: null,
                lanes: 0,
                hiddenCallbacks: null
            },
            callbacks: null
        }
    }
    function Gh(i, a) {
        i = i.updateQueue,
        a.updateQueue === i && (a.updateQueue = {
            baseState: i.baseState,
            firstBaseUpdate: i.firstBaseUpdate,
            lastBaseUpdate: i.lastBaseUpdate,
            shared: i.shared,
            callbacks: null
        })
    }
    function Oa(i) {
        return {
            lane: i,
            tag: 0,
            payload: null,
            callback: null,
            next: null
        }
    }
    function Pa(i, a, l) {
        var c = i.updateQueue;
        if (c === null)
            return null;
        if (c = c.shared,
        (gn & 2) !== 0) {
            var p = c.pending;
            return p === null ? a.next = a : (a.next = p.next,
            p.next = a),
            c.pending = a,
            a = Cu(i),
            e0(i, null, l),
            a
        }
        return Ru(i, c, a, l),
        Cu(i)
    }
    function ql(i, a, l) {
        if (a = a.updateQueue,
        a !== null && (a = a.shared,
        (l & 4194048) !== 0)) {
            var c = a.lanes;
            c &= i.pendingLanes,
            l |= c,
            a.lanes = l,
            at(i, l)
        }
    }
    function jh(i, a) {
        var l = i.updateQueue
          , c = i.alternate;
        if (c !== null && (c = c.updateQueue,
        l === c)) {
            var p = null
              , v = null;
            if (l = l.firstBaseUpdate,
            l !== null) {
                do {
                    var w = {
                        lane: l.lane,
                        tag: l.tag,
                        payload: l.payload,
                        callback: null,
                        next: null
                    };
                    v === null ? p = v = w : v = v.next = w,
                    l = l.next
                } while (l !== null);
                v === null ? p = v = a : v = v.next = a
            } else
                p = v = a;
            l = {
                baseState: c.baseState,
                firstBaseUpdate: p,
                lastBaseUpdate: v,
                shared: c.shared,
                callbacks: c.callbacks
            },
            i.updateQueue = l;
            return
        }
        i = l.lastBaseUpdate,
        i === null ? l.firstBaseUpdate = a : i.next = a,
        l.lastBaseUpdate = a
    }
    var Wh = !1;
    function Yl() {
        if (Wh) {
            var i = xo;
            if (i !== null)
                throw i
        }
    }
    function Zl(i, a, l, c) {
        Wh = !1;
        var p = i.updateQueue;
        Na = !1;
        var v = p.firstBaseUpdate
          , w = p.lastBaseUpdate
          , L = p.shared.pending;
        if (L !== null) {
            p.shared.pending = null;
            var Y = L
              , me = Y.next;
            Y.next = null,
            w === null ? v = me : w.next = me,
            w = Y;
            var Re = i.alternate;
            Re !== null && (Re = Re.updateQueue,
            L = Re.lastBaseUpdate,
            L !== w && (L === null ? Re.firstBaseUpdate = me : L.next = me,
            Re.lastBaseUpdate = Y))
        }
        if (v !== null) {
            var Pe = p.baseState;
            w = 0,
            Re = me = Y = null,
            L = v;
            do {
                var ve = L.lane & -536870913
                  , be = ve !== L.lane;
                if (be ? (ln & ve) === ve : (c & ve) === ve) {
                    ve !== 0 && ve === yo && (Wh = !0),
                    Re !== null && (Re = Re.next = {
                        lane: 0,
                        tag: L.tag,
                        payload: L.payload,
                        callback: null,
                        next: null
                    });
                    e: {
                        var Nt = i
                          , Ct = L;
                        ve = a;
                        var bn = l;
                        switch (Ct.tag) {
                        case 1:
                            if (Nt = Ct.payload,
                            typeof Nt == "function") {
                                Pe = Nt.call(bn, Pe, ve);
                                break e
                            }
                            Pe = Nt;
                            break e;
                        case 3:
                            Nt.flags = Nt.flags & -65537 | 128;
                        case 0:
                            if (Nt = Ct.payload,
                            ve = typeof Nt == "function" ? Nt.call(bn, Pe, ve) : Nt,
                            ve == null)
                                break e;
                            Pe = m({}, Pe, ve);
                            break e;
                        case 2:
                            Na = !0
                        }
                    }
                    ve = L.callback,
                    ve !== null && (i.flags |= 64,
                    be && (i.flags |= 8192),
                    be = p.callbacks,
                    be === null ? p.callbacks = [ve] : be.push(ve))
                } else
                    be = {
                        lane: ve,
                        tag: L.tag,
                        payload: L.payload,
                        callback: L.callback,
                        next: null
                    },
                    Re === null ? (me = Re = be,
                    Y = Pe) : Re = Re.next = be,
                    w |= ve;
                if (L = L.next,
                L === null) {
                    if (L = p.shared.pending,
                    L === null)
                        break;
                    be = L,
                    L = be.next,
                    be.next = null,
                    p.lastBaseUpdate = be,
                    p.shared.pending = null
                }
            } while (!0);
            Re === null && (Y = Pe),
            p.baseState = Y,
            p.firstBaseUpdate = me,
            p.lastBaseUpdate = Re,
            v === null && (p.shared.lanes = 0),
            Ga |= w,
            i.lanes = w,
            i.memoizedState = Pe
        }
    }
    function m0(i, a) {
        if (typeof i != "function")
            throw Error(r(191, i));
        i.call(a)
    }
    function g0(i, a) {
        var l = i.callbacks;
        if (l !== null)
            for (i.callbacks = null,
            i = 0; i < l.length; i++)
                m0(l[i], a)
    }
    var bo = ee(null)
      , ku = ee(0);
    function v0(i, a) {
        i = ta,
        pe(ku, i),
        pe(bo, a),
        ta = i | a.baseLanes
    }
    function Xh() {
        pe(ku, ta),
        pe(bo, bo.current)
    }
    function qh() {
        ta = ku.current,
        ge(bo),
        ge(ku)
    }
    var Ia = 0
      , Wt = null
      , yn = null
      , Hn = null
      , Fu = !1
      , So = !1
      , Ns = !1
      , Bu = 0
      , $l = 0
      , Eo = null
      , KT = 0;
    function kn() {
        throw Error(r(321))
    }
    function Yh(i, a) {
        if (a === null)
            return !1;
        for (var l = 0; l < a.length && l < i.length; l++)
            if (!Pi(i[l], a[l]))
                return !1;
        return !0
    }
    function Zh(i, a, l, c, p, v) {
        return Ia = v,
        Wt = a,
        a.memoizedState = null,
        a.updateQueue = null,
        a.lanes = 0,
        O.H = i === null || i.memoizedState === null ? ey : ty,
        Ns = !1,
        v = l(c, p),
        Ns = !1,
        So && (v = y0(a, l, c, p)),
        _0(i),
        v
    }
    function _0(i) {
        O.H = Xu;
        var a = yn !== null && yn.next !== null;
        if (Ia = 0,
        Hn = yn = Wt = null,
        Fu = !1,
        $l = 0,
        Eo = null,
        a)
            throw Error(r(300));
        i === null || ni || (i = i.dependencies,
        i !== null && Nu(i) && (ni = !0))
    }
    function y0(i, a, l, c) {
        Wt = i;
        var p = 0;
        do {
            if (So && (Eo = null),
            $l = 0,
            So = !1,
            25 <= p)
                throw Error(r(301));
            if (p += 1,
            Hn = yn = null,
            i.updateQueue != null) {
                var v = i.updateQueue;
                v.lastEffect = null,
                v.events = null,
                v.stores = null,
                v.memoCache != null && (v.memoCache.index = 0)
            }
            O.H = rA,
            v = a(l, c)
        } while (So);
        return v
    }
    function QT() {
        var i = O.H
          , a = i.useState()[0];
        return a = typeof a.then == "function" ? Kl(a) : a,
        i = i.useState()[0],
        (yn !== null ? yn.memoizedState : null) !== i && (Wt.flags |= 1024),
        a
    }
    function $h() {
        var i = Bu !== 0;
        return Bu = 0,
        i
    }
    function Kh(i, a, l) {
        a.updateQueue = i.updateQueue,
        a.flags &= -2053,
        i.lanes &= ~l
    }
    function Qh(i) {
        if (Fu) {
            for (i = i.memoizedState; i !== null; ) {
                var a = i.queue;
                a !== null && (a.pending = null),
                i = i.next
            }
            Fu = !1
        }
        Ia = 0,
        Hn = yn = Wt = null,
        So = !1,
        $l = Bu = 0,
        Eo = null
    }
    function Ri() {
        var i = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
        };
        return Hn === null ? Wt.memoizedState = Hn = i : Hn = Hn.next = i,
        Hn
    }
    function Gn() {
        if (yn === null) {
            var i = Wt.alternate;
            i = i !== null ? i.memoizedState : null
        } else
            i = yn.next;
        var a = Hn === null ? Wt.memoizedState : Hn.next;
        if (a !== null)
            Hn = a,
            yn = i;
        else {
            if (i === null)
                throw Wt.alternate === null ? Error(r(467)) : Error(r(310));
            yn = i,
            i = {
                memoizedState: yn.memoizedState,
                baseState: yn.baseState,
                baseQueue: yn.baseQueue,
                queue: yn.queue,
                next: null
            },
            Hn === null ? Wt.memoizedState = Hn = i : Hn = Hn.next = i
        }
        return Hn
    }
    function Jh() {
        return {
            lastEffect: null,
            events: null,
            stores: null,
            memoCache: null
        }
    }
    function Kl(i) {
        var a = $l;
        return $l += 1,
        Eo === null && (Eo = []),
        i = f0(Eo, i, a),
        a = Wt,
        (Hn === null ? a.memoizedState : Hn.next) === null && (a = a.alternate,
        O.H = a === null || a.memoizedState === null ? ey : ty),
        i
    }
    function Vu(i) {
        if (i !== null && typeof i == "object") {
            if (typeof i.then == "function")
                return Kl(i);
            if (i.$$typeof === D)
                return mi(i)
        }
        throw Error(r(438, String(i)))
    }
    function ep(i) {
        var a = null
          , l = Wt.updateQueue;
        if (l !== null && (a = l.memoCache),
        a == null) {
            var c = Wt.alternate;
            c !== null && (c = c.updateQueue,
            c !== null && (c = c.memoCache,
            c != null && (a = {
                data: c.data.map(function(p) {
                    return p.slice()
                }),
                index: 0
            })))
        }
        if (a == null && (a = {
            data: [],
            index: 0
        }),
        l === null && (l = Jh(),
        Wt.updateQueue = l),
        l.memoCache = a,
        l = a.data[a.index],
        l === void 0)
            for (l = a.data[a.index] = Array(i),
            c = 0; c < i; c++)
                l[c] = R;
        return a.index++,
        l
    }
    function Zr(i, a) {
        return typeof a == "function" ? a(i) : a
    }
    function Hu(i) {
        var a = Gn();
        return tp(a, yn, i)
    }
    function tp(i, a, l) {
        var c = i.queue;
        if (c === null)
            throw Error(r(311));
        c.lastRenderedReducer = l;
        var p = i.baseQueue
          , v = c.pending;
        if (v !== null) {
            if (p !== null) {
                var w = p.next;
                p.next = v.next,
                v.next = w
            }
            a.baseQueue = p = v,
            c.pending = null
        }
        if (v = i.baseState,
        p === null)
            i.memoizedState = v;
        else {
            a = p.next;
            var L = w = null
              , Y = null
              , me = a
              , Re = !1;
            do {
                var Pe = me.lane & -536870913;
                if (Pe !== me.lane ? (ln & Pe) === Pe : (Ia & Pe) === Pe) {
                    var ve = me.revertLane;
                    if (ve === 0)
                        Y !== null && (Y = Y.next = {
                            lane: 0,
                            revertLane: 0,
                            action: me.action,
                            hasEagerState: me.hasEagerState,
                            eagerState: me.eagerState,
                            next: null
                        }),
                        Pe === yo && (Re = !0);
                    else if ((Ia & ve) === ve) {
                        me = me.next,
                        ve === yo && (Re = !0);
                        continue
                    } else
                        Pe = {
                            lane: 0,
                            revertLane: me.revertLane,
                            action: me.action,
                            hasEagerState: me.hasEagerState,
                            eagerState: me.eagerState,
                            next: null
                        },
                        Y === null ? (L = Y = Pe,
                        w = v) : Y = Y.next = Pe,
                        Wt.lanes |= ve,
                        Ga |= ve;
                    Pe = me.action,
                    Ns && l(v, Pe),
                    v = me.hasEagerState ? me.eagerState : l(v, Pe)
                } else
                    ve = {
                        lane: Pe,
                        revertLane: me.revertLane,
                        action: me.action,
                        hasEagerState: me.hasEagerState,
                        eagerState: me.eagerState,
                        next: null
                    },
                    Y === null ? (L = Y = ve,
                    w = v) : Y = Y.next = ve,
                    Wt.lanes |= Pe,
                    Ga |= Pe;
                me = me.next
            } while (me !== null && me !== a);
            if (Y === null ? w = v : Y.next = L,
            !Pi(v, i.memoizedState) && (ni = !0,
            Re && (l = xo,
            l !== null)))
                throw l;
            i.memoizedState = v,
            i.baseState = w,
            i.baseQueue = Y,
            c.lastRenderedState = v
        }
        return p === null && (c.lanes = 0),
        [i.memoizedState, c.dispatch]
    }
    function np(i) {
        var a = Gn()
          , l = a.queue;
        if (l === null)
            throw Error(r(311));
        l.lastRenderedReducer = i;
        var c = l.dispatch
          , p = l.pending
          , v = a.memoizedState;
        if (p !== null) {
            l.pending = null;
            var w = p = p.next;
            do
                v = i(v, w.action),
                w = w.next;
            while (w !== p);
            Pi(v, a.memoizedState) || (ni = !0),
            a.memoizedState = v,
            a.baseQueue === null && (a.baseState = v),
            l.lastRenderedState = v
        }
        return [v, c]
    }
    function x0(i, a, l) {
        var c = Wt
          , p = Gn()
          , v = hn;
        if (v) {
            if (l === void 0)
                throw Error(r(407));
            l = l()
        } else
            l = a();
        var w = !Pi((yn || p).memoizedState, l);
        w && (p.memoizedState = l,
        ni = !0),
        p = p.queue;
        var L = E0.bind(null, c, p, i);
        if (Ql(2048, 8, L, [i]),
        p.getSnapshot !== a || w || Hn !== null && Hn.memoizedState.tag & 1) {
            if (c.flags |= 2048,
            Mo(9, Gu(), S0.bind(null, c, p, l, a), null),
            Rn === null)
                throw Error(r(349));
            v || (Ia & 124) !== 0 || b0(c, a, l)
        }
        return l
    }
    function b0(i, a, l) {
        i.flags |= 16384,
        i = {
            getSnapshot: a,
            value: l
        },
        a = Wt.updateQueue,
        a === null ? (a = Jh(),
        Wt.updateQueue = a,
        a.stores = [i]) : (l = a.stores,
        l === null ? a.stores = [i] : l.push(i))
    }
    function S0(i, a, l, c) {
        a.value = l,
        a.getSnapshot = c,
        M0(a) && w0(i)
    }
    function E0(i, a, l) {
        return l(function() {
            M0(a) && w0(i)
        })
    }
    function M0(i) {
        var a = i.getSnapshot;
        i = i.value;
        try {
            var l = a();
            return !Pi(i, l)
        } catch {
            return !0
        }
    }
    function w0(i) {
        var a = mo(i, 2);
        a !== null && Vi(a, i, 2)
    }
    function ip(i) {
        var a = Ri();
        if (typeof i == "function") {
            var l = i;
            if (i = l(),
            Ns) {
                _e(!0);
                try {
                    l()
                } finally {
                    _e(!1)
                }
            }
        }
        return a.memoizedState = a.baseState = i,
        a.queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: Zr,
            lastRenderedState: i
        },
        a
    }
    function T0(i, a, l, c) {
        return i.baseState = l,
        tp(i, yn, typeof c == "function" ? c : Zr)
    }
    function JT(i, a, l, c, p) {
        if (Wu(i))
            throw Error(r(485));
        if (i = a.action,
        i !== null) {
            var v = {
                payload: p,
                action: i,
                next: null,
                isTransition: !0,
                status: "pending",
                value: null,
                reason: null,
                listeners: [],
                then: function(w) {
                    v.listeners.push(w)
                }
            };
            O.T !== null ? l(!0) : v.isTransition = !1,
            c(v),
            l = a.pending,
            l === null ? (v.next = a.pending = v,
            A0(a, v)) : (v.next = l.next,
            a.pending = l.next = v)
        }
    }
    function A0(i, a) {
        var l = a.action
          , c = a.payload
          , p = i.state;
        if (a.isTransition) {
            var v = O.T
              , w = {};
            O.T = w;
            try {
                var L = l(p, c)
                  , Y = O.S;
                Y !== null && Y(w, L),
                R0(i, a, L)
            } catch (me) {
                rp(i, a, me)
            } finally {
                O.T = v
            }
        } else
            try {
                v = l(p, c),
                R0(i, a, v)
            } catch (me) {
                rp(i, a, me)
            }
    }
    function R0(i, a, l) {
        l !== null && typeof l == "object" && typeof l.then == "function" ? l.then(function(c) {
            C0(i, a, c)
        }, function(c) {
            return rp(i, a, c)
        }) : C0(i, a, l)
    }
    function C0(i, a, l) {
        a.status = "fulfilled",
        a.value = l,
        D0(a),
        i.state = l,
        a = i.pending,
        a !== null && (l = a.next,
        l === a ? i.pending = null : (l = l.next,
        a.next = l,
        A0(i, l)))
    }
    function rp(i, a, l) {
        var c = i.pending;
        if (i.pending = null,
        c !== null) {
            c = c.next;
            do
                a.status = "rejected",
                a.reason = l,
                D0(a),
                a = a.next;
            while (a !== c)
        }
        i.action = null
    }
    function D0(i) {
        i = i.listeners;
        for (var a = 0; a < i.length; a++)
            (0,
            i[a])()
    }
    function U0(i, a) {
        return a
    }
    function L0(i, a) {
        if (hn) {
            var l = Rn.formState;
            if (l !== null) {
                e: {
                    var c = Wt;
                    if (hn) {
                        if (On) {
                            t: {
                                for (var p = On, v = Er; p.nodeType !== 8; ) {
                                    if (!v) {
                                        p = null;
                                        break t
                                    }
                                    if (p = dr(p.nextSibling),
                                    p === null) {
                                        p = null;
                                        break t
                                    }
                                }
                                v = p.data,
                                p = v === "F!" || v === "F" ? p : null
                            }
                            if (p) {
                                On = dr(p.nextSibling),
                                c = p.data === "F!";
                                break e
                            }
                        }
                        Cs(c)
                    }
                    c = !1
                }
                c && (a = l[0])
            }
        }
        return l = Ri(),
        l.memoizedState = l.baseState = a,
        c = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: U0,
            lastRenderedState: a
        },
        l.queue = c,
        l = K0.bind(null, Wt, c),
        c.dispatch = l,
        c = ip(!1),
        v = cp.bind(null, Wt, !1, c.queue),
        c = Ri(),
        p = {
            state: a,
            dispatch: null,
            action: i,
            pending: null
        },
        c.queue = p,
        l = JT.bind(null, Wt, p, v, l),
        p.dispatch = l,
        c.memoizedState = i,
        [a, l, !1]
    }
    function N0(i) {
        var a = Gn();
        return O0(a, yn, i)
    }
    function O0(i, a, l) {
        if (a = tp(i, a, U0)[0],
        i = Hu(Zr)[0],
        typeof a == "object" && a !== null && typeof a.then == "function")
            try {
                var c = Kl(a)
            } catch (w) {
                throw w === Wl ? Iu : w
            }
        else
            c = a;
        a = Gn();
        var p = a.queue
          , v = p.dispatch;
        return l !== a.memoizedState && (Wt.flags |= 2048,
        Mo(9, Gu(), eA.bind(null, p, l), null)),
        [c, v, i]
    }
    function eA(i, a) {
        i.action = a
    }
    function P0(i) {
        var a = Gn()
          , l = yn;
        if (l !== null)
            return O0(a, l, i);
        Gn(),
        a = a.memoizedState,
        l = Gn();
        var c = l.queue.dispatch;
        return l.memoizedState = i,
        [a, c, !1]
    }
    function Mo(i, a, l, c) {
        return i = {
            tag: i,
            create: l,
            deps: c,
            inst: a,
            next: null
        },
        a = Wt.updateQueue,
        a === null && (a = Jh(),
        Wt.updateQueue = a),
        l = a.lastEffect,
        l === null ? a.lastEffect = i.next = i : (c = l.next,
        l.next = i,
        i.next = c,
        a.lastEffect = i),
        i
    }
    function Gu() {
        return {
            destroy: void 0,
            resource: void 0
        }
    }
    function I0() {
        return Gn().memoizedState
    }
    function ju(i, a, l, c) {
        var p = Ri();
        c = c === void 0 ? null : c,
        Wt.flags |= i,
        p.memoizedState = Mo(1 | a, Gu(), l, c)
    }
    function Ql(i, a, l, c) {
        var p = Gn();
        c = c === void 0 ? null : c;
        var v = p.memoizedState.inst;
        yn !== null && c !== null && Yh(c, yn.memoizedState.deps) ? p.memoizedState = Mo(a, v, l, c) : (Wt.flags |= i,
        p.memoizedState = Mo(1 | a, v, l, c))
    }
    function z0(i, a) {
        ju(8390656, 8, i, a)
    }
    function k0(i, a) {
        Ql(2048, 8, i, a)
    }
    function F0(i, a) {
        return Ql(4, 2, i, a)
    }
    function B0(i, a) {
        return Ql(4, 4, i, a)
    }
    function V0(i, a) {
        if (typeof a == "function") {
            i = i();
            var l = a(i);
            return function() {
                typeof l == "function" ? l() : a(null)
            }
        }
        if (a != null)
            return i = i(),
            a.current = i,
            function() {
                a.current = null
            }
    }
    function H0(i, a, l) {
        l = l != null ? l.concat([i]) : null,
        Ql(4, 4, V0.bind(null, a, i), l)
    }
    function ap() {}
    function G0(i, a) {
        var l = Gn();
        a = a === void 0 ? null : a;
        var c = l.memoizedState;
        return a !== null && Yh(a, c[1]) ? c[0] : (l.memoizedState = [i, a],
        i)
    }
    function j0(i, a) {
        var l = Gn();
        a = a === void 0 ? null : a;
        var c = l.memoizedState;
        if (a !== null && Yh(a, c[1]))
            return c[0];
        if (c = i(),
        Ns) {
            _e(!0);
            try {
                i()
            } finally {
                _e(!1)
            }
        }
        return l.memoizedState = [c, a],
        c
    }
    function sp(i, a, l) {
        return l === void 0 || (Ia & 1073741824) !== 0 ? i.memoizedState = a : (i.memoizedState = l,
        i = qy(),
        Wt.lanes |= i,
        Ga |= i,
        l)
    }
    function W0(i, a, l, c) {
        return Pi(l, a) ? l : bo.current !== null ? (i = sp(i, l, c),
        Pi(i, a) || (ni = !0),
        i) : (Ia & 42) === 0 ? (ni = !0,
        i.memoizedState = l) : (i = qy(),
        Wt.lanes |= i,
        Ga |= i,
        a)
    }
    function X0(i, a, l, c, p) {
        var v = W.p;
        W.p = v !== 0 && 8 > v ? v : 8;
        var w = O.T
          , L = {};
        O.T = L,
        cp(i, !1, a, l);
        try {
            var Y = p()
              , me = O.S;
            if (me !== null && me(L, Y),
            Y !== null && typeof Y == "object" && typeof Y.then == "function") {
                var Re = $T(Y, c);
                Jl(i, a, Re, Bi(i))
            } else
                Jl(i, a, c, Bi(i))
        } catch (Pe) {
            Jl(i, a, {
                then: function() {},
                status: "rejected",
                reason: Pe
            }, Bi())
        } finally {
            W.p = v,
            O.T = w
        }
    }
    function tA() {}
    function op(i, a, l, c) {
        if (i.tag !== 5)
            throw Error(r(476));
        var p = q0(i).queue;
        X0(i, p, a, H, l === null ? tA : function() {
            return Y0(i),
            l(c)
        }
        )
    }
    function q0(i) {
        var a = i.memoizedState;
        if (a !== null)
            return a;
        a = {
            memoizedState: H,
            baseState: H,
            baseQueue: null,
            queue: {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: Zr,
                lastRenderedState: H
            },
            next: null
        };
        var l = {};
        return a.next = {
            memoizedState: l,
            baseState: l,
            baseQueue: null,
            queue: {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: Zr,
                lastRenderedState: l
            },
            next: null
        },
        i.memoizedState = a,
        i = i.alternate,
        i !== null && (i.memoizedState = a),
        a
    }
    function Y0(i) {
        var a = q0(i).next.queue;
        Jl(i, a, {}, Bi())
    }
    function lp() {
        return mi(vc)
    }
    function Z0() {
        return Gn().memoizedState
    }
    function $0() {
        return Gn().memoizedState
    }
    function nA(i) {
        for (var a = i.return; a !== null; ) {
            switch (a.tag) {
            case 24:
            case 3:
                var l = Bi();
                i = Oa(l);
                var c = Pa(a, i, l);
                c !== null && (Vi(c, a, l),
                ql(c, a, l)),
                a = {
                    cache: kh()
                },
                i.payload = a;
                return
            }
            a = a.return
        }
    }
    function iA(i, a, l) {
        var c = Bi();
        l = {
            lane: c,
            revertLane: 0,
            action: l,
            hasEagerState: !1,
            eagerState: null,
            next: null
        },
        Wu(i) ? Q0(a, l) : (l = Rh(i, a, l, c),
        l !== null && (Vi(l, i, c),
        J0(l, a, c)))
    }
    function K0(i, a, l) {
        var c = Bi();
        Jl(i, a, l, c)
    }
    function Jl(i, a, l, c) {
        var p = {
            lane: c,
            revertLane: 0,
            action: l,
            hasEagerState: !1,
            eagerState: null,
            next: null
        };
        if (Wu(i))
            Q0(a, p);
        else {
            var v = i.alternate;
            if (i.lanes === 0 && (v === null || v.lanes === 0) && (v = a.lastRenderedReducer,
            v !== null))
                try {
                    var w = a.lastRenderedState
                      , L = v(w, l);
                    if (p.hasEagerState = !0,
                    p.eagerState = L,
                    Pi(L, w))
                        return Ru(i, a, p, 0),
                        Rn === null && Au(),
                        !1
                } catch {} finally {}
            if (l = Rh(i, a, p, c),
            l !== null)
                return Vi(l, i, c),
                J0(l, a, c),
                !0
        }
        return !1
    }
    function cp(i, a, l, c) {
        if (c = {
            lane: 2,
            revertLane: Vp(),
            action: c,
            hasEagerState: !1,
            eagerState: null,
            next: null
        },
        Wu(i)) {
            if (a)
                throw Error(r(479))
        } else
            a = Rh(i, l, c, 2),
            a !== null && Vi(a, i, 2)
    }
    function Wu(i) {
        var a = i.alternate;
        return i === Wt || a !== null && a === Wt
    }
    function Q0(i, a) {
        So = Fu = !0;
        var l = i.pending;
        l === null ? a.next = a : (a.next = l.next,
        l.next = a),
        i.pending = a
    }
    function J0(i, a, l) {
        if ((l & 4194048) !== 0) {
            var c = a.lanes;
            c &= i.pendingLanes,
            l |= c,
            a.lanes = l,
            at(i, l)
        }
    }
    var Xu = {
        readContext: mi,
        use: Vu,
        useCallback: kn,
        useContext: kn,
        useEffect: kn,
        useImperativeHandle: kn,
        useLayoutEffect: kn,
        useInsertionEffect: kn,
        useMemo: kn,
        useReducer: kn,
        useRef: kn,
        useState: kn,
        useDebugValue: kn,
        useDeferredValue: kn,
        useTransition: kn,
        useSyncExternalStore: kn,
        useId: kn,
        useHostTransitionStatus: kn,
        useFormState: kn,
        useActionState: kn,
        useOptimistic: kn,
        useMemoCache: kn,
        useCacheRefresh: kn
    }
      , ey = {
        readContext: mi,
        use: Vu,
        useCallback: function(i, a) {
            return Ri().memoizedState = [i, a === void 0 ? null : a],
            i
        },
        useContext: mi,
        useEffect: z0,
        useImperativeHandle: function(i, a, l) {
            l = l != null ? l.concat([i]) : null,
            ju(4194308, 4, V0.bind(null, a, i), l)
        },
        useLayoutEffect: function(i, a) {
            return ju(4194308, 4, i, a)
        },
        useInsertionEffect: function(i, a) {
            ju(4, 2, i, a)
        },
        useMemo: function(i, a) {
            var l = Ri();
            a = a === void 0 ? null : a;
            var c = i();
            if (Ns) {
                _e(!0);
                try {
                    i()
                } finally {
                    _e(!1)
                }
            }
            return l.memoizedState = [c, a],
            c
        },
        useReducer: function(i, a, l) {
            var c = Ri();
            if (l !== void 0) {
                var p = l(a);
                if (Ns) {
                    _e(!0);
                    try {
                        l(a)
                    } finally {
                        _e(!1)
                    }
                }
            } else
                p = a;
            return c.memoizedState = c.baseState = p,
            i = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: i,
                lastRenderedState: p
            },
            c.queue = i,
            i = i.dispatch = iA.bind(null, Wt, i),
            [c.memoizedState, i]
        },
        useRef: function(i) {
            var a = Ri();
            return i = {
                current: i
            },
            a.memoizedState = i
        },
        useState: function(i) {
            i = ip(i);
            var a = i.queue
              , l = K0.bind(null, Wt, a);
            return a.dispatch = l,
            [i.memoizedState, l]
        },
        useDebugValue: ap,
        useDeferredValue: function(i, a) {
            var l = Ri();
            return sp(l, i, a)
        },
        useTransition: function() {
            var i = ip(!1);
            return i = X0.bind(null, Wt, i.queue, !0, !1),
            Ri().memoizedState = i,
            [!1, i]
        },
        useSyncExternalStore: function(i, a, l) {
            var c = Wt
              , p = Ri();
            if (hn) {
                if (l === void 0)
                    throw Error(r(407));
                l = l()
            } else {
                if (l = a(),
                Rn === null)
                    throw Error(r(349));
                (ln & 124) !== 0 || b0(c, a, l)
            }
            p.memoizedState = l;
            var v = {
                value: l,
                getSnapshot: a
            };
            return p.queue = v,
            z0(E0.bind(null, c, v, i), [i]),
            c.flags |= 2048,
            Mo(9, Gu(), S0.bind(null, c, v, l, a), null),
            l
        },
        useId: function() {
            var i = Ri()
              , a = Rn.identifierPrefix;
            if (hn) {
                var l = Xr
                  , c = Wr;
                l = (c & ~(1 << 32 - Ae(c) - 1)).toString(32) + l,
                a = "" + a + "R" + l,
                l = Bu++,
                0 < l && (a += "H" + l.toString(32)),
                a += ""
            } else
                l = KT++,
                a = "" + a + "r" + l.toString(32) + "";
            return i.memoizedState = a
        },
        useHostTransitionStatus: lp,
        useFormState: L0,
        useActionState: L0,
        useOptimistic: function(i) {
            var a = Ri();
            a.memoizedState = a.baseState = i;
            var l = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: null,
                lastRenderedState: null
            };
            return a.queue = l,
            a = cp.bind(null, Wt, !0, l),
            l.dispatch = a,
            [i, a]
        },
        useMemoCache: ep,
        useCacheRefresh: function() {
            return Ri().memoizedState = nA.bind(null, Wt)
        }
    }
      , ty = {
        readContext: mi,
        use: Vu,
        useCallback: G0,
        useContext: mi,
        useEffect: k0,
        useImperativeHandle: H0,
        useInsertionEffect: F0,
        useLayoutEffect: B0,
        useMemo: j0,
        useReducer: Hu,
        useRef: I0,
        useState: function() {
            return Hu(Zr)
        },
        useDebugValue: ap,
        useDeferredValue: function(i, a) {
            var l = Gn();
            return W0(l, yn.memoizedState, i, a)
        },
        useTransition: function() {
            var i = Hu(Zr)[0]
              , a = Gn().memoizedState;
            return [typeof i == "boolean" ? i : Kl(i), a]
        },
        useSyncExternalStore: x0,
        useId: Z0,
        useHostTransitionStatus: lp,
        useFormState: N0,
        useActionState: N0,
        useOptimistic: function(i, a) {
            var l = Gn();
            return T0(l, yn, i, a)
        },
        useMemoCache: ep,
        useCacheRefresh: $0
    }
      , rA = {
        readContext: mi,
        use: Vu,
        useCallback: G0,
        useContext: mi,
        useEffect: k0,
        useImperativeHandle: H0,
        useInsertionEffect: F0,
        useLayoutEffect: B0,
        useMemo: j0,
        useReducer: np,
        useRef: I0,
        useState: function() {
            return np(Zr)
        },
        useDebugValue: ap,
        useDeferredValue: function(i, a) {
            var l = Gn();
            return yn === null ? sp(l, i, a) : W0(l, yn.memoizedState, i, a)
        },
        useTransition: function() {
            var i = np(Zr)[0]
              , a = Gn().memoizedState;
            return [typeof i == "boolean" ? i : Kl(i), a]
        },
        useSyncExternalStore: x0,
        useId: Z0,
        useHostTransitionStatus: lp,
        useFormState: P0,
        useActionState: P0,
        useOptimistic: function(i, a) {
            var l = Gn();
            return yn !== null ? T0(l, yn, i, a) : (l.baseState = i,
            [i, l.queue.dispatch])
        },
        useMemoCache: ep,
        useCacheRefresh: $0
    }
      , wo = null
      , ec = 0;
    function qu(i) {
        var a = ec;
        return ec += 1,
        wo === null && (wo = []),
        f0(wo, i, a)
    }
    function tc(i, a) {
        a = a.props.ref,
        i.ref = a !== void 0 ? a : null
    }
    function Yu(i, a) {
        throw a.$$typeof === g ? Error(r(525)) : (i = Object.prototype.toString.call(a),
        Error(r(31, i === "[object Object]" ? "object with keys {" + Object.keys(a).join(", ") + "}" : i)))
    }
    function ny(i) {
        var a = i._init;
        return a(i._payload)
    }
    function iy(i) {
        function a(ce, ne) {
            if (i) {
                var he = ce.deletions;
                he === null ? (ce.deletions = [ne],
                ce.flags |= 16) : he.push(ne)
            }
        }
        function l(ce, ne) {
            if (!i)
                return null;
            for (; ne !== null; )
                a(ce, ne),
                ne = ne.sibling;
            return null
        }
        function c(ce) {
            for (var ne = new Map; ce !== null; )
                ce.key !== null ? ne.set(ce.key, ce) : ne.set(ce.index, ce),
                ce = ce.sibling;
            return ne
        }
        function p(ce, ne) {
            return ce = jr(ce, ne),
            ce.index = 0,
            ce.sibling = null,
            ce
        }
        function v(ce, ne, he) {
            return ce.index = he,
            i ? (he = ce.alternate,
            he !== null ? (he = he.index,
            he < ne ? (ce.flags |= 67108866,
            ne) : he) : (ce.flags |= 67108866,
            ne)) : (ce.flags |= 1048576,
            ne)
        }
        function w(ce) {
            return i && ce.alternate === null && (ce.flags |= 67108866),
            ce
        }
        function L(ce, ne, he, Oe) {
            return ne === null || ne.tag !== 6 ? (ne = Dh(he, ce.mode, Oe),
            ne.return = ce,
            ne) : (ne = p(ne, he),
            ne.return = ce,
            ne)
        }
        function Y(ce, ne, he, Oe) {
            var ct = he.type;
            return ct === E ? Re(ce, ne, he.props.children, Oe, he.key) : ne !== null && (ne.elementType === ct || typeof ct == "object" && ct !== null && ct.$$typeof === z && ny(ct) === ne.type) ? (ne = p(ne, he.props),
            tc(ne, he),
            ne.return = ce,
            ne) : (ne = Du(he.type, he.key, he.props, null, ce.mode, Oe),
            tc(ne, he),
            ne.return = ce,
            ne)
        }
        function me(ce, ne, he, Oe) {
            return ne === null || ne.tag !== 4 || ne.stateNode.containerInfo !== he.containerInfo || ne.stateNode.implementation !== he.implementation ? (ne = Uh(he, ce.mode, Oe),
            ne.return = ce,
            ne) : (ne = p(ne, he.children || []),
            ne.return = ce,
            ne)
        }
        function Re(ce, ne, he, Oe, ct) {
            return ne === null || ne.tag !== 7 ? (ne = ws(he, ce.mode, Oe, ct),
            ne.return = ce,
            ne) : (ne = p(ne, he),
            ne.return = ce,
            ne)
        }
        function Pe(ce, ne, he) {
            if (typeof ne == "string" && ne !== "" || typeof ne == "number" || typeof ne == "bigint")
                return ne = Dh("" + ne, ce.mode, he),
                ne.return = ce,
                ne;
            if (typeof ne == "object" && ne !== null) {
                switch (ne.$$typeof) {
                case _:
                    return he = Du(ne.type, ne.key, ne.props, null, ce.mode, he),
                    tc(he, ne),
                    he.return = ce,
                    he;
                case x:
                    return ne = Uh(ne, ce.mode, he),
                    ne.return = ce,
                    ne;
                case z:
                    var Oe = ne._init;
                    return ne = Oe(ne._payload),
                    Pe(ce, ne, he)
                }
                if (le(ne) || Q(ne))
                    return ne = ws(ne, ce.mode, he, null),
                    ne.return = ce,
                    ne;
                if (typeof ne.then == "function")
                    return Pe(ce, qu(ne), he);
                if (ne.$$typeof === D)
                    return Pe(ce, Ou(ce, ne), he);
                Yu(ce, ne)
            }
            return null
        }
        function ve(ce, ne, he, Oe) {
            var ct = ne !== null ? ne.key : null;
            if (typeof he == "string" && he !== "" || typeof he == "number" || typeof he == "bigint")
                return ct !== null ? null : L(ce, ne, "" + he, Oe);
            if (typeof he == "object" && he !== null) {
                switch (he.$$typeof) {
                case _:
                    return he.key === ct ? Y(ce, ne, he, Oe) : null;
                case x:
                    return he.key === ct ? me(ce, ne, he, Oe) : null;
                case z:
                    return ct = he._init,
                    he = ct(he._payload),
                    ve(ce, ne, he, Oe)
                }
                if (le(he) || Q(he))
                    return ct !== null ? null : Re(ce, ne, he, Oe, null);
                if (typeof he.then == "function")
                    return ve(ce, ne, qu(he), Oe);
                if (he.$$typeof === D)
                    return ve(ce, ne, Ou(ce, he), Oe);
                Yu(ce, he)
            }
            return null
        }
        function be(ce, ne, he, Oe, ct) {
            if (typeof Oe == "string" && Oe !== "" || typeof Oe == "number" || typeof Oe == "bigint")
                return ce = ce.get(he) || null,
                L(ne, ce, "" + Oe, ct);
            if (typeof Oe == "object" && Oe !== null) {
                switch (Oe.$$typeof) {
                case _:
                    return ce = ce.get(Oe.key === null ? he : Oe.key) || null,
                    Y(ne, ce, Oe, ct);
                case x:
                    return ce = ce.get(Oe.key === null ? he : Oe.key) || null,
                    me(ne, ce, Oe, ct);
                case z:
                    var Yt = Oe._init;
                    return Oe = Yt(Oe._payload),
                    be(ce, ne, he, Oe, ct)
                }
                if (le(Oe) || Q(Oe))
                    return ce = ce.get(he) || null,
                    Re(ne, ce, Oe, ct, null);
                if (typeof Oe.then == "function")
                    return be(ce, ne, he, qu(Oe), ct);
                if (Oe.$$typeof === D)
                    return be(ce, ne, he, Ou(ne, Oe), ct);
                Yu(ne, Oe)
            }
            return null
        }
        function Nt(ce, ne, he, Oe) {
            for (var ct = null, Yt = null, wt = ne, Ut = ne = 0, ri = null; wt !== null && Ut < he.length; Ut++) {
                wt.index > Ut ? (ri = wt,
                wt = null) : ri = wt.sibling;
                var dn = ve(ce, wt, he[Ut], Oe);
                if (dn === null) {
                    wt === null && (wt = ri);
                    break
                }
                i && wt && dn.alternate === null && a(ce, wt),
                ne = v(dn, ne, Ut),
                Yt === null ? ct = dn : Yt.sibling = dn,
                Yt = dn,
                wt = ri
            }
            if (Ut === he.length)
                return l(ce, wt),
                hn && As(ce, Ut),
                ct;
            if (wt === null) {
                for (; Ut < he.length; Ut++)
                    wt = Pe(ce, he[Ut], Oe),
                    wt !== null && (ne = v(wt, ne, Ut),
                    Yt === null ? ct = wt : Yt.sibling = wt,
                    Yt = wt);
                return hn && As(ce, Ut),
                ct
            }
            for (wt = c(wt); Ut < he.length; Ut++)
                ri = be(wt, ce, Ut, he[Ut], Oe),
                ri !== null && (i && ri.alternate !== null && wt.delete(ri.key === null ? Ut : ri.key),
                ne = v(ri, ne, Ut),
                Yt === null ? ct = ri : Yt.sibling = ri,
                Yt = ri);
            return i && wt.forEach(function(Qa) {
                return a(ce, Qa)
            }),
            hn && As(ce, Ut),
            ct
        }
        function Ct(ce, ne, he, Oe) {
            if (he == null)
                throw Error(r(151));
            for (var ct = null, Yt = null, wt = ne, Ut = ne = 0, ri = null, dn = he.next(); wt !== null && !dn.done; Ut++,
            dn = he.next()) {
                wt.index > Ut ? (ri = wt,
                wt = null) : ri = wt.sibling;
                var Qa = ve(ce, wt, dn.value, Oe);
                if (Qa === null) {
                    wt === null && (wt = ri);
                    break
                }
                i && wt && Qa.alternate === null && a(ce, wt),
                ne = v(Qa, ne, Ut),
                Yt === null ? ct = Qa : Yt.sibling = Qa,
                Yt = Qa,
                wt = ri
            }
            if (dn.done)
                return l(ce, wt),
                hn && As(ce, Ut),
                ct;
            if (wt === null) {
                for (; !dn.done; Ut++,
                dn = he.next())
                    dn = Pe(ce, dn.value, Oe),
                    dn !== null && (ne = v(dn, ne, Ut),
                    Yt === null ? ct = dn : Yt.sibling = dn,
                    Yt = dn);
                return hn && As(ce, Ut),
                ct
            }
            for (wt = c(wt); !dn.done; Ut++,
            dn = he.next())
                dn = be(wt, ce, Ut, dn.value, Oe),
                dn !== null && (i && dn.alternate !== null && wt.delete(dn.key === null ? Ut : dn.key),
                ne = v(dn, ne, Ut),
                Yt === null ? ct = dn : Yt.sibling = dn,
                Yt = dn);
            return i && wt.forEach(function(a1) {
                return a(ce, a1)
            }),
            hn && As(ce, Ut),
            ct
        }
        function bn(ce, ne, he, Oe) {
            if (typeof he == "object" && he !== null && he.type === E && he.key === null && (he = he.props.children),
            typeof he == "object" && he !== null) {
                switch (he.$$typeof) {
                case _:
                    e: {
                        for (var ct = he.key; ne !== null; ) {
                            if (ne.key === ct) {
                                if (ct = he.type,
                                ct === E) {
                                    if (ne.tag === 7) {
                                        l(ce, ne.sibling),
                                        Oe = p(ne, he.props.children),
                                        Oe.return = ce,
                                        ce = Oe;
                                        break e
                                    }
                                } else if (ne.elementType === ct || typeof ct == "object" && ct !== null && ct.$$typeof === z && ny(ct) === ne.type) {
                                    l(ce, ne.sibling),
                                    Oe = p(ne, he.props),
                                    tc(Oe, he),
                                    Oe.return = ce,
                                    ce = Oe;
                                    break e
                                }
                                l(ce, ne);
                                break
                            } else
                                a(ce, ne);
                            ne = ne.sibling
                        }
                        he.type === E ? (Oe = ws(he.props.children, ce.mode, Oe, he.key),
                        Oe.return = ce,
                        ce = Oe) : (Oe = Du(he.type, he.key, he.props, null, ce.mode, Oe),
                        tc(Oe, he),
                        Oe.return = ce,
                        ce = Oe)
                    }
                    return w(ce);
                case x:
                    e: {
                        for (ct = he.key; ne !== null; ) {
                            if (ne.key === ct)
                                if (ne.tag === 4 && ne.stateNode.containerInfo === he.containerInfo && ne.stateNode.implementation === he.implementation) {
                                    l(ce, ne.sibling),
                                    Oe = p(ne, he.children || []),
                                    Oe.return = ce,
                                    ce = Oe;
                                    break e
                                } else {
                                    l(ce, ne);
                                    break
                                }
                            else
                                a(ce, ne);
                            ne = ne.sibling
                        }
                        Oe = Uh(he, ce.mode, Oe),
                        Oe.return = ce,
                        ce = Oe
                    }
                    return w(ce);
                case z:
                    return ct = he._init,
                    he = ct(he._payload),
                    bn(ce, ne, he, Oe)
                }
                if (le(he))
                    return Nt(ce, ne, he, Oe);
                if (Q(he)) {
                    if (ct = Q(he),
                    typeof ct != "function")
                        throw Error(r(150));
                    return he = ct.call(he),
                    Ct(ce, ne, he, Oe)
                }
                if (typeof he.then == "function")
                    return bn(ce, ne, qu(he), Oe);
                if (he.$$typeof === D)
                    return bn(ce, ne, Ou(ce, he), Oe);
                Yu(ce, he)
            }
            return typeof he == "string" && he !== "" || typeof he == "number" || typeof he == "bigint" ? (he = "" + he,
            ne !== null && ne.tag === 6 ? (l(ce, ne.sibling),
            Oe = p(ne, he),
            Oe.return = ce,
            ce = Oe) : (l(ce, ne),
            Oe = Dh(he, ce.mode, Oe),
            Oe.return = ce,
            ce = Oe),
            w(ce)) : l(ce, ne)
        }
        return function(ce, ne, he, Oe) {
            try {
                ec = 0;
                var ct = bn(ce, ne, he, Oe);
                return wo = null,
                ct
            } catch (wt) {
                if (wt === Wl || wt === Iu)
                    throw wt;
                var Yt = Ii(29, wt, null, ce.mode);
                return Yt.lanes = Oe,
                Yt.return = ce,
                Yt
            } finally {}
        }
    }
    var To = iy(!0)
      , ry = iy(!1)
      , Qi = ee(null)
      , Mr = null;
    function za(i) {
        var a = i.alternate;
        pe(Zn, Zn.current & 1),
        pe(Qi, i),
        Mr === null && (a === null || bo.current !== null || a.memoizedState !== null) && (Mr = i)
    }
    function ay(i) {
        if (i.tag === 22) {
            if (pe(Zn, Zn.current),
            pe(Qi, i),
            Mr === null) {
                var a = i.alternate;
                a !== null && a.memoizedState !== null && (Mr = i)
            }
        } else
            ka()
    }
    function ka() {
        pe(Zn, Zn.current),
        pe(Qi, Qi.current)
    }
    function $r(i) {
        ge(Qi),
        Mr === i && (Mr = null),
        ge(Zn)
    }
    var Zn = ee(0);
    function Zu(i) {
        for (var a = i; a !== null; ) {
            if (a.tag === 13) {
                var l = a.memoizedState;
                if (l !== null && (l = l.dehydrated,
                l === null || l.data === "$?" || Jp(l)))
                    return a
            } else if (a.tag === 19 && a.memoizedProps.revealOrder !== void 0) {
                if ((a.flags & 128) !== 0)
                    return a
            } else if (a.child !== null) {
                a.child.return = a,
                a = a.child;
                continue
            }
            if (a === i)
                break;
            for (; a.sibling === null; ) {
                if (a.return === null || a.return === i)
                    return null;
                a = a.return
            }
            a.sibling.return = a.return,
            a = a.sibling
        }
        return null
    }
    function up(i, a, l, c) {
        a = i.memoizedState,
        l = l(c, a),
        l = l == null ? a : m({}, a, l),
        i.memoizedState = l,
        i.lanes === 0 && (i.updateQueue.baseState = l)
    }
    var dp = {
        enqueueSetState: function(i, a, l) {
            i = i._reactInternals;
            var c = Bi()
              , p = Oa(c);
            p.payload = a,
            l != null && (p.callback = l),
            a = Pa(i, p, c),
            a !== null && (Vi(a, i, c),
            ql(a, i, c))
        },
        enqueueReplaceState: function(i, a, l) {
            i = i._reactInternals;
            var c = Bi()
              , p = Oa(c);
            p.tag = 1,
            p.payload = a,
            l != null && (p.callback = l),
            a = Pa(i, p, c),
            a !== null && (Vi(a, i, c),
            ql(a, i, c))
        },
        enqueueForceUpdate: function(i, a) {
            i = i._reactInternals;
            var l = Bi()
              , c = Oa(l);
            c.tag = 2,
            a != null && (c.callback = a),
            a = Pa(i, c, l),
            a !== null && (Vi(a, i, l),
            ql(a, i, l))
        }
    };
    function sy(i, a, l, c, p, v, w) {
        return i = i.stateNode,
        typeof i.shouldComponentUpdate == "function" ? i.shouldComponentUpdate(c, v, w) : a.prototype && a.prototype.isPureReactComponent ? !zl(l, c) || !zl(p, v) : !0
    }
    function oy(i, a, l, c) {
        i = a.state,
        typeof a.componentWillReceiveProps == "function" && a.componentWillReceiveProps(l, c),
        typeof a.UNSAFE_componentWillReceiveProps == "function" && a.UNSAFE_componentWillReceiveProps(l, c),
        a.state !== i && dp.enqueueReplaceState(a, a.state, null)
    }
    function Os(i, a) {
        var l = a;
        if ("ref"in a) {
            l = {};
            for (var c in a)
                c !== "ref" && (l[c] = a[c])
        }
        if (i = i.defaultProps) {
            l === a && (l = m({}, l));
            for (var p in i)
                l[p] === void 0 && (l[p] = i[p])
        }
        return l
    }
    var $u = typeof reportError == "function" ? reportError : function(i) {
        if (typeof window == "object" && typeof window.ErrorEvent == "function") {
            var a = new window.ErrorEvent("error",{
                bubbles: !0,
                cancelable: !0,
                message: typeof i == "object" && i !== null && typeof i.message == "string" ? String(i.message) : String(i),
                error: i
            });
            if (!window.dispatchEvent(a))
                return
        } else if (typeof process == "object" && typeof process.emit == "function") {
            process.emit("uncaughtException", i);
            return
        }
        console.error(i)
    }
    ;
    function ly(i) {
        $u(i)
    }
    function cy(i) {
        console.error(i)
    }
    function uy(i) {
        $u(i)
    }
    function Ku(i, a) {
        try {
            var l = i.onUncaughtError;
            l(a.value, {
                componentStack: a.stack
            })
        } catch (c) {
            setTimeout(function() {
                throw c
            })
        }
    }
    function dy(i, a, l) {
        try {
            var c = i.onCaughtError;
            c(l.value, {
                componentStack: l.stack,
                errorBoundary: a.tag === 1 ? a.stateNode : null
            })
        } catch (p) {
            setTimeout(function() {
                throw p
            })
        }
    }
    function fp(i, a, l) {
        return l = Oa(l),
        l.tag = 3,
        l.payload = {
            element: null
        },
        l.callback = function() {
            Ku(i, a)
        }
        ,
        l
    }
    function fy(i) {
        return i = Oa(i),
        i.tag = 3,
        i
    }
    function hy(i, a, l, c) {
        var p = l.type.getDerivedStateFromError;
        if (typeof p == "function") {
            var v = c.value;
            i.payload = function() {
                return p(v)
            }
            ,
            i.callback = function() {
                dy(a, l, c)
            }
        }
        var w = l.stateNode;
        w !== null && typeof w.componentDidCatch == "function" && (i.callback = function() {
            dy(a, l, c),
            typeof p != "function" && (ja === null ? ja = new Set([this]) : ja.add(this));
            var L = c.stack;
            this.componentDidCatch(c.value, {
                componentStack: L !== null ? L : ""
            })
        }
        )
    }
    function aA(i, a, l, c, p) {
        if (l.flags |= 32768,
        c !== null && typeof c == "object" && typeof c.then == "function") {
            if (a = l.alternate,
            a !== null && Hl(a, l, p, !0),
            l = Qi.current,
            l !== null) {
                switch (l.tag) {
                case 13:
                    return Mr === null ? Ip() : l.alternate === null && Pn === 0 && (Pn = 3),
                    l.flags &= -257,
                    l.flags |= 65536,
                    l.lanes = p,
                    c === Vh ? l.flags |= 16384 : (a = l.updateQueue,
                    a === null ? l.updateQueue = new Set([c]) : a.add(c),
                    kp(i, c, p)),
                    !1;
                case 22:
                    return l.flags |= 65536,
                    c === Vh ? l.flags |= 16384 : (a = l.updateQueue,
                    a === null ? (a = {
                        transitions: null,
                        markerInstances: null,
                        retryQueue: new Set([c])
                    },
                    l.updateQueue = a) : (l = a.retryQueue,
                    l === null ? a.retryQueue = new Set([c]) : l.add(c)),
                    kp(i, c, p)),
                    !1
                }
                throw Error(r(435, l.tag))
            }
            return kp(i, c, p),
            Ip(),
            !1
        }
        if (hn)
            return a = Qi.current,
            a !== null ? ((a.flags & 65536) === 0 && (a.flags |= 256),
            a.flags |= 65536,
            a.lanes = p,
            c !== Oh && (i = Error(r(422), {
                cause: c
            }),
            Vl(Yi(i, l)))) : (c !== Oh && (a = Error(r(423), {
                cause: c
            }),
            Vl(Yi(a, l))),
            i = i.current.alternate,
            i.flags |= 65536,
            p &= -p,
            i.lanes |= p,
            c = Yi(c, l),
            p = fp(i.stateNode, c, p),
            jh(i, p),
            Pn !== 4 && (Pn = 2)),
            !1;
        var v = Error(r(520), {
            cause: c
        });
        if (v = Yi(v, l),
        lc === null ? lc = [v] : lc.push(v),
        Pn !== 4 && (Pn = 2),
        a === null)
            return !0;
        c = Yi(c, l),
        l = a;
        do {
            switch (l.tag) {
            case 3:
                return l.flags |= 65536,
                i = p & -p,
                l.lanes |= i,
                i = fp(l.stateNode, c, i),
                jh(l, i),
                !1;
            case 1:
                if (a = l.type,
                v = l.stateNode,
                (l.flags & 128) === 0 && (typeof a.getDerivedStateFromError == "function" || v !== null && typeof v.componentDidCatch == "function" && (ja === null || !ja.has(v))))
                    return l.flags |= 65536,
                    p &= -p,
                    l.lanes |= p,
                    p = fy(p),
                    hy(p, i, l, c),
                    jh(l, p),
                    !1
            }
            l = l.return
        } while (l !== null);
        return !1
    }
    var py = Error(r(461))
      , ni = !1;
    function li(i, a, l, c) {
        a.child = i === null ? ry(a, null, l, c) : To(a, i.child, l, c)
    }
    function my(i, a, l, c, p) {
        l = l.render;
        var v = a.ref;
        if ("ref"in c) {
            var w = {};
            for (var L in c)
                L !== "ref" && (w[L] = c[L])
        } else
            w = c;
        return Us(a),
        c = Zh(i, a, l, w, v, p),
        L = $h(),
        i !== null && !ni ? (Kh(i, a, p),
        Kr(i, a, p)) : (hn && L && Lh(a),
        a.flags |= 1,
        li(i, a, c, p),
        a.child)
    }
    function gy(i, a, l, c, p) {
        if (i === null) {
            var v = l.type;
            return typeof v == "function" && !Ch(v) && v.defaultProps === void 0 && l.compare === null ? (a.tag = 15,
            a.type = v,
            vy(i, a, v, c, p)) : (i = Du(l.type, null, c, a, a.mode, p),
            i.ref = a.ref,
            i.return = a,
            a.child = i)
        }
        if (v = i.child,
        !xp(i, p)) {
            var w = v.memoizedProps;
            if (l = l.compare,
            l = l !== null ? l : zl,
            l(w, c) && i.ref === a.ref)
                return Kr(i, a, p)
        }
        return a.flags |= 1,
        i = jr(v, c),
        i.ref = a.ref,
        i.return = a,
        a.child = i
    }
    function vy(i, a, l, c, p) {
        if (i !== null) {
            var v = i.memoizedProps;
            if (zl(v, c) && i.ref === a.ref)
                if (ni = !1,
                a.pendingProps = c = v,
                xp(i, p))
                    (i.flags & 131072) !== 0 && (ni = !0);
                else
                    return a.lanes = i.lanes,
                    Kr(i, a, p)
        }
        return hp(i, a, l, c, p)
    }
    function _y(i, a, l) {
        var c = a.pendingProps
          , p = c.children
          , v = i !== null ? i.memoizedState : null;
        if (c.mode === "hidden") {
            if ((a.flags & 128) !== 0) {
                if (c = v !== null ? v.baseLanes | l : l,
                i !== null) {
                    for (p = a.child = i.child,
                    v = 0; p !== null; )
                        v = v | p.lanes | p.childLanes,
                        p = p.sibling;
                    a.childLanes = v & ~c
                } else
                    a.childLanes = 0,
                    a.child = null;
                return yy(i, a, c, l)
            }
            if ((l & 536870912) !== 0)
                a.memoizedState = {
                    baseLanes: 0,
                    cachePool: null
                },
                i !== null && Pu(a, v !== null ? v.cachePool : null),
                v !== null ? v0(a, v) : Xh(),
                ay(a);
            else
                return a.lanes = a.childLanes = 536870912,
                yy(i, a, v !== null ? v.baseLanes | l : l, l)
        } else
            v !== null ? (Pu(a, v.cachePool),
            v0(a, v),
            ka(),
            a.memoizedState = null) : (i !== null && Pu(a, null),
            Xh(),
            ka());
        return li(i, a, p, l),
        a.child
    }
    function yy(i, a, l, c) {
        var p = Bh();
        return p = p === null ? null : {
            parent: Yn._currentValue,
            pool: p
        },
        a.memoizedState = {
            baseLanes: l,
            cachePool: p
        },
        i !== null && Pu(a, null),
        Xh(),
        ay(a),
        i !== null && Hl(i, a, c, !0),
        null
    }
    function Qu(i, a) {
        var l = a.ref;
        if (l === null)
            i !== null && i.ref !== null && (a.flags |= 4194816);
        else {
            if (typeof l != "function" && typeof l != "object")
                throw Error(r(284));
            (i === null || i.ref !== l) && (a.flags |= 4194816)
        }
    }
    function hp(i, a, l, c, p) {
        return Us(a),
        l = Zh(i, a, l, c, void 0, p),
        c = $h(),
        i !== null && !ni ? (Kh(i, a, p),
        Kr(i, a, p)) : (hn && c && Lh(a),
        a.flags |= 1,
        li(i, a, l, p),
        a.child)
    }
    function xy(i, a, l, c, p, v) {
        return Us(a),
        a.updateQueue = null,
        l = y0(a, c, l, p),
        _0(i),
        c = $h(),
        i !== null && !ni ? (Kh(i, a, v),
        Kr(i, a, v)) : (hn && c && Lh(a),
        a.flags |= 1,
        li(i, a, l, v),
        a.child)
    }
    function by(i, a, l, c, p) {
        if (Us(a),
        a.stateNode === null) {
            var v = go
              , w = l.contextType;
            typeof w == "object" && w !== null && (v = mi(w)),
            v = new l(c,v),
            a.memoizedState = v.state !== null && v.state !== void 0 ? v.state : null,
            v.updater = dp,
            a.stateNode = v,
            v._reactInternals = a,
            v = a.stateNode,
            v.props = c,
            v.state = a.memoizedState,
            v.refs = {},
            Hh(a),
            w = l.contextType,
            v.context = typeof w == "object" && w !== null ? mi(w) : go,
            v.state = a.memoizedState,
            w = l.getDerivedStateFromProps,
            typeof w == "function" && (up(a, l, w, c),
            v.state = a.memoizedState),
            typeof l.getDerivedStateFromProps == "function" || typeof v.getSnapshotBeforeUpdate == "function" || typeof v.UNSAFE_componentWillMount != "function" && typeof v.componentWillMount != "function" || (w = v.state,
            typeof v.componentWillMount == "function" && v.componentWillMount(),
            typeof v.UNSAFE_componentWillMount == "function" && v.UNSAFE_componentWillMount(),
            w !== v.state && dp.enqueueReplaceState(v, v.state, null),
            Zl(a, c, v, p),
            Yl(),
            v.state = a.memoizedState),
            typeof v.componentDidMount == "function" && (a.flags |= 4194308),
            c = !0
        } else if (i === null) {
            v = a.stateNode;
            var L = a.memoizedProps
              , Y = Os(l, L);
            v.props = Y;
            var me = v.context
              , Re = l.contextType;
            w = go,
            typeof Re == "object" && Re !== null && (w = mi(Re));
            var Pe = l.getDerivedStateFromProps;
            Re = typeof Pe == "function" || typeof v.getSnapshotBeforeUpdate == "function",
            L = a.pendingProps !== L,
            Re || typeof v.UNSAFE_componentWillReceiveProps != "function" && typeof v.componentWillReceiveProps != "function" || (L || me !== w) && oy(a, v, c, w),
            Na = !1;
            var ve = a.memoizedState;
            v.state = ve,
            Zl(a, c, v, p),
            Yl(),
            me = a.memoizedState,
            L || ve !== me || Na ? (typeof Pe == "function" && (up(a, l, Pe, c),
            me = a.memoizedState),
            (Y = Na || sy(a, l, Y, c, ve, me, w)) ? (Re || typeof v.UNSAFE_componentWillMount != "function" && typeof v.componentWillMount != "function" || (typeof v.componentWillMount == "function" && v.componentWillMount(),
            typeof v.UNSAFE_componentWillMount == "function" && v.UNSAFE_componentWillMount()),
            typeof v.componentDidMount == "function" && (a.flags |= 4194308)) : (typeof v.componentDidMount == "function" && (a.flags |= 4194308),
            a.memoizedProps = c,
            a.memoizedState = me),
            v.props = c,
            v.state = me,
            v.context = w,
            c = Y) : (typeof v.componentDidMount == "function" && (a.flags |= 4194308),
            c = !1)
        } else {
            v = a.stateNode,
            Gh(i, a),
            w = a.memoizedProps,
            Re = Os(l, w),
            v.props = Re,
            Pe = a.pendingProps,
            ve = v.context,
            me = l.contextType,
            Y = go,
            typeof me == "object" && me !== null && (Y = mi(me)),
            L = l.getDerivedStateFromProps,
            (me = typeof L == "function" || typeof v.getSnapshotBeforeUpdate == "function") || typeof v.UNSAFE_componentWillReceiveProps != "function" && typeof v.componentWillReceiveProps != "function" || (w !== Pe || ve !== Y) && oy(a, v, c, Y),
            Na = !1,
            ve = a.memoizedState,
            v.state = ve,
            Zl(a, c, v, p),
            Yl();
            var be = a.memoizedState;
            w !== Pe || ve !== be || Na || i !== null && i.dependencies !== null && Nu(i.dependencies) ? (typeof L == "function" && (up(a, l, L, c),
            be = a.memoizedState),
            (Re = Na || sy(a, l, Re, c, ve, be, Y) || i !== null && i.dependencies !== null && Nu(i.dependencies)) ? (me || typeof v.UNSAFE_componentWillUpdate != "function" && typeof v.componentWillUpdate != "function" || (typeof v.componentWillUpdate == "function" && v.componentWillUpdate(c, be, Y),
            typeof v.UNSAFE_componentWillUpdate == "function" && v.UNSAFE_componentWillUpdate(c, be, Y)),
            typeof v.componentDidUpdate == "function" && (a.flags |= 4),
            typeof v.getSnapshotBeforeUpdate == "function" && (a.flags |= 1024)) : (typeof v.componentDidUpdate != "function" || w === i.memoizedProps && ve === i.memoizedState || (a.flags |= 4),
            typeof v.getSnapshotBeforeUpdate != "function" || w === i.memoizedProps && ve === i.memoizedState || (a.flags |= 1024),
            a.memoizedProps = c,
            a.memoizedState = be),
            v.props = c,
            v.state = be,
            v.context = Y,
            c = Re) : (typeof v.componentDidUpdate != "function" || w === i.memoizedProps && ve === i.memoizedState || (a.flags |= 4),
            typeof v.getSnapshotBeforeUpdate != "function" || w === i.memoizedProps && ve === i.memoizedState || (a.flags |= 1024),
            c = !1)
        }
        return v = c,
        Qu(i, a),
        c = (a.flags & 128) !== 0,
        v || c ? (v = a.stateNode,
        l = c && typeof l.getDerivedStateFromError != "function" ? null : v.render(),
        a.flags |= 1,
        i !== null && c ? (a.child = To(a, i.child, null, p),
        a.child = To(a, null, l, p)) : li(i, a, l, p),
        a.memoizedState = v.state,
        i = a.child) : i = Kr(i, a, p),
        i
    }
    function Sy(i, a, l, c) {
        return Bl(),
        a.flags |= 256,
        li(i, a, l, c),
        a.child
    }
    var pp = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0,
        hydrationErrors: null
    };
    function mp(i) {
        return {
            baseLanes: i,
            cachePool: c0()
        }
    }
    function gp(i, a, l) {
        return i = i !== null ? i.childLanes & ~l : 0,
        a && (i |= Ji),
        i
    }
    function Ey(i, a, l) {
        var c = a.pendingProps, p = !1, v = (a.flags & 128) !== 0, w;
        if ((w = v) || (w = i !== null && i.memoizedState === null ? !1 : (Zn.current & 2) !== 0),
        w && (p = !0,
        a.flags &= -129),
        w = (a.flags & 32) !== 0,
        a.flags &= -33,
        i === null) {
            if (hn) {
                if (p ? za(a) : ka(),
                hn) {
                    var L = On, Y;
                    if (Y = L) {
                        e: {
                            for (Y = L,
                            L = Er; Y.nodeType !== 8; ) {
                                if (!L) {
                                    L = null;
                                    break e
                                }
                                if (Y = dr(Y.nextSibling),
                                Y === null) {
                                    L = null;
                                    break e
                                }
                            }
                            L = Y
                        }
                        L !== null ? (a.memoizedState = {
                            dehydrated: L,
                            treeContext: Ts !== null ? {
                                id: Wr,
                                overflow: Xr
                            } : null,
                            retryLane: 536870912,
                            hydrationErrors: null
                        },
                        Y = Ii(18, null, null, 0),
                        Y.stateNode = L,
                        Y.return = a,
                        a.child = Y,
                        yi = a,
                        On = null,
                        Y = !0) : Y = !1
                    }
                    Y || Cs(a)
                }
                if (L = a.memoizedState,
                L !== null && (L = L.dehydrated,
                L !== null))
                    return Jp(L) ? a.lanes = 32 : a.lanes = 536870912,
                    null;
                $r(a)
            }
            return L = c.children,
            c = c.fallback,
            p ? (ka(),
            p = a.mode,
            L = Ju({
                mode: "hidden",
                children: L
            }, p),
            c = ws(c, p, l, null),
            L.return = a,
            c.return = a,
            L.sibling = c,
            a.child = L,
            p = a.child,
            p.memoizedState = mp(l),
            p.childLanes = gp(i, w, l),
            a.memoizedState = pp,
            c) : (za(a),
            vp(a, L))
        }
        if (Y = i.memoizedState,
        Y !== null && (L = Y.dehydrated,
        L !== null)) {
            if (v)
                a.flags & 256 ? (za(a),
                a.flags &= -257,
                a = _p(i, a, l)) : a.memoizedState !== null ? (ka(),
                a.child = i.child,
                a.flags |= 128,
                a = null) : (ka(),
                p = c.fallback,
                L = a.mode,
                c = Ju({
                    mode: "visible",
                    children: c.children
                }, L),
                p = ws(p, L, l, null),
                p.flags |= 2,
                c.return = a,
                p.return = a,
                c.sibling = p,
                a.child = c,
                To(a, i.child, null, l),
                c = a.child,
                c.memoizedState = mp(l),
                c.childLanes = gp(i, w, l),
                a.memoizedState = pp,
                a = p);
            else if (za(a),
            Jp(L)) {
                if (w = L.nextSibling && L.nextSibling.dataset,
                w)
                    var me = w.dgst;
                w = me,
                c = Error(r(419)),
                c.stack = "",
                c.digest = w,
                Vl({
                    value: c,
                    source: null,
                    stack: null
                }),
                a = _p(i, a, l)
            } else if (ni || Hl(i, a, l, !1),
            w = (l & i.childLanes) !== 0,
            ni || w) {
                if (w = Rn,
                w !== null && (c = l & -l,
                c = (c & 42) !== 0 ? 1 : zt(c),
                c = (c & (w.suspendedLanes | l)) !== 0 ? 0 : c,
                c !== 0 && c !== Y.retryLane))
                    throw Y.retryLane = c,
                    mo(i, c),
                    Vi(w, i, c),
                    py;
                L.data === "$?" || Ip(),
                a = _p(i, a, l)
            } else
                L.data === "$?" ? (a.flags |= 192,
                a.child = i.child,
                a = null) : (i = Y.treeContext,
                On = dr(L.nextSibling),
                yi = a,
                hn = !0,
                Rs = null,
                Er = !1,
                i !== null && ($i[Ki++] = Wr,
                $i[Ki++] = Xr,
                $i[Ki++] = Ts,
                Wr = i.id,
                Xr = i.overflow,
                Ts = a),
                a = vp(a, c.children),
                a.flags |= 4096);
            return a
        }
        return p ? (ka(),
        p = c.fallback,
        L = a.mode,
        Y = i.child,
        me = Y.sibling,
        c = jr(Y, {
            mode: "hidden",
            children: c.children
        }),
        c.subtreeFlags = Y.subtreeFlags & 65011712,
        me !== null ? p = jr(me, p) : (p = ws(p, L, l, null),
        p.flags |= 2),
        p.return = a,
        c.return = a,
        c.sibling = p,
        a.child = c,
        c = p,
        p = a.child,
        L = i.child.memoizedState,
        L === null ? L = mp(l) : (Y = L.cachePool,
        Y !== null ? (me = Yn._currentValue,
        Y = Y.parent !== me ? {
            parent: me,
            pool: me
        } : Y) : Y = c0(),
        L = {
            baseLanes: L.baseLanes | l,
            cachePool: Y
        }),
        p.memoizedState = L,
        p.childLanes = gp(i, w, l),
        a.memoizedState = pp,
        c) : (za(a),
        l = i.child,
        i = l.sibling,
        l = jr(l, {
            mode: "visible",
            children: c.children
        }),
        l.return = a,
        l.sibling = null,
        i !== null && (w = a.deletions,
        w === null ? (a.deletions = [i],
        a.flags |= 16) : w.push(i)),
        a.child = l,
        a.memoizedState = null,
        l)
    }
    function vp(i, a) {
        return a = Ju({
            mode: "visible",
            children: a
        }, i.mode),
        a.return = i,
        i.child = a
    }
    function Ju(i, a) {
        return i = Ii(22, i, null, a),
        i.lanes = 0,
        i.stateNode = {
            _visibility: 1,
            _pendingMarkers: null,
            _retryCache: null,
            _transitions: null
        },
        i
    }
    function _p(i, a, l) {
        return To(a, i.child, null, l),
        i = vp(a, a.pendingProps.children),
        i.flags |= 2,
        a.memoizedState = null,
        i
    }
    function My(i, a, l) {
        i.lanes |= a;
        var c = i.alternate;
        c !== null && (c.lanes |= a),
        Ih(i.return, a, l)
    }
    function yp(i, a, l, c, p) {
        var v = i.memoizedState;
        v === null ? i.memoizedState = {
            isBackwards: a,
            rendering: null,
            renderingStartTime: 0,
            last: c,
            tail: l,
            tailMode: p
        } : (v.isBackwards = a,
        v.rendering = null,
        v.renderingStartTime = 0,
        v.last = c,
        v.tail = l,
        v.tailMode = p)
    }
    function wy(i, a, l) {
        var c = a.pendingProps
          , p = c.revealOrder
          , v = c.tail;
        if (li(i, a, c.children, l),
        c = Zn.current,
        (c & 2) !== 0)
            c = c & 1 | 2,
            a.flags |= 128;
        else {
            if (i !== null && (i.flags & 128) !== 0)
                e: for (i = a.child; i !== null; ) {
                    if (i.tag === 13)
                        i.memoizedState !== null && My(i, l, a);
                    else if (i.tag === 19)
                        My(i, l, a);
                    else if (i.child !== null) {
                        i.child.return = i,
                        i = i.child;
                        continue
                    }
                    if (i === a)
                        break e;
                    for (; i.sibling === null; ) {
                        if (i.return === null || i.return === a)
                            break e;
                        i = i.return
                    }
                    i.sibling.return = i.return,
                    i = i.sibling
                }
            c &= 1
        }
        switch (pe(Zn, c),
        p) {
        case "forwards":
            for (l = a.child,
            p = null; l !== null; )
                i = l.alternate,
                i !== null && Zu(i) === null && (p = l),
                l = l.sibling;
            l = p,
            l === null ? (p = a.child,
            a.child = null) : (p = l.sibling,
            l.sibling = null),
            yp(a, !1, p, l, v);
            break;
        case "backwards":
            for (l = null,
            p = a.child,
            a.child = null; p !== null; ) {
                if (i = p.alternate,
                i !== null && Zu(i) === null) {
                    a.child = p;
                    break
                }
                i = p.sibling,
                p.sibling = l,
                l = p,
                p = i
            }
            yp(a, !0, l, null, v);
            break;
        case "together":
            yp(a, !1, null, null, void 0);
            break;
        default:
            a.memoizedState = null
        }
        return a.child
    }
    function Kr(i, a, l) {
        if (i !== null && (a.dependencies = i.dependencies),
        Ga |= a.lanes,
        (l & a.childLanes) === 0)
            if (i !== null) {
                if (Hl(i, a, l, !1),
                (l & a.childLanes) === 0)
                    return null
            } else
                return null;
        if (i !== null && a.child !== i.child)
            throw Error(r(153));
        if (a.child !== null) {
            for (i = a.child,
            l = jr(i, i.pendingProps),
            a.child = l,
            l.return = a; i.sibling !== null; )
                i = i.sibling,
                l = l.sibling = jr(i, i.pendingProps),
                l.return = a;
            l.sibling = null
        }
        return a.child
    }
    function xp(i, a) {
        return (i.lanes & a) !== 0 ? !0 : (i = i.dependencies,
        !!(i !== null && Nu(i)))
    }
    function sA(i, a, l) {
        switch (a.tag) {
        case 3:
            Ve(a, a.stateNode.containerInfo),
            La(a, Yn, i.memoizedState.cache),
            Bl();
            break;
        case 27:
        case 5:
            He(a);
            break;
        case 4:
            Ve(a, a.stateNode.containerInfo);
            break;
        case 10:
            La(a, a.type, a.memoizedProps.value);
            break;
        case 13:
            var c = a.memoizedState;
            if (c !== null)
                return c.dehydrated !== null ? (za(a),
                a.flags |= 128,
                null) : (l & a.child.childLanes) !== 0 ? Ey(i, a, l) : (za(a),
                i = Kr(i, a, l),
                i !== null ? i.sibling : null);
            za(a);
            break;
        case 19:
            var p = (i.flags & 128) !== 0;
            if (c = (l & a.childLanes) !== 0,
            c || (Hl(i, a, l, !1),
            c = (l & a.childLanes) !== 0),
            p) {
                if (c)
                    return wy(i, a, l);
                a.flags |= 128
            }
            if (p = a.memoizedState,
            p !== null && (p.rendering = null,
            p.tail = null,
            p.lastEffect = null),
            pe(Zn, Zn.current),
            c)
                break;
            return null;
        case 22:
        case 23:
            return a.lanes = 0,
            _y(i, a, l);
        case 24:
            La(a, Yn, i.memoizedState.cache)
        }
        return Kr(i, a, l)
    }
    function Ty(i, a, l) {
        if (i !== null)
            if (i.memoizedProps !== a.pendingProps)
                ni = !0;
            else {
                if (!xp(i, l) && (a.flags & 128) === 0)
                    return ni = !1,
                    sA(i, a, l);
                ni = (i.flags & 131072) !== 0
            }
        else
            ni = !1,
            hn && (a.flags & 1048576) !== 0 && n0(a, Lu, a.index);
        switch (a.lanes = 0,
        a.tag) {
        case 16:
            e: {
                i = a.pendingProps;
                var c = a.elementType
                  , p = c._init;
                if (c = p(c._payload),
                a.type = c,
                typeof c == "function")
                    Ch(c) ? (i = Os(c, i),
                    a.tag = 1,
                    a = by(null, a, c, i, l)) : (a.tag = 0,
                    a = hp(null, a, c, i, l));
                else {
                    if (c != null) {
                        if (p = c.$$typeof,
                        p === C) {
                            a.tag = 11,
                            a = my(null, a, c, i, l);
                            break e
                        } else if (p === F) {
                            a.tag = 14,
                            a = gy(null, a, c, i, l);
                            break e
                        }
                    }
                    throw a = oe(c) || c,
                    Error(r(306, a, ""))
                }
            }
            return a;
        case 0:
            return hp(i, a, a.type, a.pendingProps, l);
        case 1:
            return c = a.type,
            p = Os(c, a.pendingProps),
            by(i, a, c, p, l);
        case 3:
            e: {
                if (Ve(a, a.stateNode.containerInfo),
                i === null)
                    throw Error(r(387));
                c = a.pendingProps;
                var v = a.memoizedState;
                p = v.element,
                Gh(i, a),
                Zl(a, c, null, l);
                var w = a.memoizedState;
                if (c = w.cache,
                La(a, Yn, c),
                c !== v.cache && zh(a, [Yn], l, !0),
                Yl(),
                c = w.element,
                v.isDehydrated)
                    if (v = {
                        element: c,
                        isDehydrated: !1,
                        cache: w.cache
                    },
                    a.updateQueue.baseState = v,
                    a.memoizedState = v,
                    a.flags & 256) {
                        a = Sy(i, a, c, l);
                        break e
                    } else if (c !== p) {
                        p = Yi(Error(r(424)), a),
                        Vl(p),
                        a = Sy(i, a, c, l);
                        break e
                    } else {
                        switch (i = a.stateNode.containerInfo,
                        i.nodeType) {
                        case 9:
                            i = i.body;
                            break;
                        default:
                            i = i.nodeName === "HTML" ? i.ownerDocument.body : i
                        }
                        for (On = dr(i.firstChild),
                        yi = a,
                        hn = !0,
                        Rs = null,
                        Er = !0,
                        l = ry(a, null, c, l),
                        a.child = l; l; )
                            l.flags = l.flags & -3 | 4096,
                            l = l.sibling
                    }
                else {
                    if (Bl(),
                    c === p) {
                        a = Kr(i, a, l);
                        break e
                    }
                    li(i, a, c, l)
                }
                a = a.child
            }
            return a;
        case 26:
            return Qu(i, a),
            i === null ? (l = Dx(a.type, null, a.pendingProps, null)) ? a.memoizedState = l : hn || (l = a.type,
            i = a.pendingProps,
            c = hd(Se.current).createElement(l),
            c[Ue] = a,
            c[ze] = i,
            ui(c, l, i),
            on(c),
            a.stateNode = c) : a.memoizedState = Dx(a.type, i.memoizedProps, a.pendingProps, i.memoizedState),
            null;
        case 27:
            return He(a),
            i === null && hn && (c = a.stateNode = Ax(a.type, a.pendingProps, Se.current),
            yi = a,
            Er = !0,
            p = On,
            qa(a.type) ? (em = p,
            On = dr(c.firstChild)) : On = p),
            li(i, a, a.pendingProps.children, l),
            Qu(i, a),
            i === null && (a.flags |= 4194304),
            a.child;
        case 5:
            return i === null && hn && ((p = c = On) && (c = OA(c, a.type, a.pendingProps, Er),
            c !== null ? (a.stateNode = c,
            yi = a,
            On = dr(c.firstChild),
            Er = !1,
            p = !0) : p = !1),
            p || Cs(a)),
            He(a),
            p = a.type,
            v = a.pendingProps,
            w = i !== null ? i.memoizedProps : null,
            c = v.children,
            $p(p, v) ? c = null : w !== null && $p(p, w) && (a.flags |= 32),
            a.memoizedState !== null && (p = Zh(i, a, QT, null, null, l),
            vc._currentValue = p),
            Qu(i, a),
            li(i, a, c, l),
            a.child;
        case 6:
            return i === null && hn && ((i = l = On) && (l = PA(l, a.pendingProps, Er),
            l !== null ? (a.stateNode = l,
            yi = a,
            On = null,
            i = !0) : i = !1),
            i || Cs(a)),
            null;
        case 13:
            return Ey(i, a, l);
        case 4:
            return Ve(a, a.stateNode.containerInfo),
            c = a.pendingProps,
            i === null ? a.child = To(a, null, c, l) : li(i, a, c, l),
            a.child;
        case 11:
            return my(i, a, a.type, a.pendingProps, l);
        case 7:
            return li(i, a, a.pendingProps, l),
            a.child;
        case 8:
            return li(i, a, a.pendingProps.children, l),
            a.child;
        case 12:
            return li(i, a, a.pendingProps.children, l),
            a.child;
        case 10:
            return c = a.pendingProps,
            La(a, a.type, c.value),
            li(i, a, c.children, l),
            a.child;
        case 9:
            return p = a.type._context,
            c = a.pendingProps.children,
            Us(a),
            p = mi(p),
            c = c(p),
            a.flags |= 1,
            li(i, a, c, l),
            a.child;
        case 14:
            return gy(i, a, a.type, a.pendingProps, l);
        case 15:
            return vy(i, a, a.type, a.pendingProps, l);
        case 19:
            return wy(i, a, l);
        case 31:
            return c = a.pendingProps,
            l = a.mode,
            c = {
                mode: c.mode,
                children: c.children
            },
            i === null ? (l = Ju(c, l),
            l.ref = a.ref,
            a.child = l,
            l.return = a,
            a = l) : (l = jr(i.child, c),
            l.ref = a.ref,
            a.child = l,
            l.return = a,
            a = l),
            a;
        case 22:
            return _y(i, a, l);
        case 24:
            return Us(a),
            c = mi(Yn),
            i === null ? (p = Bh(),
            p === null && (p = Rn,
            v = kh(),
            p.pooledCache = v,
            v.refCount++,
            v !== null && (p.pooledCacheLanes |= l),
            p = v),
            a.memoizedState = {
                parent: c,
                cache: p
            },
            Hh(a),
            La(a, Yn, p)) : ((i.lanes & l) !== 0 && (Gh(i, a),
            Zl(a, null, null, l),
            Yl()),
            p = i.memoizedState,
            v = a.memoizedState,
            p.parent !== c ? (p = {
                parent: c,
                cache: c
            },
            a.memoizedState = p,
            a.lanes === 0 && (a.memoizedState = a.updateQueue.baseState = p),
            La(a, Yn, c)) : (c = v.cache,
            La(a, Yn, c),
            c !== p.cache && zh(a, [Yn], l, !0))),
            li(i, a, a.pendingProps.children, l),
            a.child;
        case 29:
            throw a.pendingProps
        }
        throw Error(r(156, a.tag))
    }
    function Qr(i) {
        i.flags |= 4
    }
    function Ay(i, a) {
        if (a.type !== "stylesheet" || (a.state.loading & 4) !== 0)
            i.flags &= -16777217;
        else if (i.flags |= 16777216,
        !Px(a)) {
            if (a = Qi.current,
            a !== null && ((ln & 4194048) === ln ? Mr !== null : (ln & 62914560) !== ln && (ln & 536870912) === 0 || a !== Mr))
                throw Xl = Vh,
                u0;
            i.flags |= 8192
        }
    }
    function ed(i, a) {
        a !== null && (i.flags |= 4),
        i.flags & 16384 && (a = i.tag !== 22 ? Ye() : 536870912,
        i.lanes |= a,
        Do |= a)
    }
    function nc(i, a) {
        if (!hn)
            switch (i.tailMode) {
            case "hidden":
                a = i.tail;
                for (var l = null; a !== null; )
                    a.alternate !== null && (l = a),
                    a = a.sibling;
                l === null ? i.tail = null : l.sibling = null;
                break;
            case "collapsed":
                l = i.tail;
                for (var c = null; l !== null; )
                    l.alternate !== null && (c = l),
                    l = l.sibling;
                c === null ? a || i.tail === null ? i.tail = null : i.tail.sibling = null : c.sibling = null
            }
    }
    function Un(i) {
        var a = i.alternate !== null && i.alternate.child === i.child
          , l = 0
          , c = 0;
        if (a)
            for (var p = i.child; p !== null; )
                l |= p.lanes | p.childLanes,
                c |= p.subtreeFlags & 65011712,
                c |= p.flags & 65011712,
                p.return = i,
                p = p.sibling;
        else
            for (p = i.child; p !== null; )
                l |= p.lanes | p.childLanes,
                c |= p.subtreeFlags,
                c |= p.flags,
                p.return = i,
                p = p.sibling;
        return i.subtreeFlags |= c,
        i.childLanes = l,
        a
    }
    function oA(i, a, l) {
        var c = a.pendingProps;
        switch (Nh(a),
        a.tag) {
        case 31:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
            return Un(a),
            null;
        case 1:
            return Un(a),
            null;
        case 3:
            return l = a.stateNode,
            c = null,
            i !== null && (c = i.memoizedState.cache),
            a.memoizedState.cache !== c && (a.flags |= 2048),
            Yr(Yn),
            _t(),
            l.pendingContext && (l.context = l.pendingContext,
            l.pendingContext = null),
            (i === null || i.child === null) && (Fl(a) ? Qr(a) : i === null || i.memoizedState.isDehydrated && (a.flags & 256) === 0 || (a.flags |= 1024,
            a0())),
            Un(a),
            null;
        case 26:
            return l = a.memoizedState,
            i === null ? (Qr(a),
            l !== null ? (Un(a),
            Ay(a, l)) : (Un(a),
            a.flags &= -16777217)) : l ? l !== i.memoizedState ? (Qr(a),
            Un(a),
            Ay(a, l)) : (Un(a),
            a.flags &= -16777217) : (i.memoizedProps !== c && Qr(a),
            Un(a),
            a.flags &= -16777217),
            null;
        case 27:
            Pt(a),
            l = Se.current;
            var p = a.type;
            if (i !== null && a.stateNode != null)
                i.memoizedProps !== c && Qr(a);
            else {
                if (!c) {
                    if (a.stateNode === null)
                        throw Error(r(166));
                    return Un(a),
                    null
                }
                i = te.current,
                Fl(a) ? i0(a) : (i = Ax(p, c, l),
                a.stateNode = i,
                Qr(a))
            }
            return Un(a),
            null;
        case 5:
            if (Pt(a),
            l = a.type,
            i !== null && a.stateNode != null)
                i.memoizedProps !== c && Qr(a);
            else {
                if (!c) {
                    if (a.stateNode === null)
                        throw Error(r(166));
                    return Un(a),
                    null
                }
                if (i = te.current,
                Fl(a))
                    i0(a);
                else {
                    switch (p = hd(Se.current),
                    i) {
                    case 1:
                        i = p.createElementNS("http://www.w3.org/2000/svg", l);
                        break;
                    case 2:
                        i = p.createElementNS("http://www.w3.org/1998/Math/MathML", l);
                        break;
                    default:
                        switch (l) {
                        case "svg":
                            i = p.createElementNS("http://www.w3.org/2000/svg", l);
                            break;
                        case "math":
                            i = p.createElementNS("http://www.w3.org/1998/Math/MathML", l);
                            break;
                        case "script":
                            i = p.createElement("div"),
                            i.innerHTML = "<script><\/script>",
                            i = i.removeChild(i.firstChild);
                            break;
                        case "select":
                            i = typeof c.is == "string" ? p.createElement("select", {
                                is: c.is
                            }) : p.createElement("select"),
                            c.multiple ? i.multiple = !0 : c.size && (i.size = c.size);
                            break;
                        default:
                            i = typeof c.is == "string" ? p.createElement(l, {
                                is: c.is
                            }) : p.createElement(l)
                        }
                    }
                    i[Ue] = a,
                    i[ze] = c;
                    e: for (p = a.child; p !== null; ) {
                        if (p.tag === 5 || p.tag === 6)
                            i.appendChild(p.stateNode);
                        else if (p.tag !== 4 && p.tag !== 27 && p.child !== null) {
                            p.child.return = p,
                            p = p.child;
                            continue
                        }
                        if (p === a)
                            break e;
                        for (; p.sibling === null; ) {
                            if (p.return === null || p.return === a)
                                break e;
                            p = p.return
                        }
                        p.sibling.return = p.return,
                        p = p.sibling
                    }
                    a.stateNode = i;
                    e: switch (ui(i, l, c),
                    l) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        i = !!c.autoFocus;
                        break e;
                    case "img":
                        i = !0;
                        break e;
                    default:
                        i = !1
                    }
                    i && Qr(a)
                }
            }
            return Un(a),
            a.flags &= -16777217,
            null;
        case 6:
            if (i && a.stateNode != null)
                i.memoizedProps !== c && Qr(a);
            else {
                if (typeof c != "string" && a.stateNode === null)
                    throw Error(r(166));
                if (i = Se.current,
                Fl(a)) {
                    if (i = a.stateNode,
                    l = a.memoizedProps,
                    c = null,
                    p = yi,
                    p !== null)
                        switch (p.tag) {
                        case 27:
                        case 5:
                            c = p.memoizedProps
                        }
                    i[Ue] = a,
                    i = !!(i.nodeValue === l || c !== null && c.suppressHydrationWarning === !0 || xx(i.nodeValue, l)),
                    i || Cs(a)
                } else
                    i = hd(i).createTextNode(c),
                    i[Ue] = a,
                    a.stateNode = i
            }
            return Un(a),
            null;
        case 13:
            if (c = a.memoizedState,
            i === null || i.memoizedState !== null && i.memoizedState.dehydrated !== null) {
                if (p = Fl(a),
                c !== null && c.dehydrated !== null) {
                    if (i === null) {
                        if (!p)
                            throw Error(r(318));
                        if (p = a.memoizedState,
                        p = p !== null ? p.dehydrated : null,
                        !p)
                            throw Error(r(317));
                        p[Ue] = a
                    } else
                        Bl(),
                        (a.flags & 128) === 0 && (a.memoizedState = null),
                        a.flags |= 4;
                    Un(a),
                    p = !1
                } else
                    p = a0(),
                    i !== null && i.memoizedState !== null && (i.memoizedState.hydrationErrors = p),
                    p = !0;
                if (!p)
                    return a.flags & 256 ? ($r(a),
                    a) : ($r(a),
                    null)
            }
            if ($r(a),
            (a.flags & 128) !== 0)
                return a.lanes = l,
                a;
            if (l = c !== null,
            i = i !== null && i.memoizedState !== null,
            l) {
                c = a.child,
                p = null,
                c.alternate !== null && c.alternate.memoizedState !== null && c.alternate.memoizedState.cachePool !== null && (p = c.alternate.memoizedState.cachePool.pool);
                var v = null;
                c.memoizedState !== null && c.memoizedState.cachePool !== null && (v = c.memoizedState.cachePool.pool),
                v !== p && (c.flags |= 2048)
            }
            return l !== i && l && (a.child.flags |= 8192),
            ed(a, a.updateQueue),
            Un(a),
            null;
        case 4:
            return _t(),
            i === null && Wp(a.stateNode.containerInfo),
            Un(a),
            null;
        case 10:
            return Yr(a.type),
            Un(a),
            null;
        case 19:
            if (ge(Zn),
            p = a.memoizedState,
            p === null)
                return Un(a),
                null;
            if (c = (a.flags & 128) !== 0,
            v = p.rendering,
            v === null)
                if (c)
                    nc(p, !1);
                else {
                    if (Pn !== 0 || i !== null && (i.flags & 128) !== 0)
                        for (i = a.child; i !== null; ) {
                            if (v = Zu(i),
                            v !== null) {
                                for (a.flags |= 128,
                                nc(p, !1),
                                i = v.updateQueue,
                                a.updateQueue = i,
                                ed(a, i),
                                a.subtreeFlags = 0,
                                i = l,
                                l = a.child; l !== null; )
                                    t0(l, i),
                                    l = l.sibling;
                                return pe(Zn, Zn.current & 1 | 2),
                                a.child
                            }
                            i = i.sibling
                        }
                    p.tail !== null && it() > id && (a.flags |= 128,
                    c = !0,
                    nc(p, !1),
                    a.lanes = 4194304)
                }
            else {
                if (!c)
                    if (i = Zu(v),
                    i !== null) {
                        if (a.flags |= 128,
                        c = !0,
                        i = i.updateQueue,
                        a.updateQueue = i,
                        ed(a, i),
                        nc(p, !0),
                        p.tail === null && p.tailMode === "hidden" && !v.alternate && !hn)
                            return Un(a),
                            null
                    } else
                        2 * it() - p.renderingStartTime > id && l !== 536870912 && (a.flags |= 128,
                        c = !0,
                        nc(p, !1),
                        a.lanes = 4194304);
                p.isBackwards ? (v.sibling = a.child,
                a.child = v) : (i = p.last,
                i !== null ? i.sibling = v : a.child = v,
                p.last = v)
            }
            return p.tail !== null ? (a = p.tail,
            p.rendering = a,
            p.tail = a.sibling,
            p.renderingStartTime = it(),
            a.sibling = null,
            i = Zn.current,
            pe(Zn, c ? i & 1 | 2 : i & 1),
            a) : (Un(a),
            null);
        case 22:
        case 23:
            return $r(a),
            qh(),
            c = a.memoizedState !== null,
            i !== null ? i.memoizedState !== null !== c && (a.flags |= 8192) : c && (a.flags |= 8192),
            c ? (l & 536870912) !== 0 && (a.flags & 128) === 0 && (Un(a),
            a.subtreeFlags & 6 && (a.flags |= 8192)) : Un(a),
            l = a.updateQueue,
            l !== null && ed(a, l.retryQueue),
            l = null,
            i !== null && i.memoizedState !== null && i.memoizedState.cachePool !== null && (l = i.memoizedState.cachePool.pool),
            c = null,
            a.memoizedState !== null && a.memoizedState.cachePool !== null && (c = a.memoizedState.cachePool.pool),
            c !== l && (a.flags |= 2048),
            i !== null && ge(Ls),
            null;
        case 24:
            return l = null,
            i !== null && (l = i.memoizedState.cache),
            a.memoizedState.cache !== l && (a.flags |= 2048),
            Yr(Yn),
            Un(a),
            null;
        case 25:
            return null;
        case 30:
            return null
        }
        throw Error(r(156, a.tag))
    }
    function lA(i, a) {
        switch (Nh(a),
        a.tag) {
        case 1:
            return i = a.flags,
            i & 65536 ? (a.flags = i & -65537 | 128,
            a) : null;
        case 3:
            return Yr(Yn),
            _t(),
            i = a.flags,
            (i & 65536) !== 0 && (i & 128) === 0 ? (a.flags = i & -65537 | 128,
            a) : null;
        case 26:
        case 27:
        case 5:
            return Pt(a),
            null;
        case 13:
            if ($r(a),
            i = a.memoizedState,
            i !== null && i.dehydrated !== null) {
                if (a.alternate === null)
                    throw Error(r(340));
                Bl()
            }
            return i = a.flags,
            i & 65536 ? (a.flags = i & -65537 | 128,
            a) : null;
        case 19:
            return ge(Zn),
            null;
        case 4:
            return _t(),
            null;
        case 10:
            return Yr(a.type),
            null;
        case 22:
        case 23:
            return $r(a),
            qh(),
            i !== null && ge(Ls),
            i = a.flags,
            i & 65536 ? (a.flags = i & -65537 | 128,
            a) : null;
        case 24:
            return Yr(Yn),
            null;
        case 25:
            return null;
        default:
            return null
        }
    }
    function Ry(i, a) {
        switch (Nh(a),
        a.tag) {
        case 3:
            Yr(Yn),
            _t();
            break;
        case 26:
        case 27:
        case 5:
            Pt(a);
            break;
        case 4:
            _t();
            break;
        case 13:
            $r(a);
            break;
        case 19:
            ge(Zn);
            break;
        case 10:
            Yr(a.type);
            break;
        case 22:
        case 23:
            $r(a),
            qh(),
            i !== null && ge(Ls);
            break;
        case 24:
            Yr(Yn)
        }
    }
    function ic(i, a) {
        try {
            var l = a.updateQueue
              , c = l !== null ? l.lastEffect : null;
            if (c !== null) {
                var p = c.next;
                l = p;
                do {
                    if ((l.tag & i) === i) {
                        c = void 0;
                        var v = l.create
                          , w = l.inst;
                        c = v(),
                        w.destroy = c
                    }
                    l = l.next
                } while (l !== p)
            }
        } catch (L) {
            wn(a, a.return, L)
        }
    }
    function Fa(i, a, l) {
        try {
            var c = a.updateQueue
              , p = c !== null ? c.lastEffect : null;
            if (p !== null) {
                var v = p.next;
                c = v;
                do {
                    if ((c.tag & i) === i) {
                        var w = c.inst
                          , L = w.destroy;
                        if (L !== void 0) {
                            w.destroy = void 0,
                            p = a;
                            var Y = l
                              , me = L;
                            try {
                                me()
                            } catch (Re) {
                                wn(p, Y, Re)
                            }
                        }
                    }
                    c = c.next
                } while (c !== v)
            }
        } catch (Re) {
            wn(a, a.return, Re)
        }
    }
    function Cy(i) {
        var a = i.updateQueue;
        if (a !== null) {
            var l = i.stateNode;
            try {
                g0(a, l)
            } catch (c) {
                wn(i, i.return, c)
            }
        }
    }
    function Dy(i, a, l) {
        l.props = Os(i.type, i.memoizedProps),
        l.state = i.memoizedState;
        try {
            l.componentWillUnmount()
        } catch (c) {
            wn(i, a, c)
        }
    }
    function rc(i, a) {
        try {
            var l = i.ref;
            if (l !== null) {
                switch (i.tag) {
                case 26:
                case 27:
                case 5:
                    var c = i.stateNode;
                    break;
                case 30:
                    c = i.stateNode;
                    break;
                default:
                    c = i.stateNode
                }
                typeof l == "function" ? i.refCleanup = l(c) : l.current = c
            }
        } catch (p) {
            wn(i, a, p)
        }
    }
    function wr(i, a) {
        var l = i.ref
          , c = i.refCleanup;
        if (l !== null)
            if (typeof c == "function")
                try {
                    c()
                } catch (p) {
                    wn(i, a, p)
                } finally {
                    i.refCleanup = null,
                    i = i.alternate,
                    i != null && (i.refCleanup = null)
                }
            else if (typeof l == "function")
                try {
                    l(null)
                } catch (p) {
                    wn(i, a, p)
                }
            else
                l.current = null
    }
    function Uy(i) {
        var a = i.type
          , l = i.memoizedProps
          , c = i.stateNode;
        try {
            e: switch (a) {
            case "button":
            case "input":
            case "select":
            case "textarea":
                l.autoFocus && c.focus();
                break e;
            case "img":
                l.src ? c.src = l.src : l.srcSet && (c.srcset = l.srcSet)
            }
        } catch (p) {
            wn(i, i.return, p)
        }
    }
    function bp(i, a, l) {
        try {
            var c = i.stateNode;
            CA(c, i.type, l, a),
            c[ze] = a
        } catch (p) {
            wn(i, i.return, p)
        }
    }
    function Ly(i) {
        return i.tag === 5 || i.tag === 3 || i.tag === 26 || i.tag === 27 && qa(i.type) || i.tag === 4
    }
    function Sp(i) {
        e: for (; ; ) {
            for (; i.sibling === null; ) {
                if (i.return === null || Ly(i.return))
                    return null;
                i = i.return
            }
            for (i.sibling.return = i.return,
            i = i.sibling; i.tag !== 5 && i.tag !== 6 && i.tag !== 18; ) {
                if (i.tag === 27 && qa(i.type) || i.flags & 2 || i.child === null || i.tag === 4)
                    continue e;
                i.child.return = i,
                i = i.child
            }
            if (!(i.flags & 2))
                return i.stateNode
        }
    }
    function Ep(i, a, l) {
        var c = i.tag;
        if (c === 5 || c === 6)
            i = i.stateNode,
            a ? (l.nodeType === 9 ? l.body : l.nodeName === "HTML" ? l.ownerDocument.body : l).insertBefore(i, a) : (a = l.nodeType === 9 ? l.body : l.nodeName === "HTML" ? l.ownerDocument.body : l,
            a.appendChild(i),
            l = l._reactRootContainer,
            l != null || a.onclick !== null || (a.onclick = fd));
        else if (c !== 4 && (c === 27 && qa(i.type) && (l = i.stateNode,
        a = null),
        i = i.child,
        i !== null))
            for (Ep(i, a, l),
            i = i.sibling; i !== null; )
                Ep(i, a, l),
                i = i.sibling
    }
    function td(i, a, l) {
        var c = i.tag;
        if (c === 5 || c === 6)
            i = i.stateNode,
            a ? l.insertBefore(i, a) : l.appendChild(i);
        else if (c !== 4 && (c === 27 && qa(i.type) && (l = i.stateNode),
        i = i.child,
        i !== null))
            for (td(i, a, l),
            i = i.sibling; i !== null; )
                td(i, a, l),
                i = i.sibling
    }
    function Ny(i) {
        var a = i.stateNode
          , l = i.memoizedProps;
        try {
            for (var c = i.type, p = a.attributes; p.length; )
                a.removeAttributeNode(p[0]);
            ui(a, c, l),
            a[Ue] = i,
            a[ze] = l
        } catch (v) {
            wn(i, i.return, v)
        }
    }
    var Jr = !1
      , Fn = !1
      , Mp = !1
      , Oy = typeof WeakSet == "function" ? WeakSet : Set
      , ii = null;
    function cA(i, a) {
        if (i = i.containerInfo,
        Yp = yd,
        i = W_(i),
        Sh(i)) {
            if ("selectionStart"in i)
                var l = {
                    start: i.selectionStart,
                    end: i.selectionEnd
                };
            else
                e: {
                    l = (l = i.ownerDocument) && l.defaultView || window;
                    var c = l.getSelection && l.getSelection();
                    if (c && c.rangeCount !== 0) {
                        l = c.anchorNode;
                        var p = c.anchorOffset
                          , v = c.focusNode;
                        c = c.focusOffset;
                        try {
                            l.nodeType,
                            v.nodeType
                        } catch {
                            l = null;
                            break e
                        }
                        var w = 0
                          , L = -1
                          , Y = -1
                          , me = 0
                          , Re = 0
                          , Pe = i
                          , ve = null;
                        t: for (; ; ) {
                            for (var be; Pe !== l || p !== 0 && Pe.nodeType !== 3 || (L = w + p),
                            Pe !== v || c !== 0 && Pe.nodeType !== 3 || (Y = w + c),
                            Pe.nodeType === 3 && (w += Pe.nodeValue.length),
                            (be = Pe.firstChild) !== null; )
                                ve = Pe,
                                Pe = be;
                            for (; ; ) {
                                if (Pe === i)
                                    break t;
                                if (ve === l && ++me === p && (L = w),
                                ve === v && ++Re === c && (Y = w),
                                (be = Pe.nextSibling) !== null)
                                    break;
                                Pe = ve,
                                ve = Pe.parentNode
                            }
                            Pe = be
                        }
                        l = L === -1 || Y === -1 ? null : {
                            start: L,
                            end: Y
                        }
                    } else
                        l = null
                }
            l = l || {
                start: 0,
                end: 0
            }
        } else
            l = null;
        for (Zp = {
            focusedElem: i,
            selectionRange: l
        },
        yd = !1,
        ii = a; ii !== null; )
            if (a = ii,
            i = a.child,
            (a.subtreeFlags & 1024) !== 0 && i !== null)
                i.return = a,
                ii = i;
            else
                for (; ii !== null; ) {
                    switch (a = ii,
                    v = a.alternate,
                    i = a.flags,
                    a.tag) {
                    case 0:
                        break;
                    case 11:
                    case 15:
                        break;
                    case 1:
                        if ((i & 1024) !== 0 && v !== null) {
                            i = void 0,
                            l = a,
                            p = v.memoizedProps,
                            v = v.memoizedState,
                            c = l.stateNode;
                            try {
                                var Nt = Os(l.type, p, l.elementType === l.type);
                                i = c.getSnapshotBeforeUpdate(Nt, v),
                                c.__reactInternalSnapshotBeforeUpdate = i
                            } catch (Ct) {
                                wn(l, l.return, Ct)
                            }
                        }
                        break;
                    case 3:
                        if ((i & 1024) !== 0) {
                            if (i = a.stateNode.containerInfo,
                            l = i.nodeType,
                            l === 9)
                                Qp(i);
                            else if (l === 1)
                                switch (i.nodeName) {
                                case "HEAD":
                                case "HTML":
                                case "BODY":
                                    Qp(i);
                                    break;
                                default:
                                    i.textContent = ""
                                }
                        }
                        break;
                    case 5:
                    case 26:
                    case 27:
                    case 6:
                    case 4:
                    case 17:
                        break;
                    default:
                        if ((i & 1024) !== 0)
                            throw Error(r(163))
                    }
                    if (i = a.sibling,
                    i !== null) {
                        i.return = a.return,
                        ii = i;
                        break
                    }
                    ii = a.return
                }
    }
    function Py(i, a, l) {
        var c = l.flags;
        switch (l.tag) {
        case 0:
        case 11:
        case 15:
            Ba(i, l),
            c & 4 && ic(5, l);
            break;
        case 1:
            if (Ba(i, l),
            c & 4)
                if (i = l.stateNode,
                a === null)
                    try {
                        i.componentDidMount()
                    } catch (w) {
                        wn(l, l.return, w)
                    }
                else {
                    var p = Os(l.type, a.memoizedProps);
                    a = a.memoizedState;
                    try {
                        i.componentDidUpdate(p, a, i.__reactInternalSnapshotBeforeUpdate)
                    } catch (w) {
                        wn(l, l.return, w)
                    }
                }
            c & 64 && Cy(l),
            c & 512 && rc(l, l.return);
            break;
        case 3:
            if (Ba(i, l),
            c & 64 && (i = l.updateQueue,
            i !== null)) {
                if (a = null,
                l.child !== null)
                    switch (l.child.tag) {
                    case 27:
                    case 5:
                        a = l.child.stateNode;
                        break;
                    case 1:
                        a = l.child.stateNode
                    }
                try {
                    g0(i, a)
                } catch (w) {
                    wn(l, l.return, w)
                }
            }
            break;
        case 27:
            a === null && c & 4 && Ny(l);
        case 26:
        case 5:
            Ba(i, l),
            a === null && c & 4 && Uy(l),
            c & 512 && rc(l, l.return);
            break;
        case 12:
            Ba(i, l);
            break;
        case 13:
            Ba(i, l),
            c & 4 && ky(i, l),
            c & 64 && (i = l.memoizedState,
            i !== null && (i = i.dehydrated,
            i !== null && (l = _A.bind(null, l),
            IA(i, l))));
            break;
        case 22:
            if (c = l.memoizedState !== null || Jr,
            !c) {
                a = a !== null && a.memoizedState !== null || Fn,
                p = Jr;
                var v = Fn;
                Jr = c,
                (Fn = a) && !v ? Va(i, l, (l.subtreeFlags & 8772) !== 0) : Ba(i, l),
                Jr = p,
                Fn = v
            }
            break;
        case 30:
            break;
        default:
            Ba(i, l)
        }
    }
    function Iy(i) {
        var a = i.alternate;
        a !== null && (i.alternate = null,
        Iy(a)),
        i.child = null,
        i.deletions = null,
        i.sibling = null,
        i.tag === 5 && (a = i.stateNode,
        a !== null && ft(a)),
        i.stateNode = null,
        i.return = null,
        i.dependencies = null,
        i.memoizedProps = null,
        i.memoizedState = null,
        i.pendingProps = null,
        i.stateNode = null,
        i.updateQueue = null
    }
    var Dn = null
      , Ci = !1;
    function ea(i, a, l) {
        for (l = l.child; l !== null; )
            zy(i, a, l),
            l = l.sibling
    }
    function zy(i, a, l) {
        if (de && typeof de.onCommitFiberUnmount == "function")
            try {
                de.onCommitFiberUnmount(J, l)
            } catch {}
        switch (l.tag) {
        case 26:
            Fn || wr(l, a),
            ea(i, a, l),
            l.memoizedState ? l.memoizedState.count-- : l.stateNode && (l = l.stateNode,
            l.parentNode.removeChild(l));
            break;
        case 27:
            Fn || wr(l, a);
            var c = Dn
              , p = Ci;
            qa(l.type) && (Dn = l.stateNode,
            Ci = !1),
            ea(i, a, l),
            hc(l.stateNode),
            Dn = c,
            Ci = p;
            break;
        case 5:
            Fn || wr(l, a);
        case 6:
            if (c = Dn,
            p = Ci,
            Dn = null,
            ea(i, a, l),
            Dn = c,
            Ci = p,
            Dn !== null)
                if (Ci)
                    try {
                        (Dn.nodeType === 9 ? Dn.body : Dn.nodeName === "HTML" ? Dn.ownerDocument.body : Dn).removeChild(l.stateNode)
                    } catch (v) {
                        wn(l, a, v)
                    }
                else
                    try {
                        Dn.removeChild(l.stateNode)
                    } catch (v) {
                        wn(l, a, v)
                    }
            break;
        case 18:
            Dn !== null && (Ci ? (i = Dn,
            wx(i.nodeType === 9 ? i.body : i.nodeName === "HTML" ? i.ownerDocument.body : i, l.stateNode),
            bc(i)) : wx(Dn, l.stateNode));
            break;
        case 4:
            c = Dn,
            p = Ci,
            Dn = l.stateNode.containerInfo,
            Ci = !0,
            ea(i, a, l),
            Dn = c,
            Ci = p;
            break;
        case 0:
        case 11:
        case 14:
        case 15:
            Fn || Fa(2, l, a),
            Fn || Fa(4, l, a),
            ea(i, a, l);
            break;
        case 1:
            Fn || (wr(l, a),
            c = l.stateNode,
            typeof c.componentWillUnmount == "function" && Dy(l, a, c)),
            ea(i, a, l);
            break;
        case 21:
            ea(i, a, l);
            break;
        case 22:
            Fn = (c = Fn) || l.memoizedState !== null,
            ea(i, a, l),
            Fn = c;
            break;
        default:
            ea(i, a, l)
        }
    }
    function ky(i, a) {
        if (a.memoizedState === null && (i = a.alternate,
        i !== null && (i = i.memoizedState,
        i !== null && (i = i.dehydrated,
        i !== null))))
            try {
                bc(i)
            } catch (l) {
                wn(a, a.return, l)
            }
    }
    function uA(i) {
        switch (i.tag) {
        case 13:
        case 19:
            var a = i.stateNode;
            return a === null && (a = i.stateNode = new Oy),
            a;
        case 22:
            return i = i.stateNode,
            a = i._retryCache,
            a === null && (a = i._retryCache = new Oy),
            a;
        default:
            throw Error(r(435, i.tag))
        }
    }
    function wp(i, a) {
        var l = uA(i);
        a.forEach(function(c) {
            var p = yA.bind(null, i, c);
            l.has(c) || (l.add(c),
            c.then(p, p))
        })
    }
    function zi(i, a) {
        var l = a.deletions;
        if (l !== null)
            for (var c = 0; c < l.length; c++) {
                var p = l[c]
                  , v = i
                  , w = a
                  , L = w;
                e: for (; L !== null; ) {
                    switch (L.tag) {
                    case 27:
                        if (qa(L.type)) {
                            Dn = L.stateNode,
                            Ci = !1;
                            break e
                        }
                        break;
                    case 5:
                        Dn = L.stateNode,
                        Ci = !1;
                        break e;
                    case 3:
                    case 4:
                        Dn = L.stateNode.containerInfo,
                        Ci = !0;
                        break e
                    }
                    L = L.return
                }
                if (Dn === null)
                    throw Error(r(160));
                zy(v, w, p),
                Dn = null,
                Ci = !1,
                v = p.alternate,
                v !== null && (v.return = null),
                p.return = null
            }
        if (a.subtreeFlags & 13878)
            for (a = a.child; a !== null; )
                Fy(a, i),
                a = a.sibling
    }
    var ur = null;
    function Fy(i, a) {
        var l = i.alternate
          , c = i.flags;
        switch (i.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
            zi(a, i),
            ki(i),
            c & 4 && (Fa(3, i, i.return),
            ic(3, i),
            Fa(5, i, i.return));
            break;
        case 1:
            zi(a, i),
            ki(i),
            c & 512 && (Fn || l === null || wr(l, l.return)),
            c & 64 && Jr && (i = i.updateQueue,
            i !== null && (c = i.callbacks,
            c !== null && (l = i.shared.hiddenCallbacks,
            i.shared.hiddenCallbacks = l === null ? c : l.concat(c))));
            break;
        case 26:
            var p = ur;
            if (zi(a, i),
            ki(i),
            c & 512 && (Fn || l === null || wr(l, l.return)),
            c & 4) {
                var v = l !== null ? l.memoizedState : null;
                if (c = i.memoizedState,
                l === null)
                    if (c === null)
                        if (i.stateNode === null) {
                            e: {
                                c = i.type,
                                l = i.memoizedProps,
                                p = p.ownerDocument || p;
                                t: switch (c) {
                                case "title":
                                    v = p.getElementsByTagName("title")[0],
                                    (!v || v[Rt] || v[Ue] || v.namespaceURI === "http://www.w3.org/2000/svg" || v.hasAttribute("itemprop")) && (v = p.createElement(c),
                                    p.head.insertBefore(v, p.querySelector("head > title"))),
                                    ui(v, c, l),
                                    v[Ue] = i,
                                    on(v),
                                    c = v;
                                    break e;
                                case "link":
                                    var w = Nx("link", "href", p).get(c + (l.href || ""));
                                    if (w) {
                                        for (var L = 0; L < w.length; L++)
                                            if (v = w[L],
                                            v.getAttribute("href") === (l.href == null || l.href === "" ? null : l.href) && v.getAttribute("rel") === (l.rel == null ? null : l.rel) && v.getAttribute("title") === (l.title == null ? null : l.title) && v.getAttribute("crossorigin") === (l.crossOrigin == null ? null : l.crossOrigin)) {
                                                w.splice(L, 1);
                                                break t
                                            }
                                    }
                                    v = p.createElement(c),
                                    ui(v, c, l),
                                    p.head.appendChild(v);
                                    break;
                                case "meta":
                                    if (w = Nx("meta", "content", p).get(c + (l.content || ""))) {
                                        for (L = 0; L < w.length; L++)
                                            if (v = w[L],
                                            v.getAttribute("content") === (l.content == null ? null : "" + l.content) && v.getAttribute("name") === (l.name == null ? null : l.name) && v.getAttribute("property") === (l.property == null ? null : l.property) && v.getAttribute("http-equiv") === (l.httpEquiv == null ? null : l.httpEquiv) && v.getAttribute("charset") === (l.charSet == null ? null : l.charSet)) {
                                                w.splice(L, 1);
                                                break t
                                            }
                                    }
                                    v = p.createElement(c),
                                    ui(v, c, l),
                                    p.head.appendChild(v);
                                    break;
                                default:
                                    throw Error(r(468, c))
                                }
                                v[Ue] = i,
                                on(v),
                                c = v
                            }
                            i.stateNode = c
                        } else
                            Ox(p, i.type, i.stateNode);
                    else
                        i.stateNode = Lx(p, c, i.memoizedProps);
                else
                    v !== c ? (v === null ? l.stateNode !== null && (l = l.stateNode,
                    l.parentNode.removeChild(l)) : v.count--,
                    c === null ? Ox(p, i.type, i.stateNode) : Lx(p, c, i.memoizedProps)) : c === null && i.stateNode !== null && bp(i, i.memoizedProps, l.memoizedProps)
            }
            break;
        case 27:
            zi(a, i),
            ki(i),
            c & 512 && (Fn || l === null || wr(l, l.return)),
            l !== null && c & 4 && bp(i, i.memoizedProps, l.memoizedProps);
            break;
        case 5:
            if (zi(a, i),
            ki(i),
            c & 512 && (Fn || l === null || wr(l, l.return)),
            i.flags & 32) {
                p = i.stateNode;
                try {
                    Sr(p, "")
                } catch (be) {
                    wn(i, i.return, be)
                }
            }
            c & 4 && i.stateNode != null && (p = i.memoizedProps,
            bp(i, p, l !== null ? l.memoizedProps : p)),
            c & 1024 && (Mp = !0);
            break;
        case 6:
            if (zi(a, i),
            ki(i),
            c & 4) {
                if (i.stateNode === null)
                    throw Error(r(162));
                c = i.memoizedProps,
                l = i.stateNode;
                try {
                    l.nodeValue = c
                } catch (be) {
                    wn(i, i.return, be)
                }
            }
            break;
        case 3:
            if (gd = null,
            p = ur,
            ur = pd(a.containerInfo),
            zi(a, i),
            ur = p,
            ki(i),
            c & 4 && l !== null && l.memoizedState.isDehydrated)
                try {
                    bc(a.containerInfo)
                } catch (be) {
                    wn(i, i.return, be)
                }
            Mp && (Mp = !1,
            By(i));
            break;
        case 4:
            c = ur,
            ur = pd(i.stateNode.containerInfo),
            zi(a, i),
            ki(i),
            ur = c;
            break;
        case 12:
            zi(a, i),
            ki(i);
            break;
        case 13:
            zi(a, i),
            ki(i),
            i.child.flags & 8192 && i.memoizedState !== null != (l !== null && l.memoizedState !== null) && (Up = it()),
            c & 4 && (c = i.updateQueue,
            c !== null && (i.updateQueue = null,
            wp(i, c)));
            break;
        case 22:
            p = i.memoizedState !== null;
            var Y = l !== null && l.memoizedState !== null
              , me = Jr
              , Re = Fn;
            if (Jr = me || p,
            Fn = Re || Y,
            zi(a, i),
            Fn = Re,
            Jr = me,
            ki(i),
            c & 8192)
                e: for (a = i.stateNode,
                a._visibility = p ? a._visibility & -2 : a._visibility | 1,
                p && (l === null || Y || Jr || Fn || Ps(i)),
                l = null,
                a = i; ; ) {
                    if (a.tag === 5 || a.tag === 26) {
                        if (l === null) {
                            Y = l = a;
                            try {
                                if (v = Y.stateNode,
                                p)
                                    w = v.style,
                                    typeof w.setProperty == "function" ? w.setProperty("display", "none", "important") : w.display = "none";
                                else {
                                    L = Y.stateNode;
                                    var Pe = Y.memoizedProps.style
                                      , ve = Pe != null && Pe.hasOwnProperty("display") ? Pe.display : null;
                                    L.style.display = ve == null || typeof ve == "boolean" ? "" : ("" + ve).trim()
                                }
                            } catch (be) {
                                wn(Y, Y.return, be)
                            }
                        }
                    } else if (a.tag === 6) {
                        if (l === null) {
                            Y = a;
                            try {
                                Y.stateNode.nodeValue = p ? "" : Y.memoizedProps
                            } catch (be) {
                                wn(Y, Y.return, be)
                            }
                        }
                    } else if ((a.tag !== 22 && a.tag !== 23 || a.memoizedState === null || a === i) && a.child !== null) {
                        a.child.return = a,
                        a = a.child;
                        continue
                    }
                    if (a === i)
                        break e;
                    for (; a.sibling === null; ) {
                        if (a.return === null || a.return === i)
                            break e;
                        l === a && (l = null),
                        a = a.return
                    }
                    l === a && (l = null),
                    a.sibling.return = a.return,
                    a = a.sibling
                }
            c & 4 && (c = i.updateQueue,
            c !== null && (l = c.retryQueue,
            l !== null && (c.retryQueue = null,
            wp(i, l))));
            break;
        case 19:
            zi(a, i),
            ki(i),
            c & 4 && (c = i.updateQueue,
            c !== null && (i.updateQueue = null,
            wp(i, c)));
            break;
        case 30:
            break;
        case 21:
            break;
        default:
            zi(a, i),
            ki(i)
        }
    }
    function ki(i) {
        var a = i.flags;
        if (a & 2) {
            try {
                for (var l, c = i.return; c !== null; ) {
                    if (Ly(c)) {
                        l = c;
                        break
                    }
                    c = c.return
                }
                if (l == null)
                    throw Error(r(160));
                switch (l.tag) {
                case 27:
                    var p = l.stateNode
                      , v = Sp(i);
                    td(i, v, p);
                    break;
                case 5:
                    var w = l.stateNode;
                    l.flags & 32 && (Sr(w, ""),
                    l.flags &= -33);
                    var L = Sp(i);
                    td(i, L, w);
                    break;
                case 3:
                case 4:
                    var Y = l.stateNode.containerInfo
                      , me = Sp(i);
                    Ep(i, me, Y);
                    break;
                default:
                    throw Error(r(161))
                }
            } catch (Re) {
                wn(i, i.return, Re)
            }
            i.flags &= -3
        }
        a & 4096 && (i.flags &= -4097)
    }
    function By(i) {
        if (i.subtreeFlags & 1024)
            for (i = i.child; i !== null; ) {
                var a = i;
                By(a),
                a.tag === 5 && a.flags & 1024 && a.stateNode.reset(),
                i = i.sibling
            }
    }
    function Ba(i, a) {
        if (a.subtreeFlags & 8772)
            for (a = a.child; a !== null; )
                Py(i, a.alternate, a),
                a = a.sibling
    }
    function Ps(i) {
        for (i = i.child; i !== null; ) {
            var a = i;
            switch (a.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
                Fa(4, a, a.return),
                Ps(a);
                break;
            case 1:
                wr(a, a.return);
                var l = a.stateNode;
                typeof l.componentWillUnmount == "function" && Dy(a, a.return, l),
                Ps(a);
                break;
            case 27:
                hc(a.stateNode);
            case 26:
            case 5:
                wr(a, a.return),
                Ps(a);
                break;
            case 22:
                a.memoizedState === null && Ps(a);
                break;
            case 30:
                Ps(a);
                break;
            default:
                Ps(a)
            }
            i = i.sibling
        }
    }
    function Va(i, a, l) {
        for (l = l && (a.subtreeFlags & 8772) !== 0,
        a = a.child; a !== null; ) {
            var c = a.alternate
              , p = i
              , v = a
              , w = v.flags;
            switch (v.tag) {
            case 0:
            case 11:
            case 15:
                Va(p, v, l),
                ic(4, v);
                break;
            case 1:
                if (Va(p, v, l),
                c = v,
                p = c.stateNode,
                typeof p.componentDidMount == "function")
                    try {
                        p.componentDidMount()
                    } catch (me) {
                        wn(c, c.return, me)
                    }
                if (c = v,
                p = c.updateQueue,
                p !== null) {
                    var L = c.stateNode;
                    try {
                        var Y = p.shared.hiddenCallbacks;
                        if (Y !== null)
                            for (p.shared.hiddenCallbacks = null,
                            p = 0; p < Y.length; p++)
                                m0(Y[p], L)
                    } catch (me) {
                        wn(c, c.return, me)
                    }
                }
                l && w & 64 && Cy(v),
                rc(v, v.return);
                break;
            case 27:
                Ny(v);
            case 26:
            case 5:
                Va(p, v, l),
                l && c === null && w & 4 && Uy(v),
                rc(v, v.return);
                break;
            case 12:
                Va(p, v, l);
                break;
            case 13:
                Va(p, v, l),
                l && w & 4 && ky(p, v);
                break;
            case 22:
                v.memoizedState === null && Va(p, v, l),
                rc(v, v.return);
                break;
            case 30:
                break;
            default:
                Va(p, v, l)
            }
            a = a.sibling
        }
    }
    function Tp(i, a) {
        var l = null;
        i !== null && i.memoizedState !== null && i.memoizedState.cachePool !== null && (l = i.memoizedState.cachePool.pool),
        i = null,
        a.memoizedState !== null && a.memoizedState.cachePool !== null && (i = a.memoizedState.cachePool.pool),
        i !== l && (i != null && i.refCount++,
        l != null && Gl(l))
    }
    function Ap(i, a) {
        i = null,
        a.alternate !== null && (i = a.alternate.memoizedState.cache),
        a = a.memoizedState.cache,
        a !== i && (a.refCount++,
        i != null && Gl(i))
    }
    function Tr(i, a, l, c) {
        if (a.subtreeFlags & 10256)
            for (a = a.child; a !== null; )
                Vy(i, a, l, c),
                a = a.sibling
    }
    function Vy(i, a, l, c) {
        var p = a.flags;
        switch (a.tag) {
        case 0:
        case 11:
        case 15:
            Tr(i, a, l, c),
            p & 2048 && ic(9, a);
            break;
        case 1:
            Tr(i, a, l, c);
            break;
        case 3:
            Tr(i, a, l, c),
            p & 2048 && (i = null,
            a.alternate !== null && (i = a.alternate.memoizedState.cache),
            a = a.memoizedState.cache,
            a !== i && (a.refCount++,
            i != null && Gl(i)));
            break;
        case 12:
            if (p & 2048) {
                Tr(i, a, l, c),
                i = a.stateNode;
                try {
                    var v = a.memoizedProps
                      , w = v.id
                      , L = v.onPostCommit;
                    typeof L == "function" && L(w, a.alternate === null ? "mount" : "update", i.passiveEffectDuration, -0)
                } catch (Y) {
                    wn(a, a.return, Y)
                }
            } else
                Tr(i, a, l, c);
            break;
        case 13:
            Tr(i, a, l, c);
            break;
        case 23:
            break;
        case 22:
            v = a.stateNode,
            w = a.alternate,
            a.memoizedState !== null ? v._visibility & 2 ? Tr(i, a, l, c) : ac(i, a) : v._visibility & 2 ? Tr(i, a, l, c) : (v._visibility |= 2,
            Ao(i, a, l, c, (a.subtreeFlags & 10256) !== 0)),
            p & 2048 && Tp(w, a);
            break;
        case 24:
            Tr(i, a, l, c),
            p & 2048 && Ap(a.alternate, a);
            break;
        default:
            Tr(i, a, l, c)
        }
    }
    function Ao(i, a, l, c, p) {
        for (p = p && (a.subtreeFlags & 10256) !== 0,
        a = a.child; a !== null; ) {
            var v = i
              , w = a
              , L = l
              , Y = c
              , me = w.flags;
            switch (w.tag) {
            case 0:
            case 11:
            case 15:
                Ao(v, w, L, Y, p),
                ic(8, w);
                break;
            case 23:
                break;
            case 22:
                var Re = w.stateNode;
                w.memoizedState !== null ? Re._visibility & 2 ? Ao(v, w, L, Y, p) : ac(v, w) : (Re._visibility |= 2,
                Ao(v, w, L, Y, p)),
                p && me & 2048 && Tp(w.alternate, w);
                break;
            case 24:
                Ao(v, w, L, Y, p),
                p && me & 2048 && Ap(w.alternate, w);
                break;
            default:
                Ao(v, w, L, Y, p)
            }
            a = a.sibling
        }
    }
    function ac(i, a) {
        if (a.subtreeFlags & 10256)
            for (a = a.child; a !== null; ) {
                var l = i
                  , c = a
                  , p = c.flags;
                switch (c.tag) {
                case 22:
                    ac(l, c),
                    p & 2048 && Tp(c.alternate, c);
                    break;
                case 24:
                    ac(l, c),
                    p & 2048 && Ap(c.alternate, c);
                    break;
                default:
                    ac(l, c)
                }
                a = a.sibling
            }
    }
    var sc = 8192;
    function Ro(i) {
        if (i.subtreeFlags & sc)
            for (i = i.child; i !== null; )
                Hy(i),
                i = i.sibling
    }
    function Hy(i) {
        switch (i.tag) {
        case 26:
            Ro(i),
            i.flags & sc && i.memoizedState !== null && ZA(ur, i.memoizedState, i.memoizedProps);
            break;
        case 5:
            Ro(i);
            break;
        case 3:
        case 4:
            var a = ur;
            ur = pd(i.stateNode.containerInfo),
            Ro(i),
            ur = a;
            break;
        case 22:
            i.memoizedState === null && (a = i.alternate,
            a !== null && a.memoizedState !== null ? (a = sc,
            sc = 16777216,
            Ro(i),
            sc = a) : Ro(i));
            break;
        default:
            Ro(i)
        }
    }
    function Gy(i) {
        var a = i.alternate;
        if (a !== null && (i = a.child,
        i !== null)) {
            a.child = null;
            do
                a = i.sibling,
                i.sibling = null,
                i = a;
            while (i !== null)
        }
    }
    function oc(i) {
        var a = i.deletions;
        if ((i.flags & 16) !== 0) {
            if (a !== null)
                for (var l = 0; l < a.length; l++) {
                    var c = a[l];
                    ii = c,
                    Wy(c, i)
                }
            Gy(i)
        }
        if (i.subtreeFlags & 10256)
            for (i = i.child; i !== null; )
                jy(i),
                i = i.sibling
    }
    function jy(i) {
        switch (i.tag) {
        case 0:
        case 11:
        case 15:
            oc(i),
            i.flags & 2048 && Fa(9, i, i.return);
            break;
        case 3:
            oc(i);
            break;
        case 12:
            oc(i);
            break;
        case 22:
            var a = i.stateNode;
            i.memoizedState !== null && a._visibility & 2 && (i.return === null || i.return.tag !== 13) ? (a._visibility &= -3,
            nd(i)) : oc(i);
            break;
        default:
            oc(i)
        }
    }
    function nd(i) {
        var a = i.deletions;
        if ((i.flags & 16) !== 0) {
            if (a !== null)
                for (var l = 0; l < a.length; l++) {
                    var c = a[l];
                    ii = c,
                    Wy(c, i)
                }
            Gy(i)
        }
        for (i = i.child; i !== null; ) {
            switch (a = i,
            a.tag) {
            case 0:
            case 11:
            case 15:
                Fa(8, a, a.return),
                nd(a);
                break;
            case 22:
                l = a.stateNode,
                l._visibility & 2 && (l._visibility &= -3,
                nd(a));
                break;
            default:
                nd(a)
            }
            i = i.sibling
        }
    }
    function Wy(i, a) {
        for (; ii !== null; ) {
            var l = ii;
            switch (l.tag) {
            case 0:
            case 11:
            case 15:
                Fa(8, l, a);
                break;
            case 23:
            case 22:
                if (l.memoizedState !== null && l.memoizedState.cachePool !== null) {
                    var c = l.memoizedState.cachePool.pool;
                    c != null && c.refCount++
                }
                break;
            case 24:
                Gl(l.memoizedState.cache)
            }
            if (c = l.child,
            c !== null)
                c.return = l,
                ii = c;
            else
                e: for (l = i; ii !== null; ) {
                    c = ii;
                    var p = c.sibling
                      , v = c.return;
                    if (Iy(c),
                    c === l) {
                        ii = null;
                        break e
                    }
                    if (p !== null) {
                        p.return = v,
                        ii = p;
                        break e
                    }
                    ii = v
                }
        }
    }
    var dA = {
        getCacheForType: function(i) {
            var a = mi(Yn)
              , l = a.data.get(i);
            return l === void 0 && (l = i(),
            a.data.set(i, l)),
            l
        }
    }
      , fA = typeof WeakMap == "function" ? WeakMap : Map
      , gn = 0
      , Rn = null
      , Qt = null
      , ln = 0
      , vn = 0
      , Fi = null
      , Ha = !1
      , Co = !1
      , Rp = !1
      , ta = 0
      , Pn = 0
      , Ga = 0
      , Is = 0
      , Cp = 0
      , Ji = 0
      , Do = 0
      , lc = null
      , Di = null
      , Dp = !1
      , Up = 0
      , id = 1 / 0
      , rd = null
      , ja = null
      , ci = 0
      , Wa = null
      , Uo = null
      , Lo = 0
      , Lp = 0
      , Np = null
      , Xy = null
      , cc = 0
      , Op = null;
    function Bi() {
        if ((gn & 2) !== 0 && ln !== 0)
            return ln & -ln;
        if (O.T !== null) {
            var i = yo;
            return i !== 0 ? i : Vp()
        }
        return j()
    }
    function qy() {
        Ji === 0 && (Ji = (ln & 536870912) === 0 || hn ? re() : 536870912);
        var i = Qi.current;
        return i !== null && (i.flags |= 32),
        Ji
    }
    function Vi(i, a, l) {
        (i === Rn && (vn === 2 || vn === 9) || i.cancelPendingCommit !== null) && (No(i, 0),
        Xa(i, ln, Ji, !1)),
        Ne(i, l),
        ((gn & 2) === 0 || i !== Rn) && (i === Rn && ((gn & 2) === 0 && (Is |= l),
        Pn === 4 && Xa(i, ln, Ji, !1)),
        Ar(i))
    }
    function Yy(i, a, l) {
        if ((gn & 6) !== 0)
            throw Error(r(327));
        var c = !l && (a & 124) === 0 && (a & i.expiredLanes) === 0 || Tt(i, a)
          , p = c ? mA(i, a) : zp(i, a, !0)
          , v = c;
        do {
            if (p === 0) {
                Co && !c && Xa(i, a, 0, !1);
                break
            } else {
                if (l = i.current.alternate,
                v && !hA(l)) {
                    p = zp(i, a, !1),
                    v = !1;
                    continue
                }
                if (p === 2) {
                    if (v = a,
                    i.errorRecoveryDisabledLanes & v)
                        var w = 0;
                    else
                        w = i.pendingLanes & -536870913,
                        w = w !== 0 ? w : w & 536870912 ? 536870912 : 0;
                    if (w !== 0) {
                        a = w;
                        e: {
                            var L = i;
                            p = lc;
                            var Y = L.current.memoizedState.isDehydrated;
                            if (Y && (No(L, w).flags |= 256),
                            w = zp(L, w, !1),
                            w !== 2) {
                                if (Rp && !Y) {
                                    L.errorRecoveryDisabledLanes |= v,
                                    Is |= v,
                                    p = 4;
                                    break e
                                }
                                v = Di,
                                Di = p,
                                v !== null && (Di === null ? Di = v : Di.push.apply(Di, v))
                            }
                            p = w
                        }
                        if (v = !1,
                        p !== 2)
                            continue
                    }
                }
                if (p === 1) {
                    No(i, 0),
                    Xa(i, a, 0, !0);
                    break
                }
                e: {
                    switch (c = i,
                    v = p,
                    v) {
                    case 0:
                    case 1:
                        throw Error(r(345));
                    case 4:
                        if ((a & 4194048) !== a)
                            break;
                    case 6:
                        Xa(c, a, Ji, !Ha);
                        break e;
                    case 2:
                        Di = null;
                        break;
                    case 3:
                    case 5:
                        break;
                    default:
                        throw Error(r(329))
                    }
                    if ((a & 62914560) === a && (p = Up + 300 - it(),
                    10 < p)) {
                        if (Xa(c, a, Ji, !Ha),
                        Lt(c, 0, !0) !== 0)
                            break e;
                        c.timeoutHandle = Ex(Zy.bind(null, c, l, Di, rd, Dp, a, Ji, Is, Do, Ha, v, 2, -0, 0), p);
                        break e
                    }
                    Zy(c, l, Di, rd, Dp, a, Ji, Is, Do, Ha, v, 0, -0, 0)
                }
            }
            break
        } while (!0);
        Ar(i)
    }
    function Zy(i, a, l, c, p, v, w, L, Y, me, Re, Pe, ve, be) {
        if (i.timeoutHandle = -1,
        Pe = a.subtreeFlags,
        (Pe & 8192 || (Pe & 16785408) === 16785408) && (gc = {
            stylesheets: null,
            count: 0,
            unsuspend: YA
        },
        Hy(a),
        Pe = $A(),
        Pe !== null)) {
            i.cancelPendingCommit = Pe(nx.bind(null, i, a, v, l, c, p, w, L, Y, Re, 1, ve, be)),
            Xa(i, v, w, !me);
            return
        }
        nx(i, a, v, l, c, p, w, L, Y)
    }
    function hA(i) {
        for (var a = i; ; ) {
            var l = a.tag;
            if ((l === 0 || l === 11 || l === 15) && a.flags & 16384 && (l = a.updateQueue,
            l !== null && (l = l.stores,
            l !== null)))
                for (var c = 0; c < l.length; c++) {
                    var p = l[c]
                      , v = p.getSnapshot;
                    p = p.value;
                    try {
                        if (!Pi(v(), p))
                            return !1
                    } catch {
                        return !1
                    }
                }
            if (l = a.child,
            a.subtreeFlags & 16384 && l !== null)
                l.return = a,
                a = l;
            else {
                if (a === i)
                    break;
                for (; a.sibling === null; ) {
                    if (a.return === null || a.return === i)
                        return !0;
                    a = a.return
                }
                a.sibling.return = a.return,
                a = a.sibling
            }
        }
        return !0
    }
    function Xa(i, a, l, c) {
        a &= ~Cp,
        a &= ~Is,
        i.suspendedLanes |= a,
        i.pingedLanes &= ~a,
        c && (i.warmLanes |= a),
        c = i.expirationTimes;
        for (var p = a; 0 < p; ) {
            var v = 31 - Ae(p)
              , w = 1 << v;
            c[v] = -1,
            p &= ~w
        }
        l !== 0 && Ce(i, l, a)
    }
    function ad() {
        return (gn & 6) === 0 ? (uc(0),
        !1) : !0
    }
    function Pp() {
        if (Qt !== null) {
            if (vn === 0)
                var i = Qt.return;
            else
                i = Qt,
                qr = Ds = null,
                Qh(i),
                wo = null,
                ec = 0,
                i = Qt;
            for (; i !== null; )
                Ry(i.alternate, i),
                i = i.return;
            Qt = null
        }
    }
    function No(i, a) {
        var l = i.timeoutHandle;
        l !== -1 && (i.timeoutHandle = -1,
        UA(l)),
        l = i.cancelPendingCommit,
        l !== null && (i.cancelPendingCommit = null,
        l()),
        Pp(),
        Rn = i,
        Qt = l = jr(i.current, null),
        ln = a,
        vn = 0,
        Fi = null,
        Ha = !1,
        Co = Tt(i, a),
        Rp = !1,
        Do = Ji = Cp = Is = Ga = Pn = 0,
        Di = lc = null,
        Dp = !1,
        (a & 8) !== 0 && (a |= a & 32);
        var c = i.entangledLanes;
        if (c !== 0)
            for (i = i.entanglements,
            c &= a; 0 < c; ) {
                var p = 31 - Ae(c)
                  , v = 1 << p;
                a |= i[p],
                c &= ~v
            }
        return ta = a,
        Au(),
        l
    }
    function $y(i, a) {
        Wt = null,
        O.H = Xu,
        a === Wl || a === Iu ? (a = h0(),
        vn = 3) : a === u0 ? (a = h0(),
        vn = 4) : vn = a === py ? 8 : a !== null && typeof a == "object" && typeof a.then == "function" ? 6 : 1,
        Fi = a,
        Qt === null && (Pn = 1,
        Ku(i, Yi(a, i.current)))
    }
    function Ky() {
        var i = O.H;
        return O.H = Xu,
        i === null ? Xu : i
    }
    function Qy() {
        var i = O.A;
        return O.A = dA,
        i
    }
    function Ip() {
        Pn = 4,
        Ha || (ln & 4194048) !== ln && Qi.current !== null || (Co = !0),
        (Ga & 134217727) === 0 && (Is & 134217727) === 0 || Rn === null || Xa(Rn, ln, Ji, !1)
    }
    function zp(i, a, l) {
        var c = gn;
        gn |= 2;
        var p = Ky()
          , v = Qy();
        (Rn !== i || ln !== a) && (rd = null,
        No(i, a)),
        a = !1;
        var w = Pn;
        e: do
            try {
                if (vn !== 0 && Qt !== null) {
                    var L = Qt
                      , Y = Fi;
                    switch (vn) {
                    case 8:
                        Pp(),
                        w = 6;
                        break e;
                    case 3:
                    case 2:
                    case 9:
                    case 6:
                        Qi.current === null && (a = !0);
                        var me = vn;
                        if (vn = 0,
                        Fi = null,
                        Oo(i, L, Y, me),
                        l && Co) {
                            w = 0;
                            break e
                        }
                        break;
                    default:
                        me = vn,
                        vn = 0,
                        Fi = null,
                        Oo(i, L, Y, me)
                    }
                }
                pA(),
                w = Pn;
                break
            } catch (Re) {
                $y(i, Re)
            }
        while (!0);
        return a && i.shellSuspendCounter++,
        qr = Ds = null,
        gn = c,
        O.H = p,
        O.A = v,
        Qt === null && (Rn = null,
        ln = 0,
        Au()),
        w
    }
    function pA() {
        for (; Qt !== null; )
            Jy(Qt)
    }
    function mA(i, a) {
        var l = gn;
        gn |= 2;
        var c = Ky()
          , p = Qy();
        Rn !== i || ln !== a ? (rd = null,
        id = it() + 500,
        No(i, a)) : Co = Tt(i, a);
        e: do
            try {
                if (vn !== 0 && Qt !== null) {
                    a = Qt;
                    var v = Fi;
                    t: switch (vn) {
                    case 1:
                        vn = 0,
                        Fi = null,
                        Oo(i, a, v, 1);
                        break;
                    case 2:
                    case 9:
                        if (d0(v)) {
                            vn = 0,
                            Fi = null,
                            ex(a);
                            break
                        }
                        a = function() {
                            vn !== 2 && vn !== 9 || Rn !== i || (vn = 7),
                            Ar(i)
                        }
                        ,
                        v.then(a, a);
                        break e;
                    case 3:
                        vn = 7;
                        break e;
                    case 4:
                        vn = 5;
                        break e;
                    case 7:
                        d0(v) ? (vn = 0,
                        Fi = null,
                        ex(a)) : (vn = 0,
                        Fi = null,
                        Oo(i, a, v, 7));
                        break;
                    case 5:
                        var w = null;
                        switch (Qt.tag) {
                        case 26:
                            w = Qt.memoizedState;
                        case 5:
                        case 27:
                            var L = Qt;
                            if (!w || Px(w)) {
                                vn = 0,
                                Fi = null;
                                var Y = L.sibling;
                                if (Y !== null)
                                    Qt = Y;
                                else {
                                    var me = L.return;
                                    me !== null ? (Qt = me,
                                    sd(me)) : Qt = null
                                }
                                break t
                            }
                        }
                        vn = 0,
                        Fi = null,
                        Oo(i, a, v, 5);
                        break;
                    case 6:
                        vn = 0,
                        Fi = null,
                        Oo(i, a, v, 6);
                        break;
                    case 8:
                        Pp(),
                        Pn = 6;
                        break e;
                    default:
                        throw Error(r(462))
                    }
                }
                gA();
                break
            } catch (Re) {
                $y(i, Re)
            }
        while (!0);
        return qr = Ds = null,
        O.H = c,
        O.A = p,
        gn = l,
        Qt !== null ? 0 : (Rn = null,
        ln = 0,
        Au(),
        Pn)
    }
    function gA() {
        for (; Qt !== null && !Zt(); )
            Jy(Qt)
    }
    function Jy(i) {
        var a = Ty(i.alternate, i, ta);
        i.memoizedProps = i.pendingProps,
        a === null ? sd(i) : Qt = a
    }
    function ex(i) {
        var a = i
          , l = a.alternate;
        switch (a.tag) {
        case 15:
        case 0:
            a = xy(l, a, a.pendingProps, a.type, void 0, ln);
            break;
        case 11:
            a = xy(l, a, a.pendingProps, a.type.render, a.ref, ln);
            break;
        case 5:
            Qh(a);
        default:
            Ry(l, a),
            a = Qt = t0(a, ta),
            a = Ty(l, a, ta)
        }
        i.memoizedProps = i.pendingProps,
        a === null ? sd(i) : Qt = a
    }
    function Oo(i, a, l, c) {
        qr = Ds = null,
        Qh(a),
        wo = null,
        ec = 0;
        var p = a.return;
        try {
            if (aA(i, p, a, l, ln)) {
                Pn = 1,
                Ku(i, Yi(l, i.current)),
                Qt = null;
                return
            }
        } catch (v) {
            if (p !== null)
                throw Qt = p,
                v;
            Pn = 1,
            Ku(i, Yi(l, i.current)),
            Qt = null;
            return
        }
        a.flags & 32768 ? (hn || c === 1 ? i = !0 : Co || (ln & 536870912) !== 0 ? i = !1 : (Ha = i = !0,
        (c === 2 || c === 9 || c === 3 || c === 6) && (c = Qi.current,
        c !== null && c.tag === 13 && (c.flags |= 16384))),
        tx(a, i)) : sd(a)
    }
    function sd(i) {
        var a = i;
        do {
            if ((a.flags & 32768) !== 0) {
                tx(a, Ha);
                return
            }
            i = a.return;
            var l = oA(a.alternate, a, ta);
            if (l !== null) {
                Qt = l;
                return
            }
            if (a = a.sibling,
            a !== null) {
                Qt = a;
                return
            }
            Qt = a = i
        } while (a !== null);
        Pn === 0 && (Pn = 5)
    }
    function tx(i, a) {
        do {
            var l = lA(i.alternate, i);
            if (l !== null) {
                l.flags &= 32767,
                Qt = l;
                return
            }
            if (l = i.return,
            l !== null && (l.flags |= 32768,
            l.subtreeFlags = 0,
            l.deletions = null),
            !a && (i = i.sibling,
            i !== null)) {
                Qt = i;
                return
            }
            Qt = i = l
        } while (i !== null);
        Pn = 6,
        Qt = null
    }
    function nx(i, a, l, c, p, v, w, L, Y) {
        i.cancelPendingCommit = null;
        do
            od();
        while (ci !== 0);
        if ((gn & 6) !== 0)
            throw Error(r(327));
        if (a !== null) {
            if (a === i.current)
                throw Error(r(177));
            if (v = a.lanes | a.childLanes,
            v |= Ah,
            Ke(i, l, v, w, L, Y),
            i === Rn && (Qt = Rn = null,
            ln = 0),
            Uo = a,
            Wa = i,
            Lo = l,
            Lp = v,
            Np = p,
            Xy = c,
            (a.subtreeFlags & 10256) !== 0 || (a.flags & 10256) !== 0 ? (i.callbackNode = null,
            i.callbackPriority = 0,
            xA(B, function() {
                return ox(),
                null
            })) : (i.callbackNode = null,
            i.callbackPriority = 0),
            c = (a.flags & 13878) !== 0,
            (a.subtreeFlags & 13878) !== 0 || c) {
                c = O.T,
                O.T = null,
                p = W.p,
                W.p = 2,
                w = gn,
                gn |= 4;
                try {
                    cA(i, a, l)
                } finally {
                    gn = w,
                    W.p = p,
                    O.T = c
                }
            }
            ci = 1,
            ix(),
            rx(),
            ax()
        }
    }
    function ix() {
        if (ci === 1) {
            ci = 0;
            var i = Wa
              , a = Uo
              , l = (a.flags & 13878) !== 0;
            if ((a.subtreeFlags & 13878) !== 0 || l) {
                l = O.T,
                O.T = null;
                var c = W.p;
                W.p = 2;
                var p = gn;
                gn |= 4;
                try {
                    Fy(a, i);
                    var v = Zp
                      , w = W_(i.containerInfo)
                      , L = v.focusedElem
                      , Y = v.selectionRange;
                    if (w !== L && L && L.ownerDocument && j_(L.ownerDocument.documentElement, L)) {
                        if (Y !== null && Sh(L)) {
                            var me = Y.start
                              , Re = Y.end;
                            if (Re === void 0 && (Re = me),
                            "selectionStart"in L)
                                L.selectionStart = me,
                                L.selectionEnd = Math.min(Re, L.value.length);
                            else {
                                var Pe = L.ownerDocument || document
                                  , ve = Pe && Pe.defaultView || window;
                                if (ve.getSelection) {
                                    var be = ve.getSelection()
                                      , Nt = L.textContent.length
                                      , Ct = Math.min(Y.start, Nt)
                                      , bn = Y.end === void 0 ? Ct : Math.min(Y.end, Nt);
                                    !be.extend && Ct > bn && (w = bn,
                                    bn = Ct,
                                    Ct = w);
                                    var ce = G_(L, Ct)
                                      , ne = G_(L, bn);
                                    if (ce && ne && (be.rangeCount !== 1 || be.anchorNode !== ce.node || be.anchorOffset !== ce.offset || be.focusNode !== ne.node || be.focusOffset !== ne.offset)) {
                                        var he = Pe.createRange();
                                        he.setStart(ce.node, ce.offset),
                                        be.removeAllRanges(),
                                        Ct > bn ? (be.addRange(he),
                                        be.extend(ne.node, ne.offset)) : (he.setEnd(ne.node, ne.offset),
                                        be.addRange(he))
                                    }
                                }
                            }
                        }
                        for (Pe = [],
                        be = L; be = be.parentNode; )
                            be.nodeType === 1 && Pe.push({
                                element: be,
                                left: be.scrollLeft,
                                top: be.scrollTop
                            });
                        for (typeof L.focus == "function" && L.focus(),
                        L = 0; L < Pe.length; L++) {
                            var Oe = Pe[L];
                            Oe.element.scrollLeft = Oe.left,
                            Oe.element.scrollTop = Oe.top
                        }
                    }
                    yd = !!Yp,
                    Zp = Yp = null
                } finally {
                    gn = p,
                    W.p = c,
                    O.T = l
                }
            }
            i.current = a,
            ci = 2
        }
    }
    function rx() {
        if (ci === 2) {
            ci = 0;
            var i = Wa
              , a = Uo
              , l = (a.flags & 8772) !== 0;
            if ((a.subtreeFlags & 8772) !== 0 || l) {
                l = O.T,
                O.T = null;
                var c = W.p;
                W.p = 2;
                var p = gn;
                gn |= 4;
                try {
                    Py(i, a.alternate, a)
                } finally {
                    gn = p,
                    W.p = c,
                    O.T = l
                }
            }
            ci = 3
        }
    }
    function ax() {
        if (ci === 4 || ci === 3) {
            ci = 0,
            ot();
            var i = Wa
              , a = Uo
              , l = Lo
              , c = Xy;
            (a.subtreeFlags & 10256) !== 0 || (a.flags & 10256) !== 0 ? ci = 5 : (ci = 0,
            Uo = Wa = null,
            sx(i, i.pendingLanes));
            var p = i.pendingLanes;
            if (p === 0 && (ja = null),
            nn(l),
            a = a.stateNode,
            de && typeof de.onCommitFiberRoot == "function")
                try {
                    de.onCommitFiberRoot(J, a, void 0, (a.current.flags & 128) === 128)
                } catch {}
            if (c !== null) {
                a = O.T,
                p = W.p,
                W.p = 2,
                O.T = null;
                try {
                    for (var v = i.onRecoverableError, w = 0; w < c.length; w++) {
                        var L = c[w];
                        v(L.value, {
                            componentStack: L.stack
                        })
                    }
                } finally {
                    O.T = a,
                    W.p = p
                }
            }
            (Lo & 3) !== 0 && od(),
            Ar(i),
            p = i.pendingLanes,
            (l & 4194090) !== 0 && (p & 42) !== 0 ? i === Op ? cc++ : (cc = 0,
            Op = i) : cc = 0,
            uc(0)
        }
    }
    function sx(i, a) {
        (i.pooledCacheLanes &= a) === 0 && (a = i.pooledCache,
        a != null && (i.pooledCache = null,
        Gl(a)))
    }
    function od(i) {
        return ix(),
        rx(),
        ax(),
        ox()
    }
    function ox() {
        if (ci !== 5)
            return !1;
        var i = Wa
          , a = Lp;
        Lp = 0;
        var l = nn(Lo)
          , c = O.T
          , p = W.p;
        try {
            W.p = 32 > l ? 32 : l,
            O.T = null,
            l = Np,
            Np = null;
            var v = Wa
              , w = Lo;
            if (ci = 0,
            Uo = Wa = null,
            Lo = 0,
            (gn & 6) !== 0)
                throw Error(r(331));
            var L = gn;
            if (gn |= 4,
            jy(v.current),
            Vy(v, v.current, w, l),
            gn = L,
            uc(0, !1),
            de && typeof de.onPostCommitFiberRoot == "function")
                try {
                    de.onPostCommitFiberRoot(J, v)
                } catch {}
            return !0
        } finally {
            W.p = p,
            O.T = c,
            sx(i, a)
        }
    }
    function lx(i, a, l) {
        a = Yi(l, a),
        a = fp(i.stateNode, a, 2),
        i = Pa(i, a, 2),
        i !== null && (Ne(i, 2),
        Ar(i))
    }
    function wn(i, a, l) {
        if (i.tag === 3)
            lx(i, i, l);
        else
            for (; a !== null; ) {
                if (a.tag === 3) {
                    lx(a, i, l);
                    break
                } else if (a.tag === 1) {
                    var c = a.stateNode;
                    if (typeof a.type.getDerivedStateFromError == "function" || typeof c.componentDidCatch == "function" && (ja === null || !ja.has(c))) {
                        i = Yi(l, i),
                        l = fy(2),
                        c = Pa(a, l, 2),
                        c !== null && (hy(l, c, a, i),
                        Ne(c, 2),
                        Ar(c));
                        break
                    }
                }
                a = a.return
            }
    }
    function kp(i, a, l) {
        var c = i.pingCache;
        if (c === null) {
            c = i.pingCache = new fA;
            var p = new Set;
            c.set(a, p)
        } else
            p = c.get(a),
            p === void 0 && (p = new Set,
            c.set(a, p));
        p.has(l) || (Rp = !0,
        p.add(l),
        i = vA.bind(null, i, a, l),
        a.then(i, i))
    }
    function vA(i, a, l) {
        var c = i.pingCache;
        c !== null && c.delete(a),
        i.pingedLanes |= i.suspendedLanes & l,
        i.warmLanes &= ~l,
        Rn === i && (ln & l) === l && (Pn === 4 || Pn === 3 && (ln & 62914560) === ln && 300 > it() - Up ? (gn & 2) === 0 && No(i, 0) : Cp |= l,
        Do === ln && (Do = 0)),
        Ar(i)
    }
    function cx(i, a) {
        a === 0 && (a = Ye()),
        i = mo(i, a),
        i !== null && (Ne(i, a),
        Ar(i))
    }
    function _A(i) {
        var a = i.memoizedState
          , l = 0;
        a !== null && (l = a.retryLane),
        cx(i, l)
    }
    function yA(i, a) {
        var l = 0;
        switch (i.tag) {
        case 13:
            var c = i.stateNode
              , p = i.memoizedState;
            p !== null && (l = p.retryLane);
            break;
        case 19:
            c = i.stateNode;
            break;
        case 22:
            c = i.stateNode._retryCache;
            break;
        default:
            throw Error(r(314))
        }
        c !== null && c.delete(a),
        cx(i, l)
    }
    function xA(i, a) {
        return nt(i, a)
    }
    var ld = null
      , Po = null
      , Fp = !1
      , cd = !1
      , Bp = !1
      , zs = 0;
    function Ar(i) {
        i !== Po && i.next === null && (Po === null ? ld = Po = i : Po = Po.next = i),
        cd = !0,
        Fp || (Fp = !0,
        SA())
    }
    function uc(i, a) {
        if (!Bp && cd) {
            Bp = !0;
            do
                for (var l = !1, c = ld; c !== null; ) {
                    if (i !== 0) {
                        var p = c.pendingLanes;
                        if (p === 0)
                            var v = 0;
                        else {
                            var w = c.suspendedLanes
                              , L = c.pingedLanes;
                            v = (1 << 31 - Ae(42 | i) + 1) - 1,
                            v &= p & ~(w & ~L),
                            v = v & 201326741 ? v & 201326741 | 1 : v ? v | 2 : 0
                        }
                        v !== 0 && (l = !0,
                        hx(c, v))
                    } else
                        v = ln,
                        v = Lt(c, c === Rn ? v : 0, c.cancelPendingCommit !== null || c.timeoutHandle !== -1),
                        (v & 3) === 0 || Tt(c, v) || (l = !0,
                        hx(c, v));
                    c = c.next
                }
            while (l);
            Bp = !1
        }
    }
    function bA() {
        ux()
    }
    function ux() {
        cd = Fp = !1;
        var i = 0;
        zs !== 0 && (DA() && (i = zs),
        zs = 0);
        for (var a = it(), l = null, c = ld; c !== null; ) {
            var p = c.next
              , v = dx(c, a);
            v === 0 ? (c.next = null,
            l === null ? ld = p : l.next = p,
            p === null && (Po = l)) : (l = c,
            (i !== 0 || (v & 3) !== 0) && (cd = !0)),
            c = p
        }
        uc(i)
    }
    function dx(i, a) {
        for (var l = i.suspendedLanes, c = i.pingedLanes, p = i.expirationTimes, v = i.pendingLanes & -62914561; 0 < v; ) {
            var w = 31 - Ae(v)
              , L = 1 << w
              , Y = p[w];
            Y === -1 ? ((L & l) === 0 || (L & c) !== 0) && (p[w] = qt(L, a)) : Y <= a && (i.expiredLanes |= L),
            v &= ~L
        }
        if (a = Rn,
        l = ln,
        l = Lt(i, i === a ? l : 0, i.cancelPendingCommit !== null || i.timeoutHandle !== -1),
        c = i.callbackNode,
        l === 0 || i === a && (vn === 2 || vn === 9) || i.cancelPendingCommit !== null)
            return c !== null && c !== null && G(c),
            i.callbackNode = null,
            i.callbackPriority = 0;
        if ((l & 3) === 0 || Tt(i, l)) {
            if (a = l & -l,
            a === i.callbackPriority)
                return a;
            switch (c !== null && G(c),
            nn(l)) {
            case 2:
            case 8:
                l = Xe;
                break;
            case 32:
                l = B;
                break;
            case 268435456:
                l = I;
                break;
            default:
                l = B
            }
            return c = fx.bind(null, i),
            l = nt(l, c),
            i.callbackPriority = a,
            i.callbackNode = l,
            a
        }
        return c !== null && c !== null && G(c),
        i.callbackPriority = 2,
        i.callbackNode = null,
        2
    }
    function fx(i, a) {
        if (ci !== 0 && ci !== 5)
            return i.callbackNode = null,
            i.callbackPriority = 0,
            null;
        var l = i.callbackNode;
        if (od() && i.callbackNode !== l)
            return null;
        var c = ln;
        return c = Lt(i, i === Rn ? c : 0, i.cancelPendingCommit !== null || i.timeoutHandle !== -1),
        c === 0 ? null : (Yy(i, c, a),
        dx(i, it()),
        i.callbackNode != null && i.callbackNode === l ? fx.bind(null, i) : null)
    }
    function hx(i, a) {
        if (od())
            return null;
        Yy(i, a, !0)
    }
    function SA() {
        LA(function() {
            (gn & 6) !== 0 ? nt(pt, bA) : ux()
        })
    }
    function Vp() {
        return zs === 0 && (zs = re()),
        zs
    }
    function px(i) {
        return i == null || typeof i == "symbol" || typeof i == "boolean" ? null : typeof i == "function" ? i : xu("" + i)
    }
    function mx(i, a) {
        var l = a.ownerDocument.createElement("input");
        return l.name = a.name,
        l.value = a.value,
        i.id && l.setAttribute("form", i.id),
        a.parentNode.insertBefore(l, a),
        i = new FormData(i),
        l.parentNode.removeChild(l),
        i
    }
    function EA(i, a, l, c, p) {
        if (a === "submit" && l && l.stateNode === p) {
            var v = px((p[ze] || null).action)
              , w = c.submitter;
            w && (a = (a = w[ze] || null) ? px(a.formAction) : w.getAttribute("formAction"),
            a !== null && (v = a,
            w = null));
            var L = new Mu("action","action",null,c,p);
            i.push({
                event: L,
                listeners: [{
                    instance: null,
                    listener: function() {
                        if (c.defaultPrevented) {
                            if (zs !== 0) {
                                var Y = w ? mx(p, w) : new FormData(p);
                                op(l, {
                                    pending: !0,
                                    data: Y,
                                    method: p.method,
                                    action: v
                                }, null, Y)
                            }
                        } else
                            typeof v == "function" && (L.preventDefault(),
                            Y = w ? mx(p, w) : new FormData(p),
                            op(l, {
                                pending: !0,
                                data: Y,
                                method: p.method,
                                action: v
                            }, v, Y))
                    },
                    currentTarget: p
                }]
            })
        }
    }
    for (var Hp = 0; Hp < Th.length; Hp++) {
        var Gp = Th[Hp]
          , MA = Gp.toLowerCase()
          , wA = Gp[0].toUpperCase() + Gp.slice(1);
        cr(MA, "on" + wA)
    }
    cr(Y_, "onAnimationEnd"),
    cr(Z_, "onAnimationIteration"),
    cr($_, "onAnimationStart"),
    cr("dblclick", "onDoubleClick"),
    cr("focusin", "onFocus"),
    cr("focusout", "onBlur"),
    cr(HT, "onTransitionRun"),
    cr(GT, "onTransitionStart"),
    cr(jT, "onTransitionCancel"),
    cr(K_, "onTransitionEnd"),
    N("onMouseEnter", ["mouseout", "mouseover"]),
    N("onMouseLeave", ["mouseout", "mouseover"]),
    N("onPointerEnter", ["pointerout", "pointerover"]),
    N("onPointerLeave", ["pointerout", "pointerover"]),
    si("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")),
    si("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),
    si("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
    si("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")),
    si("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")),
    si("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var dc = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
      , TA = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(dc));
    function gx(i, a) {
        a = (a & 4) !== 0;
        for (var l = 0; l < i.length; l++) {
            var c = i[l]
              , p = c.event;
            c = c.listeners;
            e: {
                var v = void 0;
                if (a)
                    for (var w = c.length - 1; 0 <= w; w--) {
                        var L = c[w]
                          , Y = L.instance
                          , me = L.currentTarget;
                        if (L = L.listener,
                        Y !== v && p.isPropagationStopped())
                            break e;
                        v = L,
                        p.currentTarget = me;
                        try {
                            v(p)
                        } catch (Re) {
                            $u(Re)
                        }
                        p.currentTarget = null,
                        v = Y
                    }
                else
                    for (w = 0; w < c.length; w++) {
                        if (L = c[w],
                        Y = L.instance,
                        me = L.currentTarget,
                        L = L.listener,
                        Y !== v && p.isPropagationStopped())
                            break e;
                        v = L,
                        p.currentTarget = me;
                        try {
                            v(p)
                        } catch (Re) {
                            $u(Re)
                        }
                        p.currentTarget = null,
                        v = Y
                    }
            }
        }
    }
    function Jt(i, a) {
        var l = a[bt];
        l === void 0 && (l = a[bt] = new Set);
        var c = i + "__bubble";
        l.has(c) || (vx(a, i, 2, !1),
        l.add(c))
    }
    function jp(i, a, l) {
        var c = 0;
        a && (c |= 4),
        vx(l, i, c, a)
    }
    var ud = "_reactListening" + Math.random().toString(36).slice(2);
    function Wp(i) {
        if (!i[ud]) {
            i[ud] = !0,
            $t.forEach(function(l) {
                l !== "selectionchange" && (TA.has(l) || jp(l, !1, i),
                jp(l, !0, i))
            });
            var a = i.nodeType === 9 ? i : i.ownerDocument;
            a === null || a[ud] || (a[ud] = !0,
            jp("selectionchange", !1, a))
        }
    }
    function vx(i, a, l, c) {
        switch (Vx(a)) {
        case 2:
            var p = JA;
            break;
        case 8:
            p = e1;
            break;
        default:
            p = am
        }
        l = p.bind(null, a, l, i),
        p = void 0,
        !hh || a !== "touchstart" && a !== "touchmove" && a !== "wheel" || (p = !0),
        c ? p !== void 0 ? i.addEventListener(a, l, {
            capture: !0,
            passive: p
        }) : i.addEventListener(a, l, !0) : p !== void 0 ? i.addEventListener(a, l, {
            passive: p
        }) : i.addEventListener(a, l, !1)
    }
    function Xp(i, a, l, c, p) {
        var v = c;
        if ((a & 1) === 0 && (a & 2) === 0 && c !== null)
            e: for (; ; ) {
                if (c === null)
                    return;
                var w = c.tag;
                if (w === 3 || w === 4) {
                    var L = c.stateNode.containerInfo;
                    if (L === p)
                        break;
                    if (w === 4)
                        for (w = c.return; w !== null; ) {
                            var Y = w.tag;
                            if ((Y === 3 || Y === 4) && w.stateNode.containerInfo === p)
                                return;
                            w = w.return
                        }
                    for (; L !== null; ) {
                        if (w = Dt(L),
                        w === null)
                            return;
                        if (Y = w.tag,
                        Y === 5 || Y === 6 || Y === 26 || Y === 27) {
                            c = v = w;
                            continue e
                        }
                        L = L.parentNode
                    }
                }
                c = c.return
            }
        M_(function() {
            var me = v
              , Re = dh(l)
              , Pe = [];
            e: {
                var ve = Q_.get(i);
                if (ve !== void 0) {
                    var be = Mu
                      , Nt = i;
                    switch (i) {
                    case "keypress":
                        if (Su(l) === 0)
                            break e;
                    case "keydown":
                    case "keyup":
                        be = xT;
                        break;
                    case "focusin":
                        Nt = "focus",
                        be = vh;
                        break;
                    case "focusout":
                        Nt = "blur",
                        be = vh;
                        break;
                    case "beforeblur":
                    case "afterblur":
                        be = vh;
                        break;
                    case "click":
                        if (l.button === 2)
                            break e;
                    case "auxclick":
                    case "dblclick":
                    case "mousedown":
                    case "mousemove":
                    case "mouseup":
                    case "mouseout":
                    case "mouseover":
                    case "contextmenu":
                        be = A_;
                        break;
                    case "drag":
                    case "dragend":
                    case "dragenter":
                    case "dragexit":
                    case "dragleave":
                    case "dragover":
                    case "dragstart":
                    case "drop":
                        be = lT;
                        break;
                    case "touchcancel":
                    case "touchend":
                    case "touchmove":
                    case "touchstart":
                        be = ET;
                        break;
                    case Y_:
                    case Z_:
                    case $_:
                        be = dT;
                        break;
                    case K_:
                        be = wT;
                        break;
                    case "scroll":
                    case "scrollend":
                        be = sT;
                        break;
                    case "wheel":
                        be = AT;
                        break;
                    case "copy":
                    case "cut":
                    case "paste":
                        be = hT;
                        break;
                    case "gotpointercapture":
                    case "lostpointercapture":
                    case "pointercancel":
                    case "pointerdown":
                    case "pointermove":
                    case "pointerout":
                    case "pointerover":
                    case "pointerup":
                        be = C_;
                        break;
                    case "toggle":
                    case "beforetoggle":
                        be = CT
                    }
                    var Ct = (a & 4) !== 0
                      , bn = !Ct && (i === "scroll" || i === "scrollend")
                      , ce = Ct ? ve !== null ? ve + "Capture" : null : ve;
                    Ct = [];
                    for (var ne = me, he; ne !== null; ) {
                        var Oe = ne;
                        if (he = Oe.stateNode,
                        Oe = Oe.tag,
                        Oe !== 5 && Oe !== 26 && Oe !== 27 || he === null || ce === null || (Oe = Dl(ne, ce),
                        Oe != null && Ct.push(fc(ne, Oe, he))),
                        bn)
                            break;
                        ne = ne.return
                    }
                    0 < Ct.length && (ve = new be(ve,Nt,null,l,Re),
                    Pe.push({
                        event: ve,
                        listeners: Ct
                    }))
                }
            }
            if ((a & 7) === 0) {
                e: {
                    if (ve = i === "mouseover" || i === "pointerover",
                    be = i === "mouseout" || i === "pointerout",
                    ve && l !== uh && (Nt = l.relatedTarget || l.fromElement) && (Dt(Nt) || Nt[je]))
                        break e;
                    if ((be || ve) && (ve = Re.window === Re ? Re : (ve = Re.ownerDocument) ? ve.defaultView || ve.parentWindow : window,
                    be ? (Nt = l.relatedTarget || l.toElement,
                    be = me,
                    Nt = Nt ? Dt(Nt) : null,
                    Nt !== null && (bn = o(Nt),
                    Ct = Nt.tag,
                    Nt !== bn || Ct !== 5 && Ct !== 27 && Ct !== 6) && (Nt = null)) : (be = null,
                    Nt = me),
                    be !== Nt)) {
                        if (Ct = A_,
                        Oe = "onMouseLeave",
                        ce = "onMouseEnter",
                        ne = "mouse",
                        (i === "pointerout" || i === "pointerover") && (Ct = C_,
                        Oe = "onPointerLeave",
                        ce = "onPointerEnter",
                        ne = "pointer"),
                        bn = be == null ? ve : En(be),
                        he = Nt == null ? ve : En(Nt),
                        ve = new Ct(Oe,ne + "leave",be,l,Re),
                        ve.target = bn,
                        ve.relatedTarget = he,
                        Oe = null,
                        Dt(Re) === me && (Ct = new Ct(ce,ne + "enter",Nt,l,Re),
                        Ct.target = he,
                        Ct.relatedTarget = bn,
                        Oe = Ct),
                        bn = Oe,
                        be && Nt)
                            t: {
                                for (Ct = be,
                                ce = Nt,
                                ne = 0,
                                he = Ct; he; he = Io(he))
                                    ne++;
                                for (he = 0,
                                Oe = ce; Oe; Oe = Io(Oe))
                                    he++;
                                for (; 0 < ne - he; )
                                    Ct = Io(Ct),
                                    ne--;
                                for (; 0 < he - ne; )
                                    ce = Io(ce),
                                    he--;
                                for (; ne--; ) {
                                    if (Ct === ce || ce !== null && Ct === ce.alternate)
                                        break t;
                                    Ct = Io(Ct),
                                    ce = Io(ce)
                                }
                                Ct = null
                            }
                        else
                            Ct = null;
                        be !== null && _x(Pe, ve, be, Ct, !1),
                        Nt !== null && bn !== null && _x(Pe, bn, Nt, Ct, !0)
                    }
                }
                e: {
                    if (ve = me ? En(me) : window,
                    be = ve.nodeName && ve.nodeName.toLowerCase(),
                    be === "select" || be === "input" && ve.type === "file")
                        var ct = z_;
                    else if (P_(ve))
                        if (k_)
                            ct = FT;
                        else {
                            ct = zT;
                            var Yt = IT
                        }
                    else
                        be = ve.nodeName,
                        !be || be.toLowerCase() !== "input" || ve.type !== "checkbox" && ve.type !== "radio" ? me && ch(me.elementType) && (ct = z_) : ct = kT;
                    if (ct && (ct = ct(i, me))) {
                        I_(Pe, ct, l, Re);
                        break e
                    }
                    Yt && Yt(i, ve, me),
                    i === "focusout" && me && ve.type === "number" && me.memoizedProps.value != null && pi(ve, "number", ve.value)
                }
                switch (Yt = me ? En(me) : window,
                i) {
                case "focusin":
                    (P_(Yt) || Yt.contentEditable === "true") && (fo = Yt,
                    Eh = me,
                    kl = null);
                    break;
                case "focusout":
                    kl = Eh = fo = null;
                    break;
                case "mousedown":
                    Mh = !0;
                    break;
                case "contextmenu":
                case "mouseup":
                case "dragend":
                    Mh = !1,
                    X_(Pe, l, Re);
                    break;
                case "selectionchange":
                    if (VT)
                        break;
                case "keydown":
                case "keyup":
                    X_(Pe, l, Re)
                }
                var wt;
                if (yh)
                    e: {
                        switch (i) {
                        case "compositionstart":
                            var Ut = "onCompositionStart";
                            break e;
                        case "compositionend":
                            Ut = "onCompositionEnd";
                            break e;
                        case "compositionupdate":
                            Ut = "onCompositionUpdate";
                            break e
                        }
                        Ut = void 0
                    }
                else
                    uo ? N_(i, l) && (Ut = "onCompositionEnd") : i === "keydown" && l.keyCode === 229 && (Ut = "onCompositionStart");
                Ut && (D_ && l.locale !== "ko" && (uo || Ut !== "onCompositionStart" ? Ut === "onCompositionEnd" && uo && (wt = w_()) : (Ua = Re,
                ph = "value"in Ua ? Ua.value : Ua.textContent,
                uo = !0)),
                Yt = dd(me, Ut),
                0 < Yt.length && (Ut = new R_(Ut,i,null,l,Re),
                Pe.push({
                    event: Ut,
                    listeners: Yt
                }),
                wt ? Ut.data = wt : (wt = O_(l),
                wt !== null && (Ut.data = wt)))),
                (wt = UT ? LT(i, l) : NT(i, l)) && (Ut = dd(me, "onBeforeInput"),
                0 < Ut.length && (Yt = new R_("onBeforeInput","beforeinput",null,l,Re),
                Pe.push({
                    event: Yt,
                    listeners: Ut
                }),
                Yt.data = wt)),
                EA(Pe, i, me, l, Re)
            }
            gx(Pe, a)
        })
    }
    function fc(i, a, l) {
        return {
            instance: i,
            listener: a,
            currentTarget: l
        }
    }
    function dd(i, a) {
        for (var l = a + "Capture", c = []; i !== null; ) {
            var p = i
              , v = p.stateNode;
            if (p = p.tag,
            p !== 5 && p !== 26 && p !== 27 || v === null || (p = Dl(i, l),
            p != null && c.unshift(fc(i, p, v)),
            p = Dl(i, a),
            p != null && c.push(fc(i, p, v))),
            i.tag === 3)
                return c;
            i = i.return
        }
        return []
    }
    function Io(i) {
        if (i === null)
            return null;
        do
            i = i.return;
        while (i && i.tag !== 5 && i.tag !== 27);
        return i || null
    }
    function _x(i, a, l, c, p) {
        for (var v = a._reactName, w = []; l !== null && l !== c; ) {
            var L = l
              , Y = L.alternate
              , me = L.stateNode;
            if (L = L.tag,
            Y !== null && Y === c)
                break;
            L !== 5 && L !== 26 && L !== 27 || me === null || (Y = me,
            p ? (me = Dl(l, v),
            me != null && w.unshift(fc(l, me, Y))) : p || (me = Dl(l, v),
            me != null && w.push(fc(l, me, Y)))),
            l = l.return
        }
        w.length !== 0 && i.push({
            event: a,
            listeners: w
        })
    }
    var AA = /\r\n?/g
      , RA = /\u0000|\uFFFD/g;
    function yx(i) {
        return (typeof i == "string" ? i : "" + i).replace(AA, `
`).replace(RA, "")
    }
    function xx(i, a) {
        return a = yx(a),
        yx(i) === a
    }
    function fd() {}
    function xn(i, a, l, c, p, v) {
        switch (l) {
        case "children":
            typeof c == "string" ? a === "body" || a === "textarea" && c === "" || Sr(i, c) : (typeof c == "number" || typeof c == "bigint") && a !== "body" && Sr(i, "" + c);
            break;
        case "className":
            Ge(i, "class", c);
            break;
        case "tabIndex":
            Ge(i, "tabindex", c);
            break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
            Ge(i, l, c);
            break;
        case "style":
            S_(i, c, v);
            break;
        case "data":
            if (a !== "object") {
                Ge(i, "data", c);
                break
            }
        case "src":
        case "href":
            if (c === "" && (a !== "a" || l !== "href")) {
                i.removeAttribute(l);
                break
            }
            if (c == null || typeof c == "function" || typeof c == "symbol" || typeof c == "boolean") {
                i.removeAttribute(l);
                break
            }
            c = xu("" + c),
            i.setAttribute(l, c);
            break;
        case "action":
        case "formAction":
            if (typeof c == "function") {
                i.setAttribute(l, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
                break
            } else
                typeof v == "function" && (l === "formAction" ? (a !== "input" && xn(i, a, "name", p.name, p, null),
                xn(i, a, "formEncType", p.formEncType, p, null),
                xn(i, a, "formMethod", p.formMethod, p, null),
                xn(i, a, "formTarget", p.formTarget, p, null)) : (xn(i, a, "encType", p.encType, p, null),
                xn(i, a, "method", p.method, p, null),
                xn(i, a, "target", p.target, p, null)));
            if (c == null || typeof c == "symbol" || typeof c == "boolean") {
                i.removeAttribute(l);
                break
            }
            c = xu("" + c),
            i.setAttribute(l, c);
            break;
        case "onClick":
            c != null && (i.onclick = fd);
            break;
        case "onScroll":
            c != null && Jt("scroll", i);
            break;
        case "onScrollEnd":
            c != null && Jt("scrollend", i);
            break;
        case "dangerouslySetInnerHTML":
            if (c != null) {
                if (typeof c != "object" || !("__html"in c))
                    throw Error(r(61));
                if (l = c.__html,
                l != null) {
                    if (p.children != null)
                        throw Error(r(60));
                    i.innerHTML = l
                }
            }
            break;
        case "multiple":
            i.multiple = c && typeof c != "function" && typeof c != "symbol";
            break;
        case "muted":
            i.muted = c && typeof c != "function" && typeof c != "symbol";
            break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
            break;
        case "autoFocus":
            break;
        case "xlinkHref":
            if (c == null || typeof c == "function" || typeof c == "boolean" || typeof c == "symbol") {
                i.removeAttribute("xlink:href");
                break
            }
            l = xu("" + c),
            i.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", l);
            break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
            c != null && typeof c != "function" && typeof c != "symbol" ? i.setAttribute(l, "" + c) : i.removeAttribute(l);
            break;
        case "inert":
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
            c && typeof c != "function" && typeof c != "symbol" ? i.setAttribute(l, "") : i.removeAttribute(l);
            break;
        case "capture":
        case "download":
            c === !0 ? i.setAttribute(l, "") : c !== !1 && c != null && typeof c != "function" && typeof c != "symbol" ? i.setAttribute(l, c) : i.removeAttribute(l);
            break;
        case "cols":
        case "rows":
        case "size":
        case "span":
            c != null && typeof c != "function" && typeof c != "symbol" && !isNaN(c) && 1 <= c ? i.setAttribute(l, c) : i.removeAttribute(l);
            break;
        case "rowSpan":
        case "start":
            c == null || typeof c == "function" || typeof c == "symbol" || isNaN(c) ? i.removeAttribute(l) : i.setAttribute(l, c);
            break;
        case "popover":
            Jt("beforetoggle", i),
            Jt("toggle", i),
            ke(i, "popover", c);
            break;
        case "xlinkActuate":
            Ie(i, "http://www.w3.org/1999/xlink", "xlink:actuate", c);
            break;
        case "xlinkArcrole":
            Ie(i, "http://www.w3.org/1999/xlink", "xlink:arcrole", c);
            break;
        case "xlinkRole":
            Ie(i, "http://www.w3.org/1999/xlink", "xlink:role", c);
            break;
        case "xlinkShow":
            Ie(i, "http://www.w3.org/1999/xlink", "xlink:show", c);
            break;
        case "xlinkTitle":
            Ie(i, "http://www.w3.org/1999/xlink", "xlink:title", c);
            break;
        case "xlinkType":
            Ie(i, "http://www.w3.org/1999/xlink", "xlink:type", c);
            break;
        case "xmlBase":
            Ie(i, "http://www.w3.org/XML/1998/namespace", "xml:base", c);
            break;
        case "xmlLang":
            Ie(i, "http://www.w3.org/XML/1998/namespace", "xml:lang", c);
            break;
        case "xmlSpace":
            Ie(i, "http://www.w3.org/XML/1998/namespace", "xml:space", c);
            break;
        case "is":
            ke(i, "is", c);
            break;
        case "innerText":
        case "textContent":
            break;
        default:
            (!(2 < l.length) || l[0] !== "o" && l[0] !== "O" || l[1] !== "n" && l[1] !== "N") && (l = rT.get(l) || l,
            ke(i, l, c))
        }
    }
    function qp(i, a, l, c, p, v) {
        switch (l) {
        case "style":
            S_(i, c, v);
            break;
        case "dangerouslySetInnerHTML":
            if (c != null) {
                if (typeof c != "object" || !("__html"in c))
                    throw Error(r(61));
                if (l = c.__html,
                l != null) {
                    if (p.children != null)
                        throw Error(r(60));
                    i.innerHTML = l
                }
            }
            break;
        case "children":
            typeof c == "string" ? Sr(i, c) : (typeof c == "number" || typeof c == "bigint") && Sr(i, "" + c);
            break;
        case "onScroll":
            c != null && Jt("scroll", i);
            break;
        case "onScrollEnd":
            c != null && Jt("scrollend", i);
            break;
        case "onClick":
            c != null && (i.onclick = fd);
            break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
            break;
        case "innerText":
        case "textContent":
            break;
        default:
            if (!br.hasOwnProperty(l))
                e: {
                    if (l[0] === "o" && l[1] === "n" && (p = l.endsWith("Capture"),
                    a = l.slice(2, p ? l.length - 7 : void 0),
                    v = i[ze] || null,
                    v = v != null ? v[l] : null,
                    typeof v == "function" && i.removeEventListener(a, v, p),
                    typeof c == "function")) {
                        typeof v != "function" && v !== null && (l in i ? i[l] = null : i.hasAttribute(l) && i.removeAttribute(l)),
                        i.addEventListener(a, c, p);
                        break e
                    }
                    l in i ? i[l] = c : c === !0 ? i.setAttribute(l, "") : ke(i, l, c)
                }
        }
    }
    function ui(i, a, l) {
        switch (a) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
            break;
        case "img":
            Jt("error", i),
            Jt("load", i);
            var c = !1, p = !1, v;
            for (v in l)
                if (l.hasOwnProperty(v)) {
                    var w = l[v];
                    if (w != null)
                        switch (v) {
                        case "src":
                            c = !0;
                            break;
                        case "srcSet":
                            p = !0;
                            break;
                        case "children":
                        case "dangerouslySetInnerHTML":
                            throw Error(r(137, a));
                        default:
                            xn(i, a, v, w, l, null)
                        }
                }
            p && xn(i, a, "srcSet", l.srcSet, l, null),
            c && xn(i, a, "src", l.src, l, null);
            return;
        case "input":
            Jt("invalid", i);
            var L = v = w = p = null
              , Y = null
              , me = null;
            for (c in l)
                if (l.hasOwnProperty(c)) {
                    var Re = l[c];
                    if (Re != null)
                        switch (c) {
                        case "name":
                            p = Re;
                            break;
                        case "type":
                            w = Re;
                            break;
                        case "checked":
                            Y = Re;
                            break;
                        case "defaultChecked":
                            me = Re;
                            break;
                        case "value":
                            v = Re;
                            break;
                        case "defaultValue":
                            L = Re;
                            break;
                        case "children":
                        case "dangerouslySetInnerHTML":
                            if (Re != null)
                                throw Error(r(137, a));
                            break;
                        default:
                            xn(i, a, c, Re, l, null)
                        }
                }
            Mn(i, v, L, Y, me, w, p, !1),
            Nn(i);
            return;
        case "select":
            Jt("invalid", i),
            c = w = v = null;
            for (p in l)
                if (l.hasOwnProperty(p) && (L = l[p],
                L != null))
                    switch (p) {
                    case "value":
                        v = L;
                        break;
                    case "defaultValue":
                        w = L;
                        break;
                    case "multiple":
                        c = L;
                    default:
                        xn(i, a, p, L, l, null)
                    }
            a = v,
            l = w,
            i.multiple = !!c,
            a != null ? qn(i, !!c, a, !1) : l != null && qn(i, !!c, l, !0);
            return;
        case "textarea":
            Jt("invalid", i),
            v = p = c = null;
            for (w in l)
                if (l.hasOwnProperty(w) && (L = l[w],
                L != null))
                    switch (w) {
                    case "value":
                        c = L;
                        break;
                    case "defaultValue":
                        p = L;
                        break;
                    case "children":
                        v = L;
                        break;
                    case "dangerouslySetInnerHTML":
                        if (L != null)
                            throw Error(r(91));
                        break;
                    default:
                        xn(i, a, w, L, l, null)
                    }
            oi(i, c, p, v),
            Nn(i);
            return;
        case "option":
            for (Y in l)
                if (l.hasOwnProperty(Y) && (c = l[Y],
                c != null))
                    switch (Y) {
                    case "selected":
                        i.selected = c && typeof c != "function" && typeof c != "symbol";
                        break;
                    default:
                        xn(i, a, Y, c, l, null)
                    }
            return;
        case "dialog":
            Jt("beforetoggle", i),
            Jt("toggle", i),
            Jt("cancel", i),
            Jt("close", i);
            break;
        case "iframe":
        case "object":
            Jt("load", i);
            break;
        case "video":
        case "audio":
            for (c = 0; c < dc.length; c++)
                Jt(dc[c], i);
            break;
        case "image":
            Jt("error", i),
            Jt("load", i);
            break;
        case "details":
            Jt("toggle", i);
            break;
        case "embed":
        case "source":
        case "link":
            Jt("error", i),
            Jt("load", i);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
            for (me in l)
                if (l.hasOwnProperty(me) && (c = l[me],
                c != null))
                    switch (me) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                        throw Error(r(137, a));
                    default:
                        xn(i, a, me, c, l, null)
                    }
            return;
        default:
            if (ch(a)) {
                for (Re in l)
                    l.hasOwnProperty(Re) && (c = l[Re],
                    c !== void 0 && qp(i, a, Re, c, l, void 0));
                return
            }
        }
        for (L in l)
            l.hasOwnProperty(L) && (c = l[L],
            c != null && xn(i, a, L, c, l, null))
    }
    function CA(i, a, l, c) {
        switch (a) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
            break;
        case "input":
            var p = null
              , v = null
              , w = null
              , L = null
              , Y = null
              , me = null
              , Re = null;
            for (be in l) {
                var Pe = l[be];
                if (l.hasOwnProperty(be) && Pe != null)
                    switch (be) {
                    case "checked":
                        break;
                    case "value":
                        break;
                    case "defaultValue":
                        Y = Pe;
                    default:
                        c.hasOwnProperty(be) || xn(i, a, be, null, c, Pe)
                    }
            }
            for (var ve in c) {
                var be = c[ve];
                if (Pe = l[ve],
                c.hasOwnProperty(ve) && (be != null || Pe != null))
                    switch (ve) {
                    case "type":
                        v = be;
                        break;
                    case "name":
                        p = be;
                        break;
                    case "checked":
                        me = be;
                        break;
                    case "defaultChecked":
                        Re = be;
                        break;
                    case "value":
                        w = be;
                        break;
                    case "defaultValue":
                        L = be;
                        break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                        if (be != null)
                            throw Error(r(137, a));
                        break;
                    default:
                        be !== Pe && xn(i, a, ve, be, c, Pe)
                    }
            }
            Vr(i, w, L, Y, me, Re, v, p);
            return;
        case "select":
            be = w = L = ve = null;
            for (v in l)
                if (Y = l[v],
                l.hasOwnProperty(v) && Y != null)
                    switch (v) {
                    case "value":
                        break;
                    case "multiple":
                        be = Y;
                    default:
                        c.hasOwnProperty(v) || xn(i, a, v, null, c, Y)
                    }
            for (p in c)
                if (v = c[p],
                Y = l[p],
                c.hasOwnProperty(p) && (v != null || Y != null))
                    switch (p) {
                    case "value":
                        ve = v;
                        break;
                    case "defaultValue":
                        L = v;
                        break;
                    case "multiple":
                        w = v;
                    default:
                        v !== Y && xn(i, a, p, v, c, Y)
                    }
            a = L,
            l = w,
            c = be,
            ve != null ? qn(i, !!l, ve, !1) : !!c != !!l && (a != null ? qn(i, !!l, a, !0) : qn(i, !!l, l ? [] : "", !1));
            return;
        case "textarea":
            be = ve = null;
            for (L in l)
                if (p = l[L],
                l.hasOwnProperty(L) && p != null && !c.hasOwnProperty(L))
                    switch (L) {
                    case "value":
                        break;
                    case "children":
                        break;
                    default:
                        xn(i, a, L, null, c, p)
                    }
            for (w in c)
                if (p = c[w],
                v = l[w],
                c.hasOwnProperty(w) && (p != null || v != null))
                    switch (w) {
                    case "value":
                        ve = p;
                        break;
                    case "defaultValue":
                        be = p;
                        break;
                    case "children":
                        break;
                    case "dangerouslySetInnerHTML":
                        if (p != null)
                            throw Error(r(91));
                        break;
                    default:
                        p !== v && xn(i, a, w, p, c, v)
                    }
            ti(i, ve, be);
            return;
        case "option":
            for (var Nt in l)
                if (ve = l[Nt],
                l.hasOwnProperty(Nt) && ve != null && !c.hasOwnProperty(Nt))
                    switch (Nt) {
                    case "selected":
                        i.selected = !1;
                        break;
                    default:
                        xn(i, a, Nt, null, c, ve)
                    }
            for (Y in c)
                if (ve = c[Y],
                be = l[Y],
                c.hasOwnProperty(Y) && ve !== be && (ve != null || be != null))
                    switch (Y) {
                    case "selected":
                        i.selected = ve && typeof ve != "function" && typeof ve != "symbol";
                        break;
                    default:
                        xn(i, a, Y, ve, c, be)
                    }
            return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
            for (var Ct in l)
                ve = l[Ct],
                l.hasOwnProperty(Ct) && ve != null && !c.hasOwnProperty(Ct) && xn(i, a, Ct, null, c, ve);
            for (me in c)
                if (ve = c[me],
                be = l[me],
                c.hasOwnProperty(me) && ve !== be && (ve != null || be != null))
                    switch (me) {
                    case "children":
                    case "dangerouslySetInnerHTML":
                        if (ve != null)
                            throw Error(r(137, a));
                        break;
                    default:
                        xn(i, a, me, ve, c, be)
                    }
            return;
        default:
            if (ch(a)) {
                for (var bn in l)
                    ve = l[bn],
                    l.hasOwnProperty(bn) && ve !== void 0 && !c.hasOwnProperty(bn) && qp(i, a, bn, void 0, c, ve);
                for (Re in c)
                    ve = c[Re],
                    be = l[Re],
                    !c.hasOwnProperty(Re) || ve === be || ve === void 0 && be === void 0 || qp(i, a, Re, ve, c, be);
                return
            }
        }
        for (var ce in l)
            ve = l[ce],
            l.hasOwnProperty(ce) && ve != null && !c.hasOwnProperty(ce) && xn(i, a, ce, null, c, ve);
        for (Pe in c)
            ve = c[Pe],
            be = l[Pe],
            !c.hasOwnProperty(Pe) || ve === be || ve == null && be == null || xn(i, a, Pe, ve, c, be)
    }
    var Yp = null
      , Zp = null;
    function hd(i) {
        return i.nodeType === 9 ? i : i.ownerDocument
    }
    function bx(i) {
        switch (i) {
        case "http://www.w3.org/2000/svg":
            return 1;
        case "http://www.w3.org/1998/Math/MathML":
            return 2;
        default:
            return 0
        }
    }
    function Sx(i, a) {
        if (i === 0)
            switch (a) {
            case "svg":
                return 1;
            case "math":
                return 2;
            default:
                return 0
            }
        return i === 1 && a === "foreignObject" ? 0 : i
    }
    function $p(i, a) {
        return i === "textarea" || i === "noscript" || typeof a.children == "string" || typeof a.children == "number" || typeof a.children == "bigint" || typeof a.dangerouslySetInnerHTML == "object" && a.dangerouslySetInnerHTML !== null && a.dangerouslySetInnerHTML.__html != null
    }
    var Kp = null;
    function DA() {
        var i = window.event;
        return i && i.type === "popstate" ? i === Kp ? !1 : (Kp = i,
        !0) : (Kp = null,
        !1)
    }
    var Ex = typeof setTimeout == "function" ? setTimeout : void 0
      , UA = typeof clearTimeout == "function" ? clearTimeout : void 0
      , Mx = typeof Promise == "function" ? Promise : void 0
      , LA = typeof queueMicrotask == "function" ? queueMicrotask : typeof Mx < "u" ? function(i) {
        return Mx.resolve(null).then(i).catch(NA)
    }
    : Ex;
    function NA(i) {
        setTimeout(function() {
            throw i
        })
    }
    function qa(i) {
        return i === "head"
    }
    function wx(i, a) {
        var l = a
          , c = 0
          , p = 0;
        do {
            var v = l.nextSibling;
            if (i.removeChild(l),
            v && v.nodeType === 8)
                if (l = v.data,
                l === "/$") {
                    if (0 < c && 8 > c) {
                        l = c;
                        var w = i.ownerDocument;
                        if (l & 1 && hc(w.documentElement),
                        l & 2 && hc(w.body),
                        l & 4)
                            for (l = w.head,
                            hc(l),
                            w = l.firstChild; w; ) {
                                var L = w.nextSibling
                                  , Y = w.nodeName;
                                w[Rt] || Y === "SCRIPT" || Y === "STYLE" || Y === "LINK" && w.rel.toLowerCase() === "stylesheet" || l.removeChild(w),
                                w = L
                            }
                    }
                    if (p === 0) {
                        i.removeChild(v),
                        bc(a);
                        return
                    }
                    p--
                } else
                    l === "$" || l === "$?" || l === "$!" ? p++ : c = l.charCodeAt(0) - 48;
            else
                c = 0;
            l = v
        } while (l);
        bc(a)
    }
    function Qp(i) {
        var a = i.firstChild;
        for (a && a.nodeType === 10 && (a = a.nextSibling); a; ) {
            var l = a;
            switch (a = a.nextSibling,
            l.nodeName) {
            case "HTML":
            case "HEAD":
            case "BODY":
                Qp(l),
                ft(l);
                continue;
            case "SCRIPT":
            case "STYLE":
                continue;
            case "LINK":
                if (l.rel.toLowerCase() === "stylesheet")
                    continue
            }
            i.removeChild(l)
        }
    }
    function OA(i, a, l, c) {
        for (; i.nodeType === 1; ) {
            var p = l;
            if (i.nodeName.toLowerCase() !== a.toLowerCase()) {
                if (!c && (i.nodeName !== "INPUT" || i.type !== "hidden"))
                    break
            } else if (c) {
                if (!i[Rt])
                    switch (a) {
                    case "meta":
                        if (!i.hasAttribute("itemprop"))
                            break;
                        return i;
                    case "link":
                        if (v = i.getAttribute("rel"),
                        v === "stylesheet" && i.hasAttribute("data-precedence"))
                            break;
                        if (v !== p.rel || i.getAttribute("href") !== (p.href == null || p.href === "" ? null : p.href) || i.getAttribute("crossorigin") !== (p.crossOrigin == null ? null : p.crossOrigin) || i.getAttribute("title") !== (p.title == null ? null : p.title))
                            break;
                        return i;
                    case "style":
                        if (i.hasAttribute("data-precedence"))
                            break;
                        return i;
                    case "script":
                        if (v = i.getAttribute("src"),
                        (v !== (p.src == null ? null : p.src) || i.getAttribute("type") !== (p.type == null ? null : p.type) || i.getAttribute("crossorigin") !== (p.crossOrigin == null ? null : p.crossOrigin)) && v && i.hasAttribute("async") && !i.hasAttribute("itemprop"))
                            break;
                        return i;
                    default:
                        return i
                    }
            } else if (a === "input" && i.type === "hidden") {
                var v = p.name == null ? null : "" + p.name;
                if (p.type === "hidden" && i.getAttribute("name") === v)
                    return i
            } else
                return i;
            if (i = dr(i.nextSibling),
            i === null)
                break
        }
        return null
    }
    function PA(i, a, l) {
        if (a === "")
            return null;
        for (; i.nodeType !== 3; )
            if ((i.nodeType !== 1 || i.nodeName !== "INPUT" || i.type !== "hidden") && !l || (i = dr(i.nextSibling),
            i === null))
                return null;
        return i
    }
    function Jp(i) {
        return i.data === "$!" || i.data === "$?" && i.ownerDocument.readyState === "complete"
    }
    function IA(i, a) {
        var l = i.ownerDocument;
        if (i.data !== "$?" || l.readyState === "complete")
            a();
        else {
            var c = function() {
                a(),
                l.removeEventListener("DOMContentLoaded", c)
            };
            l.addEventListener("DOMContentLoaded", c),
            i._reactRetry = c
        }
    }
    function dr(i) {
        for (; i != null; i = i.nextSibling) {
            var a = i.nodeType;
            if (a === 1 || a === 3)
                break;
            if (a === 8) {
                if (a = i.data,
                a === "$" || a === "$!" || a === "$?" || a === "F!" || a === "F")
                    break;
                if (a === "/$")
                    return null
            }
        }
        return i
    }
    var em = null;
    function Tx(i) {
        i = i.previousSibling;
        for (var a = 0; i; ) {
            if (i.nodeType === 8) {
                var l = i.data;
                if (l === "$" || l === "$!" || l === "$?") {
                    if (a === 0)
                        return i;
                    a--
                } else
                    l === "/$" && a++
            }
            i = i.previousSibling
        }
        return null
    }
    function Ax(i, a, l) {
        switch (a = hd(l),
        i) {
        case "html":
            if (i = a.documentElement,
            !i)
                throw Error(r(452));
            return i;
        case "head":
            if (i = a.head,
            !i)
                throw Error(r(453));
            return i;
        case "body":
            if (i = a.body,
            !i)
                throw Error(r(454));
            return i;
        default:
            throw Error(r(451))
        }
    }
    function hc(i) {
        for (var a = i.attributes; a.length; )
            i.removeAttributeNode(a[0]);
        ft(i)
    }
    var er = new Map
      , Rx = new Set;
    function pd(i) {
        return typeof i.getRootNode == "function" ? i.getRootNode() : i.nodeType === 9 ? i : i.ownerDocument
    }
    var na = W.d;
    W.d = {
        f: zA,
        r: kA,
        D: FA,
        C: BA,
        L: VA,
        m: HA,
        X: jA,
        S: GA,
        M: WA
    };
    function zA() {
        var i = na.f()
          , a = ad();
        return i || a
    }
    function kA(i) {
        var a = rn(i);
        a !== null && a.tag === 5 && a.type === "form" ? Y0(a) : na.r(i)
    }
    var zo = typeof document > "u" ? null : document;
    function Cx(i, a, l) {
        var c = zo;
        if (c && typeof a == "string" && a) {
            var p = An(a);
            p = 'link[rel="' + i + '"][href="' + p + '"]',
            typeof l == "string" && (p += '[crossorigin="' + l + '"]'),
            Rx.has(p) || (Rx.add(p),
            i = {
                rel: i,
                crossOrigin: l,
                href: a
            },
            c.querySelector(p) === null && (a = c.createElement("link"),
            ui(a, "link", i),
            on(a),
            c.head.appendChild(a)))
        }
    }
    function FA(i) {
        na.D(i),
        Cx("dns-prefetch", i, null)
    }
    function BA(i, a) {
        na.C(i, a),
        Cx("preconnect", i, a)
    }
    function VA(i, a, l) {
        na.L(i, a, l);
        var c = zo;
        if (c && i && a) {
            var p = 'link[rel="preload"][as="' + An(a) + '"]';
            a === "image" && l && l.imageSrcSet ? (p += '[imagesrcset="' + An(l.imageSrcSet) + '"]',
            typeof l.imageSizes == "string" && (p += '[imagesizes="' + An(l.imageSizes) + '"]')) : p += '[href="' + An(i) + '"]';
            var v = p;
            switch (a) {
            case "style":
                v = ko(i);
                break;
            case "script":
                v = Fo(i)
            }
            er.has(v) || (i = m({
                rel: "preload",
                href: a === "image" && l && l.imageSrcSet ? void 0 : i,
                as: a
            }, l),
            er.set(v, i),
            c.querySelector(p) !== null || a === "style" && c.querySelector(pc(v)) || a === "script" && c.querySelector(mc(v)) || (a = c.createElement("link"),
            ui(a, "link", i),
            on(a),
            c.head.appendChild(a)))
        }
    }
    function HA(i, a) {
        na.m(i, a);
        var l = zo;
        if (l && i) {
            var c = a && typeof a.as == "string" ? a.as : "script"
              , p = 'link[rel="modulepreload"][as="' + An(c) + '"][href="' + An(i) + '"]'
              , v = p;
            switch (c) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
                v = Fo(i)
            }
            if (!er.has(v) && (i = m({
                rel: "modulepreload",
                href: i
            }, a),
            er.set(v, i),
            l.querySelector(p) === null)) {
                switch (c) {
                case "audioworklet":
                case "paintworklet":
                case "serviceworker":
                case "sharedworker":
                case "worker":
                case "script":
                    if (l.querySelector(mc(v)))
                        return
                }
                c = l.createElement("link"),
                ui(c, "link", i),
                on(c),
                l.head.appendChild(c)
            }
        }
    }
    function GA(i, a, l) {
        na.S(i, a, l);
        var c = zo;
        if (c && i) {
            var p = Cn(c).hoistableStyles
              , v = ko(i);
            a = a || "default";
            var w = p.get(v);
            if (!w) {
                var L = {
                    loading: 0,
                    preload: null
                };
                if (w = c.querySelector(pc(v)))
                    L.loading = 5;
                else {
                    i = m({
                        rel: "stylesheet",
                        href: i,
                        "data-precedence": a
                    }, l),
                    (l = er.get(v)) && tm(i, l);
                    var Y = w = c.createElement("link");
                    on(Y),
                    ui(Y, "link", i),
                    Y._p = new Promise(function(me, Re) {
                        Y.onload = me,
                        Y.onerror = Re
                    }
                    ),
                    Y.addEventListener("load", function() {
                        L.loading |= 1
                    }),
                    Y.addEventListener("error", function() {
                        L.loading |= 2
                    }),
                    L.loading |= 4,
                    md(w, a, c)
                }
                w = {
                    type: "stylesheet",
                    instance: w,
                    count: 1,
                    state: L
                },
                p.set(v, w)
            }
        }
    }
    function jA(i, a) {
        na.X(i, a);
        var l = zo;
        if (l && i) {
            var c = Cn(l).hoistableScripts
              , p = Fo(i)
              , v = c.get(p);
            v || (v = l.querySelector(mc(p)),
            v || (i = m({
                src: i,
                async: !0
            }, a),
            (a = er.get(p)) && nm(i, a),
            v = l.createElement("script"),
            on(v),
            ui(v, "link", i),
            l.head.appendChild(v)),
            v = {
                type: "script",
                instance: v,
                count: 1,
                state: null
            },
            c.set(p, v))
        }
    }
    function WA(i, a) {
        na.M(i, a);
        var l = zo;
        if (l && i) {
            var c = Cn(l).hoistableScripts
              , p = Fo(i)
              , v = c.get(p);
            v || (v = l.querySelector(mc(p)),
            v || (i = m({
                src: i,
                async: !0,
                type: "module"
            }, a),
            (a = er.get(p)) && nm(i, a),
            v = l.createElement("script"),
            on(v),
            ui(v, "link", i),
            l.head.appendChild(v)),
            v = {
                type: "script",
                instance: v,
                count: 1,
                state: null
            },
            c.set(p, v))
        }
    }
    function Dx(i, a, l, c) {
        var p = (p = Se.current) ? pd(p) : null;
        if (!p)
            throw Error(r(446));
        switch (i) {
        case "meta":
        case "title":
            return null;
        case "style":
            return typeof l.precedence == "string" && typeof l.href == "string" ? (a = ko(l.href),
            l = Cn(p).hoistableStyles,
            c = l.get(a),
            c || (c = {
                type: "style",
                instance: null,
                count: 0,
                state: null
            },
            l.set(a, c)),
            c) : {
                type: "void",
                instance: null,
                count: 0,
                state: null
            };
        case "link":
            if (l.rel === "stylesheet" && typeof l.href == "string" && typeof l.precedence == "string") {
                i = ko(l.href);
                var v = Cn(p).hoistableStyles
                  , w = v.get(i);
                if (w || (p = p.ownerDocument || p,
                w = {
                    type: "stylesheet",
                    instance: null,
                    count: 0,
                    state: {
                        loading: 0,
                        preload: null
                    }
                },
                v.set(i, w),
                (v = p.querySelector(pc(i))) && !v._p && (w.instance = v,
                w.state.loading = 5),
                er.has(i) || (l = {
                    rel: "preload",
                    as: "style",
                    href: l.href,
                    crossOrigin: l.crossOrigin,
                    integrity: l.integrity,
                    media: l.media,
                    hrefLang: l.hrefLang,
                    referrerPolicy: l.referrerPolicy
                },
                er.set(i, l),
                v || XA(p, i, l, w.state))),
                a && c === null)
                    throw Error(r(528, ""));
                return w
            }
            if (a && c !== null)
                throw Error(r(529, ""));
            return null;
        case "script":
            return a = l.async,
            l = l.src,
            typeof l == "string" && a && typeof a != "function" && typeof a != "symbol" ? (a = Fo(l),
            l = Cn(p).hoistableScripts,
            c = l.get(a),
            c || (c = {
                type: "script",
                instance: null,
                count: 0,
                state: null
            },
            l.set(a, c)),
            c) : {
                type: "void",
                instance: null,
                count: 0,
                state: null
            };
        default:
            throw Error(r(444, i))
        }
    }
    function ko(i) {
        return 'href="' + An(i) + '"'
    }
    function pc(i) {
        return 'link[rel="stylesheet"][' + i + "]"
    }
    function Ux(i) {
        return m({}, i, {
            "data-precedence": i.precedence,
            precedence: null
        })
    }
    function XA(i, a, l, c) {
        i.querySelector('link[rel="preload"][as="style"][' + a + "]") ? c.loading = 1 : (a = i.createElement("link"),
        c.preload = a,
        a.addEventListener("load", function() {
            return c.loading |= 1
        }),
        a.addEventListener("error", function() {
            return c.loading |= 2
        }),
        ui(a, "link", l),
        on(a),
        i.head.appendChild(a))
    }
    function Fo(i) {
        return '[src="' + An(i) + '"]'
    }
    function mc(i) {
        return "script[async]" + i
    }
    function Lx(i, a, l) {
        if (a.count++,
        a.instance === null)
            switch (a.type) {
            case "style":
                var c = i.querySelector('style[data-href~="' + An(l.href) + '"]');
                if (c)
                    return a.instance = c,
                    on(c),
                    c;
                var p = m({}, l, {
                    "data-href": l.href,
                    "data-precedence": l.precedence,
                    href: null,
                    precedence: null
                });
                return c = (i.ownerDocument || i).createElement("style"),
                on(c),
                ui(c, "style", p),
                md(c, l.precedence, i),
                a.instance = c;
            case "stylesheet":
                p = ko(l.href);
                var v = i.querySelector(pc(p));
                if (v)
                    return a.state.loading |= 4,
                    a.instance = v,
                    on(v),
                    v;
                c = Ux(l),
                (p = er.get(p)) && tm(c, p),
                v = (i.ownerDocument || i).createElement("link"),
                on(v);
                var w = v;
                return w._p = new Promise(function(L, Y) {
                    w.onload = L,
                    w.onerror = Y
                }
                ),
                ui(v, "link", c),
                a.state.loading |= 4,
                md(v, l.precedence, i),
                a.instance = v;
            case "script":
                return v = Fo(l.src),
                (p = i.querySelector(mc(v))) ? (a.instance = p,
                on(p),
                p) : (c = l,
                (p = er.get(v)) && (c = m({}, l),
                nm(c, p)),
                i = i.ownerDocument || i,
                p = i.createElement("script"),
                on(p),
                ui(p, "link", c),
                i.head.appendChild(p),
                a.instance = p);
            case "void":
                return null;
            default:
                throw Error(r(443, a.type))
            }
        else
            a.type === "stylesheet" && (a.state.loading & 4) === 0 && (c = a.instance,
            a.state.loading |= 4,
            md(c, l.precedence, i));
        return a.instance
    }
    function md(i, a, l) {
        for (var c = l.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), p = c.length ? c[c.length - 1] : null, v = p, w = 0; w < c.length; w++) {
            var L = c[w];
            if (L.dataset.precedence === a)
                v = L;
            else if (v !== p)
                break
        }
        v ? v.parentNode.insertBefore(i, v.nextSibling) : (a = l.nodeType === 9 ? l.head : l,
        a.insertBefore(i, a.firstChild))
    }
    function tm(i, a) {
        i.crossOrigin == null && (i.crossOrigin = a.crossOrigin),
        i.referrerPolicy == null && (i.referrerPolicy = a.referrerPolicy),
        i.title == null && (i.title = a.title)
    }
    function nm(i, a) {
        i.crossOrigin == null && (i.crossOrigin = a.crossOrigin),
        i.referrerPolicy == null && (i.referrerPolicy = a.referrerPolicy),
        i.integrity == null && (i.integrity = a.integrity)
    }
    var gd = null;
    function Nx(i, a, l) {
        if (gd === null) {
            var c = new Map
              , p = gd = new Map;
            p.set(l, c)
        } else
            p = gd,
            c = p.get(l),
            c || (c = new Map,
            p.set(l, c));
        if (c.has(i))
            return c;
        for (c.set(i, null),
        l = l.getElementsByTagName(i),
        p = 0; p < l.length; p++) {
            var v = l[p];
            if (!(v[Rt] || v[Ue] || i === "link" && v.getAttribute("rel") === "stylesheet") && v.namespaceURI !== "http://www.w3.org/2000/svg") {
                var w = v.getAttribute(a) || "";
                w = i + w;
                var L = c.get(w);
                L ? L.push(v) : c.set(w, [v])
            }
        }
        return c
    }
    function Ox(i, a, l) {
        i = i.ownerDocument || i,
        i.head.insertBefore(l, a === "title" ? i.querySelector("head > title") : null)
    }
    function qA(i, a, l) {
        if (l === 1 || a.itemProp != null)
            return !1;
        switch (i) {
        case "meta":
        case "title":
            return !0;
        case "style":
            if (typeof a.precedence != "string" || typeof a.href != "string" || a.href === "")
                break;
            return !0;
        case "link":
            if (typeof a.rel != "string" || typeof a.href != "string" || a.href === "" || a.onLoad || a.onError)
                break;
            switch (a.rel) {
            case "stylesheet":
                return i = a.disabled,
                typeof a.precedence == "string" && i == null;
            default:
                return !0
            }
        case "script":
            if (a.async && typeof a.async != "function" && typeof a.async != "symbol" && !a.onLoad && !a.onError && a.src && typeof a.src == "string")
                return !0
        }
        return !1
    }
    function Px(i) {
        return !(i.type === "stylesheet" && (i.state.loading & 3) === 0)
    }
    var gc = null;
    function YA() {}
    function ZA(i, a, l) {
        if (gc === null)
            throw Error(r(475));
        var c = gc;
        if (a.type === "stylesheet" && (typeof l.media != "string" || matchMedia(l.media).matches !== !1) && (a.state.loading & 4) === 0) {
            if (a.instance === null) {
                var p = ko(l.href)
                  , v = i.querySelector(pc(p));
                if (v) {
                    i = v._p,
                    i !== null && typeof i == "object" && typeof i.then == "function" && (c.count++,
                    c = vd.bind(c),
                    i.then(c, c)),
                    a.state.loading |= 4,
                    a.instance = v,
                    on(v);
                    return
                }
                v = i.ownerDocument || i,
                l = Ux(l),
                (p = er.get(p)) && tm(l, p),
                v = v.createElement("link"),
                on(v);
                var w = v;
                w._p = new Promise(function(L, Y) {
                    w.onload = L,
                    w.onerror = Y
                }
                ),
                ui(v, "link", l),
                a.instance = v
            }
            c.stylesheets === null && (c.stylesheets = new Map),
            c.stylesheets.set(a, i),
            (i = a.state.preload) && (a.state.loading & 3) === 0 && (c.count++,
            a = vd.bind(c),
            i.addEventListener("load", a),
            i.addEventListener("error", a))
        }
    }
    function $A() {
        if (gc === null)
            throw Error(r(475));
        var i = gc;
        return i.stylesheets && i.count === 0 && im(i, i.stylesheets),
        0 < i.count ? function(a) {
            var l = setTimeout(function() {
                if (i.stylesheets && im(i, i.stylesheets),
                i.unsuspend) {
                    var c = i.unsuspend;
                    i.unsuspend = null,
                    c()
                }
            }, 6e4);
            return i.unsuspend = a,
            function() {
                i.unsuspend = null,
                clearTimeout(l)
            }
        }
        : null
    }
    function vd() {
        if (this.count--,
        this.count === 0) {
            if (this.stylesheets)
                im(this, this.stylesheets);
            else if (this.unsuspend) {
                var i = this.unsuspend;
                this.unsuspend = null,
                i()
            }
        }
    }
    var _d = null;
    function im(i, a) {
        i.stylesheets = null,
        i.unsuspend !== null && (i.count++,
        _d = new Map,
        a.forEach(KA, i),
        _d = null,
        vd.call(i))
    }
    function KA(i, a) {
        if (!(a.state.loading & 4)) {
            var l = _d.get(i);
            if (l)
                var c = l.get(null);
            else {
                l = new Map,
                _d.set(i, l);
                for (var p = i.querySelectorAll("link[data-precedence],style[data-precedence]"), v = 0; v < p.length; v++) {
                    var w = p[v];
                    (w.nodeName === "LINK" || w.getAttribute("media") !== "not all") && (l.set(w.dataset.precedence, w),
                    c = w)
                }
                c && l.set(null, c)
            }
            p = a.instance,
            w = p.getAttribute("data-precedence"),
            v = l.get(w) || c,
            v === c && l.set(null, p),
            l.set(w, p),
            this.count++,
            c = vd.bind(this),
            p.addEventListener("load", c),
            p.addEventListener("error", c),
            v ? v.parentNode.insertBefore(p, v.nextSibling) : (i = i.nodeType === 9 ? i.head : i,
            i.insertBefore(p, i.firstChild)),
            a.state.loading |= 4
        }
    }
    var vc = {
        $$typeof: D,
        Provider: null,
        Consumer: null,
        _currentValue: H,
        _currentValue2: H,
        _threadCount: 0
    };
    function QA(i, a, l, c, p, v, w, L) {
        this.tag = 1,
        this.containerInfo = i,
        this.pingCache = this.current = this.pendingChildren = null,
        this.timeoutHandle = -1,
        this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null,
        this.callbackPriority = 0,
        this.expirationTimes = Te(-1),
        this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
        this.entanglements = Te(0),
        this.hiddenUpdates = Te(null),
        this.identifierPrefix = c,
        this.onUncaughtError = p,
        this.onCaughtError = v,
        this.onRecoverableError = w,
        this.pooledCache = null,
        this.pooledCacheLanes = 0,
        this.formState = L,
        this.incompleteTransitions = new Map
    }
    function Ix(i, a, l, c, p, v, w, L, Y, me, Re, Pe) {
        return i = new QA(i,a,l,w,L,Y,me,Pe),
        a = 1,
        v === !0 && (a |= 24),
        v = Ii(3, null, null, a),
        i.current = v,
        v.stateNode = i,
        a = kh(),
        a.refCount++,
        i.pooledCache = a,
        a.refCount++,
        v.memoizedState = {
            element: c,
            isDehydrated: l,
            cache: a
        },
        Hh(v),
        i
    }
    function zx(i) {
        return i ? (i = go,
        i) : go
    }
    function kx(i, a, l, c, p, v) {
        p = zx(p),
        c.context === null ? c.context = p : c.pendingContext = p,
        c = Oa(a),
        c.payload = {
            element: l
        },
        v = v === void 0 ? null : v,
        v !== null && (c.callback = v),
        l = Pa(i, c, a),
        l !== null && (Vi(l, i, a),
        ql(l, i, a))
    }
    function Fx(i, a) {
        if (i = i.memoizedState,
        i !== null && i.dehydrated !== null) {
            var l = i.retryLane;
            i.retryLane = l !== 0 && l < a ? l : a
        }
    }
    function rm(i, a) {
        Fx(i, a),
        (i = i.alternate) && Fx(i, a)
    }
    function Bx(i) {
        if (i.tag === 13) {
            var a = mo(i, 67108864);
            a !== null && Vi(a, i, 67108864),
            rm(i, 67108864)
        }
    }
    var yd = !0;
    function JA(i, a, l, c) {
        var p = O.T;
        O.T = null;
        var v = W.p;
        try {
            W.p = 2,
            am(i, a, l, c)
        } finally {
            W.p = v,
            O.T = p
        }
    }
    function e1(i, a, l, c) {
        var p = O.T;
        O.T = null;
        var v = W.p;
        try {
            W.p = 8,
            am(i, a, l, c)
        } finally {
            W.p = v,
            O.T = p
        }
    }
    function am(i, a, l, c) {
        if (yd) {
            var p = sm(c);
            if (p === null)
                Xp(i, a, c, xd, l),
                Hx(i, c);
            else if (n1(p, i, a, l, c))
                c.stopPropagation();
            else if (Hx(i, c),
            a & 4 && -1 < t1.indexOf(i)) {
                for (; p !== null; ) {
                    var v = rn(p);
                    if (v !== null)
                        switch (v.tag) {
                        case 3:
                            if (v = v.stateNode,
                            v.current.memoizedState.isDehydrated) {
                                var w = qe(v.pendingLanes);
                                if (w !== 0) {
                                    var L = v;
                                    for (L.pendingLanes |= 2,
                                    L.entangledLanes |= 2; w; ) {
                                        var Y = 1 << 31 - Ae(w);
                                        L.entanglements[1] |= Y,
                                        w &= ~Y
                                    }
                                    Ar(v),
                                    (gn & 6) === 0 && (id = it() + 500,
                                    uc(0))
                                }
                            }
                            break;
                        case 13:
                            L = mo(v, 2),
                            L !== null && Vi(L, v, 2),
                            ad(),
                            rm(v, 2)
                        }
                    if (v = sm(c),
                    v === null && Xp(i, a, c, xd, l),
                    v === p)
                        break;
                    p = v
                }
                p !== null && c.stopPropagation()
            } else
                Xp(i, a, c, null, l)
        }
    }
    function sm(i) {
        return i = dh(i),
        om(i)
    }
    var xd = null;
    function om(i) {
        if (xd = null,
        i = Dt(i),
        i !== null) {
            var a = o(i);
            if (a === null)
                i = null;
            else {
                var l = a.tag;
                if (l === 13) {
                    if (i = u(a),
                    i !== null)
                        return i;
                    i = null
                } else if (l === 3) {
                    if (a.stateNode.current.memoizedState.isDehydrated)
                        return a.tag === 3 ? a.stateNode.containerInfo : null;
                    i = null
                } else
                    a !== i && (i = null)
            }
        }
        return xd = i,
        null
    }
    function Vx(i) {
        switch (i) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
            return 2;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
            return 8;
        case "message":
            switch (rt()) {
            case pt:
                return 2;
            case Xe:
                return 8;
            case B:
            case S:
                return 32;
            case I:
                return 268435456;
            default:
                return 32
            }
        default:
            return 32
        }
    }
    var lm = !1
      , Ya = null
      , Za = null
      , $a = null
      , _c = new Map
      , yc = new Map
      , Ka = []
      , t1 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");
    function Hx(i, a) {
        switch (i) {
        case "focusin":
        case "focusout":
            Ya = null;
            break;
        case "dragenter":
        case "dragleave":
            Za = null;
            break;
        case "mouseover":
        case "mouseout":
            $a = null;
            break;
        case "pointerover":
        case "pointerout":
            _c.delete(a.pointerId);
            break;
        case "gotpointercapture":
        case "lostpointercapture":
            yc.delete(a.pointerId)
        }
    }
    function xc(i, a, l, c, p, v) {
        return i === null || i.nativeEvent !== v ? (i = {
            blockedOn: a,
            domEventName: l,
            eventSystemFlags: c,
            nativeEvent: v,
            targetContainers: [p]
        },
        a !== null && (a = rn(a),
        a !== null && Bx(a)),
        i) : (i.eventSystemFlags |= c,
        a = i.targetContainers,
        p !== null && a.indexOf(p) === -1 && a.push(p),
        i)
    }
    function n1(i, a, l, c, p) {
        switch (a) {
        case "focusin":
            return Ya = xc(Ya, i, a, l, c, p),
            !0;
        case "dragenter":
            return Za = xc(Za, i, a, l, c, p),
            !0;
        case "mouseover":
            return $a = xc($a, i, a, l, c, p),
            !0;
        case "pointerover":
            var v = p.pointerId;
            return _c.set(v, xc(_c.get(v) || null, i, a, l, c, p)),
            !0;
        case "gotpointercapture":
            return v = p.pointerId,
            yc.set(v, xc(yc.get(v) || null, i, a, l, c, p)),
            !0
        }
        return !1
    }
    function Gx(i) {
        var a = Dt(i.target);
        if (a !== null) {
            var l = o(a);
            if (l !== null) {
                if (a = l.tag,
                a === 13) {
                    if (a = u(l),
                    a !== null) {
                        i.blockedOn = a,
                        ie(i.priority, function() {
                            if (l.tag === 13) {
                                var c = Bi();
                                c = zt(c);
                                var p = mo(l, c);
                                p !== null && Vi(p, l, c),
                                rm(l, c)
                            }
                        });
                        return
                    }
                } else if (a === 3 && l.stateNode.current.memoizedState.isDehydrated) {
                    i.blockedOn = l.tag === 3 ? l.stateNode.containerInfo : null;
                    return
                }
            }
        }
        i.blockedOn = null
    }
    function bd(i) {
        if (i.blockedOn !== null)
            return !1;
        for (var a = i.targetContainers; 0 < a.length; ) {
            var l = sm(i.nativeEvent);
            if (l === null) {
                l = i.nativeEvent;
                var c = new l.constructor(l.type,l);
                uh = c,
                l.target.dispatchEvent(c),
                uh = null
            } else
                return a = rn(l),
                a !== null && Bx(a),
                i.blockedOn = l,
                !1;
            a.shift()
        }
        return !0
    }
    function jx(i, a, l) {
        bd(i) && l.delete(a)
    }
    function i1() {
        lm = !1,
        Ya !== null && bd(Ya) && (Ya = null),
        Za !== null && bd(Za) && (Za = null),
        $a !== null && bd($a) && ($a = null),
        _c.forEach(jx),
        yc.forEach(jx)
    }
    function Sd(i, a) {
        i.blockedOn === a && (i.blockedOn = null,
        lm || (lm = !0,
        n.unstable_scheduleCallback(n.unstable_NormalPriority, i1)))
    }
    var Ed = null;
    function Wx(i) {
        Ed !== i && (Ed = i,
        n.unstable_scheduleCallback(n.unstable_NormalPriority, function() {
            Ed === i && (Ed = null);
            for (var a = 0; a < i.length; a += 3) {
                var l = i[a]
                  , c = i[a + 1]
                  , p = i[a + 2];
                if (typeof c != "function") {
                    if (om(c || l) === null)
                        continue;
                    break
                }
                var v = rn(l);
                v !== null && (i.splice(a, 3),
                a -= 3,
                op(v, {
                    pending: !0,
                    data: p,
                    method: l.method,
                    action: c
                }, c, p))
            }
        }))
    }
    function bc(i) {
        function a(Y) {
            return Sd(Y, i)
        }
        Ya !== null && Sd(Ya, i),
        Za !== null && Sd(Za, i),
        $a !== null && Sd($a, i),
        _c.forEach(a),
        yc.forEach(a);
        for (var l = 0; l < Ka.length; l++) {
            var c = Ka[l];
            c.blockedOn === i && (c.blockedOn = null)
        }
        for (; 0 < Ka.length && (l = Ka[0],
        l.blockedOn === null); )
            Gx(l),
            l.blockedOn === null && Ka.shift();
        if (l = (i.ownerDocument || i).$$reactFormReplay,
        l != null)
            for (c = 0; c < l.length; c += 3) {
                var p = l[c]
                  , v = l[c + 1]
                  , w = p[ze] || null;
                if (typeof v == "function")
                    w || Wx(l);
                else if (w) {
                    var L = null;
                    if (v && v.hasAttribute("formAction")) {
                        if (p = v,
                        w = v[ze] || null)
                            L = w.formAction;
                        else if (om(p) !== null)
                            continue
                    } else
                        L = w.action;
                    typeof L == "function" ? l[c + 1] = L : (l.splice(c, 3),
                    c -= 3),
                    Wx(l)
                }
            }
    }
    function cm(i) {
        this._internalRoot = i
    }
    Md.prototype.render = cm.prototype.render = function(i) {
        var a = this._internalRoot;
        if (a === null)
            throw Error(r(409));
        var l = a.current
          , c = Bi();
        kx(l, c, i, a, null, null)
    }
    ,
    Md.prototype.unmount = cm.prototype.unmount = function() {
        var i = this._internalRoot;
        if (i !== null) {
            this._internalRoot = null;
            var a = i.containerInfo;
            kx(i.current, 2, null, i, null, null),
            ad(),
            a[je] = null
        }
    }
    ;
    function Md(i) {
        this._internalRoot = i
    }
    Md.prototype.unstable_scheduleHydration = function(i) {
        if (i) {
            var a = j();
            i = {
                blockedOn: null,
                target: i,
                priority: a
            };
            for (var l = 0; l < Ka.length && a !== 0 && a < Ka[l].priority; l++)
                ;
            Ka.splice(l, 0, i),
            l === 0 && Gx(i)
        }
    }
    ;
    var Xx = e.version;
    if (Xx !== "19.1.0")
        throw Error(r(527, Xx, "19.1.0"));
    W.findDOMNode = function(i) {
        var a = i._reactInternals;
        if (a === void 0)
            throw typeof i.render == "function" ? Error(r(188)) : (i = Object.keys(i).join(","),
            Error(r(268, i)));
        return i = f(a),
        i = i !== null ? h(i) : null,
        i = i === null ? null : i.stateNode,
        i
    }
    ;
    var r1 = {
        bundleType: 0,
        version: "19.1.0",
        rendererPackageName: "react-dom",
        currentDispatcherRef: O,
        reconcilerVersion: "19.1.0"
    };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
        var wd = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!wd.isDisabled && wd.supportsFiber)
            try {
                J = wd.inject(r1),
                de = wd
            } catch {}
    }
    return Ec.createRoot = function(i, a) {
        if (!s(i))
            throw Error(r(299));
        var l = !1
          , c = ""
          , p = ly
          , v = cy
          , w = uy
          , L = null;
        return a != null && (a.unstable_strictMode === !0 && (l = !0),
        a.identifierPrefix !== void 0 && (c = a.identifierPrefix),
        a.onUncaughtError !== void 0 && (p = a.onUncaughtError),
        a.onCaughtError !== void 0 && (v = a.onCaughtError),
        a.onRecoverableError !== void 0 && (w = a.onRecoverableError),
        a.unstable_transitionCallbacks !== void 0 && (L = a.unstable_transitionCallbacks)),
        a = Ix(i, 1, !1, null, null, l, c, p, v, w, L, null),
        i[je] = a.current,
        Wp(i),
        new cm(a)
    }
    ,
    Ec.hydrateRoot = function(i, a, l) {
        if (!s(i))
            throw Error(r(299));
        var c = !1
          , p = ""
          , v = ly
          , w = cy
          , L = uy
          , Y = null
          , me = null;
        return l != null && (l.unstable_strictMode === !0 && (c = !0),
        l.identifierPrefix !== void 0 && (p = l.identifierPrefix),
        l.onUncaughtError !== void 0 && (v = l.onUncaughtError),
        l.onCaughtError !== void 0 && (w = l.onCaughtError),
        l.onRecoverableError !== void 0 && (L = l.onRecoverableError),
        l.unstable_transitionCallbacks !== void 0 && (Y = l.unstable_transitionCallbacks),
        l.formState !== void 0 && (me = l.formState)),
        a = Ix(i, 1, !0, a, l ?? null, c, p, v, w, L, Y, me),
        a.context = zx(null),
        l = a.current,
        c = Bi(),
        c = zt(c),
        p = Oa(c),
        p.callback = null,
        Pa(l, p, c),
        l = c,
        a.current.lanes = l,
        Ne(a, l),
        Ar(a),
        i[je] = a.current,
        Wp(i),
        new Md(a)
    }
    ,
    Ec.version = "19.1.0",
    Ec
}
var nb;
function h1() {
    if (nb)
        return fm.exports;
    nb = 1;
    function n() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
            try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)
            } catch (e) {
                console.error(e)
            }
    }
    return n(),
    fm.exports = f1(),
    fm.exports
}
var p1 = h1()
  , m1 = Object.freeze({
    InvalidProxyUrlErrorMessage: "The proxyUrl passed to Clerk is invalid. The expected value for proxyUrl is an absolute URL or a relative path with a leading '/'. (key={{url}})",
    InvalidPublishableKeyErrorMessage: "The publishableKey passed to Clerk is invalid. You can get your Publishable key at https://dashboard.clerk.com/last-active?path=api-keys. (key={{key}})",
    MissingPublishableKeyErrorMessage: "Missing publishableKey. You can get your key at https://dashboard.clerk.com/last-active?path=api-keys.",
    MissingSecretKeyErrorMessage: "Missing secretKey. You can get your key at https://dashboard.clerk.com/last-active?path=api-keys.",
    MissingClerkProvider: "{{source}} can only be used within the <ClerkProvider /> component. Learn more: https://clerk.com/docs/components/clerk-provider"
});
function TE({packageName: n, customMessages: e}) {
    let t = n;
    const r = {
        ...m1,
        ...e
    };
    function s(o, u) {
        if (!u)
            return `${t}: ${o}`;
        let d = o;
        const f = o.matchAll(/{{([a-zA-Z0-9-_]+)}}/g);
        for (const h of f) {
            const m = (u[h[1]] || "").toString();
            d = d.replace(`{{${h[1]}}}`, m)
        }
        return `${t}: ${d}`
    }
    return {
        setPackageName({packageName: o}) {
            return typeof o == "string" && (t = o),
            this
        },
        setMessages({customMessages: o}) {
            return Object.assign(r, o || {}),
            this
        },
        throwInvalidPublishableKeyError(o) {
            throw new Error(s(r.InvalidPublishableKeyErrorMessage, o))
        },
        throwInvalidProxyUrl(o) {
            throw new Error(s(r.InvalidProxyUrlErrorMessage, o))
        },
        throwMissingPublishableKeyError() {
            throw new Error(s(r.MissingPublishableKeyErrorMessage))
        },
        throwMissingSecretKeyError() {
            throw new Error(s(r.MissingSecretKeyErrorMessage))
        },
        throwMissingClerkProviderError(o) {
            throw new Error(s(r.MissingClerkProvider, o))
        },
        throw(o) {
            throw new Error(s(o))
        }
    }
}
var AE = Object.defineProperty
  , g1 = Object.getOwnPropertyDescriptor
  , v1 = Object.getOwnPropertyNames
  , _1 = Object.prototype.hasOwnProperty
  , y1 = (n, e) => {
    for (var t in e)
        AE(n, t, {
            get: e[t],
            enumerable: !0
        })
}
  , x1 = (n, e, t, r) => {
    if (e && typeof e == "object" || typeof e == "function")
        for (let s of v1(e))
            !_1.call(n, s) && s !== t && AE(n, s, {
                get: () => e[s],
                enumerable: !(r = g1(e, s)) || r.enumerable
            });
    return n
}
  , b1 = (n, e, t) => (x1(n, e, "default"),
t)
  , S1 = {
    strict_mfa: {
        afterMinutes: 10,
        level: "multi_factor"
    },
    strict: {
        afterMinutes: 10,
        level: "second_factor"
    },
    moderate: {
        afterMinutes: 60,
        level: "second_factor"
    },
    lax: {
        afterMinutes: 1440,
        level: "second_factor"
    }
}
  , E1 = new Set(["first_factor", "second_factor", "multi_factor"])
  , M1 = new Set(["strict_mfa", "strict", "moderate", "lax"])
  , w1 = n => typeof n == "number" && n > 0
  , T1 = n => E1.has(n)
  , A1 = n => M1.has(n)
  , R1 = (n, e) => {
    const {orgId: t, orgRole: r, orgPermissions: s} = e;
    return !n.role && !n.permission || !t || !r || !s ? null : n.permission ? s.includes(n.permission) : n.role ? r === n.role : null
}
  , ib = (n, e) => {
    const {org: t, user: r} = D1(n)
      , [s,o] = e.split(":")
      , u = o || s;
    return s === "org" ? t.includes(u) : s === "user" ? r.includes(u) : [...t, ...r].includes(u)
}
  , C1 = (n, e) => {
    const {features: t, plans: r} = e;
    return n.feature && t ? ib(t, n.feature) : n.plan && r ? ib(r, n.plan) : null
}
  , D1 = n => {
    const e = n ? n.split(",").map(t => t.trim()) : [];
    return {
        org: e.filter(t => t.split(":")[0].includes("o")).map(t => t.split(":")[1]),
        user: e.filter(t => t.split(":")[0].includes("u")).map(t => t.split(":")[1])
    }
}
  , U1 = n => {
    if (!n)
        return !1;
    const e = s => typeof s == "string" ? S1[s] : s
      , t = typeof n == "string" && A1(n)
      , r = typeof n == "object" && T1(n.level) && w1(n.afterMinutes);
    return t || r ? e.bind(null, n) : !1
}
  , L1 = (n, {factorVerificationAge: e}) => {
    if (!n.reverification || !e)
        return null;
    const t = U1(n.reverification);
    if (!t)
        return null;
    const {level: r, afterMinutes: s} = t()
      , [o,u] = e
      , d = o !== -1 ? s > o : null
      , f = u !== -1 ? s > u : null;
    switch (r) {
    case "first_factor":
        return d;
    case "second_factor":
        return u !== -1 ? f : d;
    case "multi_factor":
        return u === -1 ? d : d && f
    }
}
  , N1 = n => e => {
    if (!n.userId)
        return !1;
    const t = C1(e, n)
      , r = R1(e, n)
      , s = L1(e, n);
    return [t || r, s].some(o => o === null) ? [t || r, s].some(o => o === !0) : [t || r, s].every(o => o === !0)
}
  , O1 = ({authObject: {sessionId: n, sessionStatus: e, userId: t, actor: r, orgId: s, orgRole: o, orgSlug: u, signOut: d, getToken: f, has: h, sessionClaims: m}, options: {treatPendingAsSignedOut: g=!0}}) => {
    if (n === void 0 && t === void 0)
        return {
            isLoaded: !1,
            isSignedIn: void 0,
            sessionId: n,
            sessionClaims: void 0,
            userId: t,
            actor: void 0,
            orgId: void 0,
            orgRole: void 0,
            orgSlug: void 0,
            has: void 0,
            signOut: d,
            getToken: f
        };
    if (n === null && t === null)
        return {
            isLoaded: !0,
            isSignedIn: !1,
            sessionId: n,
            userId: t,
            sessionClaims: null,
            actor: null,
            orgId: null,
            orgRole: null,
            orgSlug: null,
            has: () => !1,
            signOut: d,
            getToken: f
        };
    if (g && e === "pending")
        return {
            isLoaded: !0,
            isSignedIn: !1,
            sessionId: null,
            userId: null,
            sessionClaims: null,
            actor: null,
            orgId: null,
            orgRole: null,
            orgSlug: null,
            has: () => !1,
            signOut: d,
            getToken: f
        };
    if (n && m && t && s && o)
        return {
            isLoaded: !0,
            isSignedIn: !0,
            sessionId: n,
            sessionClaims: m,
            userId: t,
            actor: r || null,
            orgId: s,
            orgRole: o,
            orgSlug: u || null,
            has: h,
            signOut: d,
            getToken: f
        };
    if (n && m && t && !s)
        return {
            isLoaded: !0,
            isSignedIn: !0,
            sessionId: n,
            sessionClaims: m,
            userId: t,
            actor: r || null,
            orgId: null,
            orgRole: null,
            orgSlug: null,
            has: h,
            signOut: d,
            getToken: f
        }
}
  , RE = n => typeof atob < "u" && typeof atob == "function" ? atob(n) : typeof global < "u" && global.Buffer ? new global.Buffer(n,"base64").toString() : n
  , P1 = [".lcl.dev", ".stg.dev", ".lclstage.dev", ".stgstage.dev", ".dev.lclclerk.com", ".stg.lclclerk.com", ".accounts.lclclerk.com", "accountsstage.dev", "accounts.dev"]
  , CE = "pk_live_"
  , I1 = "pk_test_";
function rb(n, e={}) {
    if (n = n || "",
    !n || !yg(n)) {
        if (e.fatal && !n)
            throw new Error("Publishable key is missing. Ensure that your publishable key is correctly configured. Double-check your environment configuration for your keys, or access them here: https://dashboard.clerk.com/last-active?path=api-keys");
        if (e.fatal && !yg(n))
            throw new Error("Publishable key not valid.");
        return null
    }
    const t = n.startsWith(CE) ? "production" : "development";
    let r = RE(n.split("_")[2]);
    return r = r.slice(0, -1),
    e.proxyUrl ? r = e.proxyUrl : t !== "development" && e.domain && (r = `clerk.${e.domain}`),
    {
        instanceType: t,
        frontendApi: r
    }
}
function yg(n="") {
    try {
        const e = n.startsWith(CE) || n.startsWith(I1)
          , t = RE(n.split("_")[2] || "").endsWith("$");
        return e && t
    } catch {
        return !1
    }
}
function z1() {
    const n = new Map;
    return {
        isDevOrStagingUrl: e => {
            if (!e)
                return !1;
            const t = typeof e == "string" ? e : e.hostname;
            let r = n.get(t);
            return r === void 0 && (r = P1.some(s => t.endsWith(s)),
            n.set(t, r)),
            r
        }
    }
}
var k1 = "METHOD_CALLED";
function Vv(n, e) {
    return {
        event: k1,
        payload: {
            method: n,
            ...e
        }
    }
}
var gm = {
    exports: {}
}
  , vm = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ab;
function F1() {
    if (ab)
        return vm;
    ab = 1;
    var n = jf();
    function e(g, _) {
        return g === _ && (g !== 0 || 1 / g === 1 / _) || g !== g && _ !== _
    }
    var t = typeof Object.is == "function" ? Object.is : e
      , r = n.useState
      , s = n.useEffect
      , o = n.useLayoutEffect
      , u = n.useDebugValue;
    function d(g, _) {
        var x = _()
          , E = r({
            inst: {
                value: x,
                getSnapshot: _
            }
        })
          , M = E[0].inst
          , b = E[1];
        return o(function() {
            M.value = x,
            M.getSnapshot = _,
            f(M) && b({
                inst: M
            })
        }, [g, x, _]),
        s(function() {
            return f(M) && b({
                inst: M
            }),
            g(function() {
                f(M) && b({
                    inst: M
                })
            })
        }, [g]),
        u(x),
        x
    }
    function f(g) {
        var _ = g.getSnapshot;
        g = g.value;
        try {
            var x = _();
            return !t(g, x)
        } catch {
            return !0
        }
    }
    function h(g, _) {
        return _()
    }
    var m = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? h : d;
    return vm.useSyncExternalStore = n.useSyncExternalStore !== void 0 ? n.useSyncExternalStore : m,
    vm
}
var sb;
function B1() {
    return sb || (sb = 1,
    gm.exports = F1()),
    gm.exports
}
var DE = B1();
const UE = 0
  , LE = 1
  , NE = 2
  , ob = 3;
var lb = Object.prototype.hasOwnProperty;
function xg(n, e) {
    var t, r;
    if (n === e)
        return !0;
    if (n && e && (t = n.constructor) === e.constructor) {
        if (t === Date)
            return n.getTime() === e.getTime();
        if (t === RegExp)
            return n.toString() === e.toString();
        if (t === Array) {
            if ((r = n.length) === e.length)
                for (; r-- && xg(n[r], e[r]); )
                    ;
            return r === -1
        }
        if (!t || typeof n == "object") {
            r = 0;
            for (t in n)
                if (lb.call(n, t) && ++r && !lb.call(e, t) || !(t in e) || !xg(n[t], e[t]))
                    return !1;
            return Object.keys(e).length === r
        }
    }
    return n !== n && e !== e
}
const mr = new WeakMap
  , ps = () => {}
  , Qn = ps()
  , xf = Object
  , Gt = n => n === Qn
  , rr = n => typeof n == "function"
  , wa = (n, e) => ({
    ...n,
    ...e
})
  , OE = n => rr(n.then)
  , _m = {}
  , Td = {}
  , Hv = "undefined"
  , su = typeof window != Hv
  , bg = typeof document != Hv
  , V1 = su && "Deno"in window
  , H1 = () => su && typeof window.requestAnimationFrame != Hv
  , ls = (n, e) => {
    const t = mr.get(n);
    return [ () => !Gt(e) && n.get(e) || _m, r => {
        if (!Gt(e)) {
            const s = n.get(e);
            e in Td || (Td[e] = s),
            t[5](e, wa(s, r), s || _m)
        }
    }
    , t[6], () => !Gt(e) && e in Td ? Td[e] : !Gt(e) && n.get(e) || _m]
}
;
let Sg = !0;
const G1 = () => Sg
  , [Eg,Mg] = su && window.addEventListener ? [window.addEventListener.bind(window), window.removeEventListener.bind(window)] : [ps, ps]
  , j1 = () => {
    const n = bg && document.visibilityState;
    return Gt(n) || n !== "hidden"
}
  , W1 = n => (bg && document.addEventListener("visibilitychange", n),
Eg("focus", n),
() => {
    bg && document.removeEventListener("visibilitychange", n),
    Mg("focus", n)
}
)
  , X1 = n => {
    const e = () => {
        Sg = !0,
        n()
    }
      , t = () => {
        Sg = !1
    }
    ;
    return Eg("online", e),
    Eg("offline", t),
    () => {
        Mg("online", e),
        Mg("offline", t)
    }
}
  , q1 = {
    isOnline: G1,
    isVisible: j1
}
  , Y1 = {
    initFocus: W1,
    initReconnect: X1
}
  , cb = !K.useId
  , Zc = !su || V1
  , Z1 = n => H1() ? window.requestAnimationFrame(n) : setTimeout(n, 1)
  , Hc = Zc ? $.useEffect : $.useLayoutEffect
  , ym = typeof navigator < "u" && navigator.connection
  , ub = !Zc && ym && (["slow-2g", "2g"].includes(ym.effectiveType) || ym.saveData)
  , Ad = new WeakMap
  , xm = (n, e) => xf.prototype.toString.call(n) === `[object ${e}]`;
let $1 = 0;
const wg = n => {
    const e = typeof n
      , t = xm(n, "Date")
      , r = xm(n, "RegExp")
      , s = xm(n, "Object");
    let o, u;
    if (xf(n) === n && !t && !r) {
        if (o = Ad.get(n),
        o)
            return o;
        if (o = ++$1 + "~",
        Ad.set(n, o),
        Array.isArray(n)) {
            for (o = "@",
            u = 0; u < n.length; u++)
                o += wg(n[u]) + ",";
            Ad.set(n, o)
        }
        if (s) {
            o = "#";
            const d = xf.keys(n).sort();
            for (; !Gt(u = d.pop()); )
                Gt(n[u]) || (o += u + ":" + wg(n[u]) + ",");
            Ad.set(n, o)
        }
    } else
        o = t ? n.toJSON() : e == "symbol" ? n.toString() : e == "string" ? JSON.stringify(n) : "" + n;
    return o
}
  , hl = n => {
    if (rr(n))
        try {
            n = n()
        } catch {
            n = ""
        }
    const e = n;
    return n = typeof n == "string" ? n : (Array.isArray(n) ? n.length : n) ? wg(n) : "",
    [n, e]
}
;
let K1 = 0;
const Tg = () => ++K1;
async function PE(...n) {
    const [e,t,r,s] = n
      , o = wa({
        populateCache: !0,
        throwOnError: !0
    }, typeof s == "boolean" ? {
        revalidate: s
    } : s || {});
    let u = o.populateCache;
    const d = o.rollbackOnError;
    let f = o.optimisticData;
    const h = _ => typeof d == "function" ? d(_) : d !== !1
      , m = o.throwOnError;
    if (rr(t)) {
        const _ = t
          , x = []
          , E = e.keys();
        for (const M of E)
            !/^\$(inf|sub)\$/.test(M) && _(e.get(M)._k) && x.push(M);
        return Promise.all(x.map(g))
    }
    return g(t);
    async function g(_) {
        const [x] = hl(_);
        if (!x)
            return;
        const [E,M] = ls(e, x)
          , [b,y,T,D] = mr.get(e)
          , C = () => {
            const X = b[x];
            return (rr(o.revalidate) ? o.revalidate(E().data, _) : o.revalidate !== !1) && (delete T[x],
            delete D[x],
            X && X[0]) ? X[0](NE).then( () => E().data) : E().data
        }
        ;
        if (n.length < 3)
            return C();
        let P = r, A;
        const F = Tg();
        y[x] = [F, 0];
        const z = !Gt(f)
          , U = E()
          , R = U.data
          , V = U._c
          , Q = Gt(V) ? R : V;
        if (z && (f = rr(f) ? f(Q, R) : f,
        M({
            data: f,
            _c: Q
        })),
        rr(P))
            try {
                P = P(Q)
            } catch (X) {
                A = X
            }
        if (P && OE(P))
            if (P = await P.catch(X => {
                A = X
            }
            ),
            F !== y[x][0]) {
                if (A)
                    throw A;
                return P
            } else
                A && z && h(A) && (u = !0,
                M({
                    data: Q,
                    _c: Qn
                }));
        if (u && !A)
            if (rr(u)) {
                const X = u(P, Q);
                M({
                    data: X,
                    error: Qn,
                    _c: Qn
                })
            } else
                M({
                    data: P,
                    error: Qn,
                    _c: Qn
                });
        if (y[x][1] = Tg(),
        Promise.resolve(C()).then( () => {
            M({
                _c: Qn
            })
        }
        ),
        A) {
            if (m)
                throw A;
            return
        }
        return P
    }
}
const db = (n, e) => {
    for (const t in n)
        n[t][0] && n[t][0](e)
}
  , IE = (n, e) => {
    if (!mr.has(n)) {
        const t = wa(Y1, e)
          , r = Object.create(null)
          , s = PE.bind(Qn, n);
        let o = ps;
        const u = Object.create(null)
          , d = (m, g) => {
            const _ = u[m] || [];
            return u[m] = _,
            _.push(g),
            () => _.splice(_.indexOf(g), 1)
        }
          , f = (m, g, _) => {
            n.set(m, g);
            const x = u[m];
            if (x)
                for (const E of x)
                    E(g, _)
        }
          , h = () => {
            if (!mr.has(n) && (mr.set(n, [r, Object.create(null), Object.create(null), Object.create(null), s, f, d]),
            !Zc)) {
                const m = t.initFocus(setTimeout.bind(Qn, db.bind(Qn, r, UE)))
                  , g = t.initReconnect(setTimeout.bind(Qn, db.bind(Qn, r, LE)));
                o = () => {
                    m && m(),
                    g && g(),
                    mr.delete(n)
                }
            }
        }
        ;
        return h(),
        [n, s, h, o]
    }
    return [n, mr.get(n)[4]]
}
  , Q1 = (n, e, t, r, s) => {
    const o = t.errorRetryCount
      , u = s.retryCount
      , d = ~~((Math.random() + .5) * (1 << (u < 8 ? u : 8))) * t.errorRetryInterval;
    !Gt(o) && u > o || setTimeout(r, d, s)
}
  , J1 = xg
  , [ou,zE] = IE(new Map)
  , kE = wa({
    onLoadingSlow: ps,
    onSuccess: ps,
    onError: ps,
    onErrorRetry: Q1,
    onDiscarded: ps,
    revalidateOnFocus: !0,
    revalidateOnReconnect: !0,
    revalidateIfStale: !0,
    shouldRetryOnError: !0,
    errorRetryInterval: ub ? 1e4 : 5e3,
    focusThrottleInterval: 5 * 1e3,
    dedupingInterval: 2 * 1e3,
    loadingTimeout: ub ? 5e3 : 3e3,
    compare: J1,
    isPaused: () => !1,
    cache: ou,
    mutate: zE,
    fallback: {}
}, q1)
  , FE = (n, e) => {
    const t = wa(n, e);
    if (e) {
        const {use: r, fallback: s} = n
          , {use: o, fallback: u} = e;
        r && o && (t.use = r.concat(o)),
        s && u && (t.fallback = wa(s, u))
    }
    return t
}
  , Ag = $.createContext({})
  , eR = n => {
    const {value: e} = n
      , t = $.useContext(Ag)
      , r = rr(e)
      , s = $.useMemo( () => r ? e(t) : e, [r, t, e])
      , o = $.useMemo( () => r ? s : FE(t, s), [r, t, s])
      , u = s && s.provider
      , d = $.useRef(Qn);
    u && !d.current && (d.current = IE(u(o.cache || ou), s));
    const f = d.current;
    return f && (o.cache = f[0],
    o.mutate = f[1]),
    Hc( () => {
        if (f)
            return f[2] && f[2](),
            f[3]
    }
    , []),
    $.createElement(Ag.Provider, wa(n, {
        value: o
    }))
}
  , BE = "$inf$"
  , VE = su && window.__SWR_DEVTOOLS_USE__
  , tR = VE ? window.__SWR_DEVTOOLS_USE__ : []
  , nR = () => {
    VE && (window.__SWR_DEVTOOLS_REACT__ = K)
}
  , HE = n => rr(n[1]) ? [n[0], n[1], n[2] || {}] : [n[0], null, (n[1] === null ? n[2] : n[1]) || {}]
  , GE = () => wa(kE, $.useContext(Ag))
  , iR = (n, e) => {
    const [t,r] = hl(n)
      , [,,,s] = mr.get(ou);
    if (s[t])
        return s[t];
    const o = e(r);
    return s[t] = o,
    o
}
  , rR = n => (e, t, r) => n(e, t && ( (...o) => {
    const [u] = hl(e)
      , [,,,d] = mr.get(ou);
    if (u.startsWith(BE))
        return t(...o);
    const f = d[u];
    return Gt(f) ? t(...o) : (delete d[u],
    f)
}
), r)
  , aR = tR.concat(rR)
  , sR = n => function(...t) {
    const r = GE()
      , [s,o,u] = HE(t)
      , d = FE(r, u);
    let f = n;
    const {use: h} = d
      , m = (h || []).concat(aR);
    for (let g = m.length; g--; )
        f = m[g](f);
    return f(s, o || d.fetcher || null, d)
}
  , oR = (n, e, t) => {
    const r = e[n] || (e[n] = []);
    return r.push(t),
    () => {
        const s = r.indexOf(t);
        s >= 0 && (r[s] = r[r.length - 1],
        r.pop())
    }
}
  , lR = (n, e) => (...t) => {
    const [r,s,o] = HE(t)
      , u = (o.use || []).concat(e);
    return n(r, s, {
        ...o,
        use: u
    })
}
;
nR();
const cR = () => {}
  , uR = cR()
  , Rg = Object
  , fb = n => n === uR
  , dR = n => typeof n == "function"
  , Rd = new WeakMap
  , bm = (n, e) => Rg.prototype.toString.call(n) === `[object ${e}]`;
let fR = 0;
const Cg = n => {
    const e = typeof n
      , t = bm(n, "Date")
      , r = bm(n, "RegExp")
      , s = bm(n, "Object");
    let o, u;
    if (Rg(n) === n && !t && !r) {
        if (o = Rd.get(n),
        o)
            return o;
        if (o = ++fR + "~",
        Rd.set(n, o),
        Array.isArray(n)) {
            for (o = "@",
            u = 0; u < n.length; u++)
                o += Cg(n[u]) + ",";
            Rd.set(n, o)
        }
        if (s) {
            o = "#";
            const d = Rg.keys(n).sort();
            for (; !fb(u = d.pop()); )
                fb(n[u]) || (o += u + ":" + Cg(n[u]) + ",");
            Rd.set(n, o)
        }
    } else
        o = t ? n.toJSON() : e == "symbol" ? n.toString() : e == "string" ? JSON.stringify(n) : "" + n;
    return o
}
  , hR = n => {
    if (dR(n))
        try {
            n = n()
        } catch {
            n = ""
        }
    const e = n;
    return n = typeof n == "string" ? n : (Array.isArray(n) ? n.length : n) ? Cg(n) : "",
    [n, e]
}
  , pR = n => hR(n)[0]
  , Sm = K.use || (n => {
    switch (n.status) {
    case "pending":
        throw n;
    case "fulfilled":
        return n.value;
    case "rejected":
        throw n.reason;
    default:
        throw n.status = "pending",
        n.then(e => {
            n.status = "fulfilled",
            n.value = e
        }
        , e => {
            n.status = "rejected",
            n.reason = e
        }
        ),
        n
    }
}
)
  , Em = {
    dedupe: !0
}
  , mR = (n, e, t) => {
    const {cache: r, compare: s, suspense: o, fallbackData: u, revalidateOnMount: d, revalidateIfStale: f, refreshInterval: h, refreshWhenHidden: m, refreshWhenOffline: g, keepPreviousData: _} = t
      , [x,E,M,b] = mr.get(r)
      , [y,T] = hl(n)
      , D = $.useRef(!1)
      , C = $.useRef(!1)
      , P = $.useRef(y)
      , A = $.useRef(e)
      , F = $.useRef(t)
      , z = () => F.current
      , U = () => z().isVisible() && z().isOnline()
      , [R,V,Q,X] = ls(r, y)
      , oe = $.useRef({}).current
      , le = Gt(u) ? Gt(t.fallback) ? Qn : t.fallback[y] : u
      , O = (nt, G) => {
        for (const Zt in oe) {
            const ot = Zt;
            if (ot === "data") {
                if (!s(nt[ot], G[ot]) && (!Gt(nt[ot]) || !s(we, G[ot])))
                    return !1
            } else if (G[ot] !== nt[ot])
                return !1
        }
        return !0
    }
      , W = $.useMemo( () => {
        const nt = !y || !e ? !1 : Gt(d) ? z().isPaused() || o ? !1 : f !== !1 : d
          , G = Xe => {
            const B = wa(Xe);
            return delete B._k,
            nt ? {
                isValidating: !0,
                isLoading: !0,
                ...B
            } : B
        }
          , Zt = R()
          , ot = X()
          , it = G(Zt)
          , rt = Zt === ot ? it : G(ot);
        let pt = it;
        return [ () => {
            const Xe = G(R());
            return O(Xe, pt) ? (pt.data = Xe.data,
            pt.isLoading = Xe.isLoading,
            pt.isValidating = Xe.isValidating,
            pt.error = Xe.error,
            pt) : (pt = Xe,
            Xe)
        }
        , () => rt]
    }
    , [r, y])
      , H = DE.useSyncExternalStore($.useCallback(nt => Q(y, (G, Zt) => {
        O(Zt, G) || nt()
    }
    ), [r, y]), W[0], W[1])
      , Me = !D.current
      , k = x[y] && x[y].length > 0
      , ee = H.data
      , ge = Gt(ee) ? le && OE(le) ? Sm(le) : le : ee
      , pe = H.error
      , te = $.useRef(ge)
      , we = _ ? Gt(ee) ? Gt(te.current) ? ge : te.current : ee : ge
      , Se = k && !Gt(pe) ? !1 : Me && !Gt(d) ? d : z().isPaused() ? !1 : o ? Gt(ge) ? !1 : f : Gt(ge) || f
      , De = !!(y && e && Me && Se)
      , Ve = Gt(H.isValidating) ? De : H.isValidating
      , _t = Gt(H.isLoading) ? De : H.isLoading
      , He = $.useCallback(async nt => {
        const G = A.current;
        if (!y || !G || C.current || z().isPaused())
            return !1;
        let Zt, ot, it = !0;
        const rt = nt || {}
          , pt = !M[y] || !rt.dedupe
          , Xe = () => cb ? !C.current && y === P.current && D.current : y === P.current
          , B = {
            isValidating: !1,
            isLoading: !1
        }
          , S = () => {
            V(B)
        }
          , I = () => {
            const se = M[y];
            se && se[1] === ot && delete M[y]
        }
          , q = {
            isValidating: !0
        };
        Gt(R().data) && (q.isLoading = !0);
        try {
            if (pt && (V(q),
            t.loadingTimeout && Gt(R().data) && setTimeout( () => {
                it && Xe() && z().onLoadingSlow(y, t)
            }
            , t.loadingTimeout),
            M[y] = [G(T), Tg()]),
            [Zt,ot] = M[y],
            Zt = await Zt,
            pt && setTimeout(I, t.dedupingInterval),
            !M[y] || M[y][1] !== ot)
                return pt && Xe() && z().onDiscarded(y),
                !1;
            B.error = Qn;
            const se = E[y];
            if (!Gt(se) && (ot <= se[0] || ot <= se[1] || se[1] === 0))
                return S(),
                pt && Xe() && z().onDiscarded(y),
                !1;
            const J = R().data;
            B.data = s(J, Zt) ? J : Zt,
            pt && Xe() && z().onSuccess(Zt, y, t)
        } catch (se) {
            I();
            const J = z()
              , {shouldRetryOnError: de} = J;
            J.isPaused() || (B.error = se,
            pt && Xe() && (J.onError(se, y, J),
            (de === !0 || rr(de) && de(se)) && (!z().revalidateOnFocus || !z().revalidateOnReconnect || U()) && J.onErrorRetry(se, y, J, _e => {
                const Ae = x[y];
                Ae && Ae[0] && Ae[0](ob, _e)
            }
            , {
                retryCount: (rt.retryCount || 0) + 1,
                dedupe: !0
            })))
        }
        return it = !1,
        S(),
        !0
    }
    , [y, r])
      , Pt = $.useCallback( (...nt) => PE(r, P.current, ...nt), []);
    if (Hc( () => {
        A.current = e,
        F.current = t,
        Gt(ee) || (te.current = ee)
    }
    ),
    Hc( () => {
        if (!y)
            return;
        const nt = He.bind(Qn, Em);
        let G = 0;
        z().revalidateOnFocus && (G = Date.now() + z().focusThrottleInterval);
        const ot = oR(y, x, (it, rt={}) => {
            if (it == UE) {
                const pt = Date.now();
                z().revalidateOnFocus && pt > G && U() && (G = pt + z().focusThrottleInterval,
                nt())
            } else if (it == LE)
                z().revalidateOnReconnect && U() && nt();
            else {
                if (it == NE)
                    return He();
                if (it == ob)
                    return He(rt)
            }
        }
        );
        return C.current = !1,
        P.current = y,
        D.current = !0,
        V({
            _k: T
        }),
        Se && (Gt(ge) || Zc ? nt() : Z1(nt)),
        () => {
            C.current = !0,
            ot()
        }
    }
    , [y]),
    Hc( () => {
        let nt;
        function G() {
            const ot = rr(h) ? h(R().data) : h;
            ot && nt !== -1 && (nt = setTimeout(Zt, ot))
        }
        function Zt() {
            !R().error && (m || z().isVisible()) && (g || z().isOnline()) ? He(Em).then(G) : G()
        }
        return G(),
        () => {
            nt && (clearTimeout(nt),
            nt = -1)
        }
    }
    , [h, m, g, y]),
    $.useDebugValue(we),
    o && Gt(ge) && y) {
        if (!cb && Zc)
            throw new Error("Fallback data is required when using Suspense in SSR.");
        A.current = e,
        F.current = t,
        C.current = !1;
        const nt = b[y];
        if (!Gt(nt)) {
            const G = Pt(nt);
            Sm(G)
        }
        if (Gt(pe)) {
            const G = He(Em);
            Gt(we) || (G.status = "fulfilled",
            G.value = !0),
            Sm(G)
        } else
            throw pe
    }
    return {
        mutate: Pt,
        get data() {
            return oe.data = !0,
            we
        },
        get error() {
            return oe.error = !0,
            pe
        },
        get isValidating() {
            return oe.isValidating = !0,
            Ve
        },
        get isLoading() {
            return oe.isLoading = !0,
            _t
        }
    }
}
  , gR = xf.defineProperty(eR, "defaultValue", {
    value: kE
})
  , Gv = sR(mR)
  , vR = Object.freeze(Object.defineProperty({
    __proto__: null,
    SWRConfig: gR,
    default: Gv,
    mutate: zE,
    preload: iR,
    unstable_serialize: pR,
    useSWRConfig: GE
}, Symbol.toStringTag, {
    value: "Module"
}))
  , _R = () => {}
  , yR = _R()
  , Dg = Object
  , hb = n => n === yR
  , xR = n => typeof n == "function"
  , Cd = new WeakMap
  , Mm = (n, e) => Dg.prototype.toString.call(n) === `[object ${e}]`;
let bR = 0;
const Ug = n => {
    const e = typeof n
      , t = Mm(n, "Date")
      , r = Mm(n, "RegExp")
      , s = Mm(n, "Object");
    let o, u;
    if (Dg(n) === n && !t && !r) {
        if (o = Cd.get(n),
        o)
            return o;
        if (o = ++bR + "~",
        Cd.set(n, o),
        Array.isArray(n)) {
            for (o = "@",
            u = 0; u < n.length; u++)
                o += Ug(n[u]) + ",";
            Cd.set(n, o)
        }
        if (s) {
            o = "#";
            const d = Dg.keys(n).sort();
            for (; !hb(u = d.pop()); )
                hb(n[u]) || (o += u + ":" + Ug(n[u]) + ",");
            Cd.set(n, o)
        }
    } else
        o = t ? n.toJSON() : e == "symbol" ? n.toString() : e == "string" ? JSON.stringify(n) : "" + n;
    return o
}
  , SR = n => {
    if (xR(n))
        try {
            n = n()
        } catch {
            n = ""
        }
    const e = n;
    return n = typeof n == "string" ? n : (Array.isArray(n) ? n.length : n) ? Ug(n) : "",
    [n, e]
}
  , ER = n => SR(n ? n(0, null) : null)[0]
  , wm = Promise.resolve()
  , MR = n => (e, t, r) => {
    const s = $.useRef(!1)
      , {cache: o, initialSize: u=1, revalidateAll: d=!1, persistSize: f=!1, revalidateFirstPage: h=!0, revalidateOnMount: m=!1, parallel: g=!1} = r
      , [,,,_] = mr.get(ou);
    let x;
    try {
        x = ER(e),
        x && (x = BE + x)
    } catch {}
    const [E,M,b] = ls(o, x)
      , y = $.useCallback( () => Gt(E()._l) ? u : E()._l, [o, x, u]);
    DE.useSyncExternalStore($.useCallback(z => x ? b(x, () => {
        z()
    }
    ) : () => {}
    , [o, x]), y, y);
    const T = $.useCallback( () => {
        const z = E()._l;
        return Gt(z) ? u : z
    }
    , [x, u])
      , D = $.useRef(T());
    Hc( () => {
        if (!s.current) {
            s.current = !0;
            return
        }
        x && M({
            _l: f ? D.current : T()
        })
    }
    , [x, o]);
    const C = m && !s.current
      , P = n(x, async z => {
        const U = E()._i
          , R = E()._r;
        M({
            _r: Qn
        });
        const V = []
          , Q = T()
          , [X] = ls(o, z)
          , oe = X().data
          , le = [];
        let O = null;
        for (let W = 0; W < Q; ++W) {
            const [H,Me] = hl(e(W, g ? null : O));
            if (!H)
                break;
            const [k,ee] = ls(o, H);
            let ge = k().data;
            const pe = d || U || Gt(ge) || h && !W && !Gt(oe) || C || oe && !Gt(oe[W]) && !r.compare(oe[W], ge);
            if (t && (typeof R == "function" ? R(ge, Me) : pe)) {
                const te = async () => {
                    if (!(H in _))
                        ge = await t(Me);
                    else {
                        const Se = _[H];
                        delete _[H],
                        ge = await Se
                    }
                    ee({
                        data: ge,
                        _k: Me
                    }),
                    V[W] = ge
                }
                ;
                g ? le.push(te) : await te()
            } else
                V[W] = ge;
            g || (O = ge)
        }
        return g && await Promise.all(le.map(W => W())),
        M({
            _i: Qn
        }),
        V
    }
    , r)
      , A = $.useCallback(function(z, U) {
        const R = typeof U == "boolean" ? {
            revalidate: U
        } : U || {}
          , V = R.revalidate !== !1;
        return x ? (V && (Gt(z) ? M({
            _i: !0,
            _r: R.revalidate
        }) : M({
            _i: !1,
            _r: R.revalidate
        })),
        arguments.length ? P.mutate(z, {
            ...R,
            revalidate: V
        }) : P.mutate()) : wm
    }, [x, o])
      , F = $.useCallback(z => {
        if (!x)
            return wm;
        const [,U] = ls(o, x);
        let R;
        if (rr(z) ? R = z(T()) : typeof z == "number" && (R = z),
        typeof R != "number")
            return wm;
        U({
            _l: R
        }),
        D.current = R;
        const V = []
          , [Q] = ls(o, x);
        let X = null;
        for (let oe = 0; oe < R; ++oe) {
            const [le] = hl(e(oe, X))
              , [O] = ls(o, le)
              , W = le ? O().data : Qn;
            if (Gt(W))
                return A(Q().data);
            V.push(W),
            X = W
        }
        return A(V)
    }
    , [x, o, A, T]);
    return {
        size: T(),
        setSize: F,
        mutate: A,
        get data() {
            return P.data
        },
        get error() {
            return P.error
        },
        get isValidating() {
            return P.isValidating
        },
        get isLoading() {
            return P.isLoading
        }
    }
}
  , wR = lR(Gv, MR);
var pb = Object.prototype.hasOwnProperty;
function mb(n, e, t) {
    for (t of n.keys())
        if (Gc(t, e))
            return t
}
function Gc(n, e) {
    var t, r, s;
    if (n === e)
        return !0;
    if (n && e && (t = n.constructor) === e.constructor) {
        if (t === Date)
            return n.getTime() === e.getTime();
        if (t === RegExp)
            return n.toString() === e.toString();
        if (t === Array) {
            if ((r = n.length) === e.length)
                for (; r-- && Gc(n[r], e[r]); )
                    ;
            return r === -1
        }
        if (t === Set) {
            if (n.size !== e.size)
                return !1;
            for (r of n)
                if (s = r,
                s && typeof s == "object" && (s = mb(e, s),
                !s) || !e.has(s))
                    return !1;
            return !0
        }
        if (t === Map) {
            if (n.size !== e.size)
                return !1;
            for (r of n)
                if (s = r[0],
                s && typeof s == "object" && (s = mb(e, s),
                !s) || !Gc(r[1], e.get(s)))
                    return !1;
            return !0
        }
        if (t === ArrayBuffer)
            n = new Uint8Array(n),
            e = new Uint8Array(e);
        else if (t === DataView) {
            if ((r = n.byteLength) === e.byteLength)
                for (; r-- && n.getInt8(r) === e.getInt8(r); )
                    ;
            return r === -1
        }
        if (ArrayBuffer.isView(n)) {
            if ((r = n.byteLength) === e.byteLength)
                for (; r-- && n[r] === e[r]; )
                    ;
            return r === -1
        }
        if (!t || typeof n == "object") {
            r = 0;
            for (t in n)
                if (pb.call(n, t) && ++r && !pb.call(e, t) || !(t in e) || !Gc(n[t], e[t]))
                    return !1;
            return Object.keys(e).length === r
        }
    }
    return n !== n && e !== e
}
function TR(n, e) {
    if (!n)
        throw typeof e == "string" ? new Error(e) : new Error(`${e.displayName} not found`)
}
var El = (n, e) => {
    const {assertCtxFn: t=TR} = {}
      , r = K.createContext(void 0);
    return r.displayName = n,
    [r, () => {
        const u = K.useContext(r);
        return t(u, `${n} not found`),
        u.value
    }
    , () => {
        const u = K.useContext(r);
        return u ? u.value : {}
    }
    ]
}
  , jv = {};
y1(jv, {
    useSWR: () => Gv,
    useSWRInfinite: () => wR
});
b1(jv, vR);
var [jE,AR] = El("ClerkInstanceContext")
  , [RR,CR] = El("UserContext")
  , [DR,WE] = El("ClientContext")
  , [UR,eF] = El("SessionContext");
K.createContext({});
var [LR,tF] = El("OrganizationContext")
  , NR = ({children: n, organization: e, swrConfig: t}) => K.createElement(jv.SWRConfig, {
    value: t
}, K.createElement(LR.Provider, {
    value: {
        value: {
            organization: e
        }
    }
}, n));
function XE(n) {
    if (!K.useContext(jE)) {
        if (typeof n == "function") {
            n();
            return
        }
        throw new Error(`${n} can only be used within the <ClerkProvider /> component.

Possible fixes:
1. Ensure that the <ClerkProvider /> is correctly wrapping your application where this component is used.
2. Check for multiple versions of the \`@clerk/shared\` package in your project. Use a tool like \`npm ls @clerk/shared\` to identify multiple versions, and update your dependencies to only rely on one.

Learn more: https://clerk.com/docs/components/clerk-provider`.trim())
    }
}
typeof window < "u" ? K.useLayoutEffect : K.useEffect;
function qE() {
    XE("useUser");
    const n = CR();
    return n === void 0 ? {
        isLoaded: !1,
        isSignedIn: void 0,
        user: void 0
    } : n === null ? {
        isLoaded: !0,
        isSignedIn: !1,
        user: null
    } : {
        isLoaded: !0,
        isSignedIn: !0,
        user: n
    }
}
var gb = Gc
  , OR = () => {
    try {
        return !1
    } catch {}
    return !1
}
  , PR = () => {
    try {
        return !1
    } catch {}
    return !1
}
  , IR = () => {
    try {
        return !0
    } catch {}
    return !1
}
  , vb = new Set
  , Wv = (n, e, t) => {
    const r = PR() || IR()
      , s = n;
    vb.has(s) || r || (vb.add(s),
    console.warn(`Clerk - DEPRECATION WARNING: "${n}" is deprecated and will be removed in the next major release.
${e}`))
}
  , Nr = TE({
    packageName: "@clerk/clerk-react"
});
function zR(n) {
    Nr.setMessages(n).setPackageName(n)
}
var [kR,FR] = El("AuthContext")
  , BR = jE
  , Wf = AR
  , VR = "You've added multiple <ClerkProvider> components in your React component tree. Wrap your components in a single <ClerkProvider>."
  , HR = n => `You've passed multiple children components to <${n}/>. You can only pass a single child component or text.`
  , GR = "Invalid state. Feel free to submit a bug or reach out to support here: https://clerk.com/support"
  , Tm = "Unsupported usage of isSatellite, domain or proxyUrl. The usage of isSatellite, domain or proxyUrl as function is not supported in non-browser environments."
  , jR = "<UserProfile.Page /> component needs to be a direct child of `<UserProfile />` or `<UserButton />`."
  , WR = "<UserProfile.Link /> component needs to be a direct child of `<UserProfile />` or `<UserButton />`."
  , XR = "<OrganizationProfile.Page /> component needs to be a direct child of `<OrganizationProfile />` or `<OrganizationSwitcher />`."
  , qR = "<OrganizationProfile.Link /> component needs to be a direct child of `<OrganizationProfile />` or `<OrganizationSwitcher />`."
  , YR = n => `<${n} /> can only accept <${n}.Page /> and <${n}.Link /> as its children. Any other provided component will be ignored.`
  , ZR = n => `Missing props. <${n}.Page /> component requires the following props: url, label, labelIcon, alongside with children to be rendered inside the page.`
  , $R = n => `Missing props. <${n}.Link /> component requires the following props: url, label and labelIcon.`
  , KR = "<UserButton /> can only accept <UserButton.UserProfilePage />, <UserButton.UserProfileLink /> and <UserButton.MenuItems /> as its children. Any other provided component will be ignored."
  , QR = "<UserButton.MenuItems /> component can only accept <UserButton.Action /> and <UserButton.Link /> as its children. Any other provided component will be ignored."
  , JR = "<UserButton.MenuItems /> component needs to be a direct child of `<UserButton />`."
  , eC = "<UserButton.Action /> component needs to be a direct child of `<UserButton.MenuItems />`."
  , tC = "<UserButton.Link /> component needs to be a direct child of `<UserButton.MenuItems />`."
  , nC = "Missing props. <UserButton.Link /> component requires the following props: href, label and labelIcon."
  , iC = "Missing props. <UserButton.Action /> component requires the following props: label."
  , Xf = n => {
    XE( () => {
        Nr.throwMissingClerkProviderError({
            source: n
        })
    }
    )
}
  , YE = n => new Promise(e => {
    n.loaded && e(),
    n.addOnLoaded(e)
}
)
  , rC = n => async e => (await YE(n),
n.session ? n.session.getToken(e) : null)
  , aC = n => async (...e) => (await YE(n),
n.signOut(...e))
  , ZE = (n={}) => {
    var e, t;
    Xf("useAuth");
    const {treatPendingAsSignedOut: r, ...s} = n ?? {}
      , o = s;
    let d = FR();
    d.sessionId === void 0 && d.userId === void 0 && (d = o ?? {});
    const f = Wf()
      , h = $.useCallback(rC(f), [f])
      , m = $.useCallback(aC(f), [f]);
    return (e = f.telemetry) == null || e.record(Vv("useAuth", {
        treatPendingAsSignedOut: r
    })),
    sC({
        ...d,
        getToken: h,
        signOut: m
    }, {
        treatPendingAsSignedOut: r ?? ((t = f.__internal_getOption) == null ? void 0 : t.call(f, "treatPendingAsSignedOut"))
    })
}
;
function sC(n, {treatPendingAsSignedOut: e=!0}={}) {
    const {userId: t, orgId: r, orgRole: s, has: o, signOut: u, getToken: d, orgPermissions: f, factorVerificationAge: h, sessionClaims: m} = n ?? {}
      , g = $.useCallback(x => o ? o(x) : N1({
        userId: t,
        orgId: r,
        orgRole: s,
        orgPermissions: f,
        factorVerificationAge: h,
        features: (m == null ? void 0 : m.fea) || "",
        plans: (m == null ? void 0 : m.pla) || ""
    })(x), [o, t, r, s, f, h])
      , _ = O1({
        authObject: {
            ...n,
            getToken: d,
            signOut: u,
            has: g
        },
        options: {
            treatPendingAsSignedOut: e
        }
    });
    return _ || Nr.throw(GR)
}
var oC = () => {
    var n;
    Xf("useSignIn");
    const e = Wf()
      , t = WE();
    return (n = e.telemetry) == null || n.record(Vv("useSignIn")),
    t ? {
        isLoaded: !0,
        signIn: t.signIn,
        setActive: e.setActive
    } : {
        isLoaded: !1,
        signIn: void 0,
        setActive: void 0
    }
}
  , lC = () => {
    var n;
    Xf("useSignUp");
    const e = Wf()
      , t = WE();
    return (n = e.telemetry) == null || n.record(Vv("useSignUp")),
    t ? {
        isLoaded: !0,
        signUp: t.signUp,
        setActive: e.setActive
    } : {
        isLoaded: !1,
        signUp: void 0,
        setActive: void 0
    }
}
  , Xn = (n, e) => {
    const r = (typeof e == "string" ? e : e == null ? void 0 : e.component) || n.displayName || n.name || "Component";
    n.displayName = r;
    const s = typeof e == "string" ? void 0 : e
      , o = u => {
        Xf(r || "withClerk");
        const d = Wf();
        return !d.loaded && !(s != null && s.renderWhileLoading) ? null : K.createElement(n, {
            ...u,
            component: r,
            clerk: d
        })
    }
    ;
    return o.displayName = `withClerk(${r})`,
    o
}
;
Xn( ({clerk: n, ...e}) => {
    const {client: t, session: r} = n
      , s = t.signedInSessions ? t.signedInSessions.length > 0 : t.activeSessions && t.activeSessions.length > 0;
    return K.useEffect( () => {
        r === null && s ? n.redirectToAfterSignOut() : n.redirectToSignIn(e)
    }
    , []),
    null
}
, "RedirectToSignIn");
Xn( ({clerk: n, ...e}) => (K.useEffect( () => {
    n.redirectToSignUp(e)
}
, []),
null), "RedirectToSignUp");
Xn( ({clerk: n}) => (K.useEffect( () => {
    Wv("RedirectToUserProfile", "Use the `redirectToUserProfile()` method instead."),
    n.redirectToUserProfile()
}
, []),
null), "RedirectToUserProfile");
Xn( ({clerk: n}) => (K.useEffect( () => {
    Wv("RedirectToOrganizationProfile", "Use the `redirectToOrganizationProfile()` method instead."),
    n.redirectToOrganizationProfile()
}
, []),
null), "RedirectToOrganizationProfile");
Xn( ({clerk: n}) => (K.useEffect( () => {
    Wv("RedirectToCreateOrganization", "Use the `redirectToCreateOrganization()` method instead."),
    n.redirectToCreateOrganization()
}
, []),
null), "RedirectToCreateOrganization");
Xn( ({clerk: n, ...e}) => (K.useEffect( () => {
    n.handleRedirectCallback(e)
}
, []),
null), "AuthenticateWithRedirectCallback");
var $E = n => {
    throw TypeError(n)
}
  , Xv = (n, e, t) => e.has(n) || $E("Cannot " + t)
  , Be = (n, e, t) => (Xv(n, e, "read from private field"),
t ? t.call(n) : e.get(n))
  , il = (n, e, t) => e.has(n) ? $E("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t)
  , Bo = (n, e, t, r) => (Xv(n, e, "write to private field"),
e.set(n, t),
t)
  , _b = (n, e, t) => (Xv(n, e, "access private method"),
t);
function cC(n) {
    return n ? uC(n) || KE(n) : !0
}
function uC(n) {
    return /^http(s)?:\/\//.test(n || "")
}
function KE(n) {
    return n.startsWith("/")
}
function dC(n) {
    return n ? KE(n) ? new URL(n,window.location.origin).toString() : n : ""
}
function fC(n) {
    if (!n)
        return "";
    let e;
    if (n.match(/^(clerk\.)+\w*$/))
        e = /(clerk\.)*(?=clerk\.)/;
    else {
        if (n.match(/\.clerk.accounts/))
            return n;
        e = /^(clerk\.)*/gi
    }
    return `clerk.${n.replace(e, "")}`
}
var hC = (n, e="5.61.2") => {
    if (n)
        return n;
    const t = pC(e);
    return t ? t === "snapshot" ? "5.61.2" : t : mC(e)
}
  , pC = n => {
    var e;
    return (e = n.trim().replace(/^v/, "").match(/-(.+?)(\.|$)/)) == null ? void 0 : e[1]
}
  , mC = n => n.trim().replace(/^v/, "").split(".")[0]
  , gC = {
    initialDelay: 125,
    maxDelayBetweenRetries: 0,
    factor: 2,
    shouldRetry: (n, e) => e < 5,
    retryImmediately: !1,
    jitter: !0
}
  , vC = 100
  , QE = async n => new Promise(e => setTimeout(e, n))
  , JE = (n, e) => e ? n * (1 + Math.random()) : n
  , _C = n => {
    let e = 0;
    const t = () => {
        const r = n.initialDelay
          , s = n.factor;
        let o = r * Math.pow(s, e);
        return o = JE(o, n.jitter),
        Math.min(n.maxDelayBetweenRetries || o, o)
    }
    ;
    return async () => {
        await QE(t()),
        e++
    }
}
  , yC = async (n, e={}) => {
    let t = 0;
    const {shouldRetry: r, initialDelay: s, maxDelayBetweenRetries: o, factor: u, retryImmediately: d, jitter: f} = {
        ...gC,
        ...e
    }
      , h = _C({
        initialDelay: s,
        maxDelayBetweenRetries: o,
        factor: u,
        jitter: f
    });
    for (; ; )
        try {
            return await n()
        } catch (m) {
            if (t++,
            !r(m, t))
                throw m;
            d && t === 1 ? await QE(JE(vC, f)) : await h()
        }
}
  , xC = "loadScript cannot be called when document does not exist"
  , bC = "loadScript cannot be called without a src";
async function SC(n="", e) {
    const {async: t, defer: r, beforeLoad: s, crossOrigin: o, nonce: u} = e || {};
    return yC( () => new Promise( (f, h) => {
        n || h(new Error(bC)),
        (!document || !document.body) && h(xC);
        const m = document.createElement("script");
        o && m.setAttribute("crossorigin", o),
        m.async = t || !1,
        m.defer = r || !1,
        m.addEventListener("load", () => {
            m.remove(),
            f(m)
        }
        ),
        m.addEventListener("error", () => {
            m.remove(),
            h()
        }
        ),
        m.src = n,
        m.nonce = u,
        s == null || s(m),
        document.body.appendChild(m)
    }
    ), {
        shouldRetry: (f, h) => h <= 5
    })
}
var yb = "Clerk: Failed to load Clerk"
  , {isDevOrStagingUrl: EC} = z1()
  , eM = TE({
    packageName: "@clerk/shared"
});
function MC(n) {
    eM.setPackageName({
        packageName: n
    })
}
var wC = async n => {
    const e = document.querySelector("script[data-clerk-js-script]");
    if (e)
        return new Promise( (t, r) => {
            e.addEventListener("load", () => {
                t(e)
            }
            ),
            e.addEventListener("error", () => {
                r(yb)
            }
            )
        }
        );
    if (!(n != null && n.publishableKey)) {
        eM.throwMissingPublishableKeyError();
        return
    }
    return SC(TC(n), {
        async: !0,
        crossOrigin: "anonymous",
        nonce: n.nonce,
        beforeLoad: RC(n)
    }).catch( () => {
        throw new Error(yb)
    }
    )
}
  , TC = n => {
    var m, g;
    const {clerkJSUrl: e, clerkJSVariant: t, clerkJSVersion: r, proxyUrl: s, domain: o, publishableKey: u} = n;
    if (e)
        return e;
    let d = "";
    s && cC(s) ? d = dC(s).replace(/http(s)?:\/\//, "") : o && !EC(((m = rb(u)) == null ? void 0 : m.frontendApi) || "") ? d = fC(o) : d = ((g = rb(u)) == null ? void 0 : g.frontendApi) || "";
    const f = t ? `${t.replace(/\.+$/, "")}.` : ""
      , h = hC(r);
    return `https://${d}/npm/@clerk/clerk-js@${h}/dist/clerk.${f}browser.js`
}
  , AC = n => {
    const e = {};
    return n.publishableKey && (e["data-clerk-publishable-key"] = n.publishableKey),
    n.proxyUrl && (e["data-clerk-proxy-url"] = n.proxyUrl),
    n.domain && (e["data-clerk-domain"] = n.domain),
    n.nonce && (e.nonce = n.nonce),
    e
}
  , RC = n => e => {
    const t = AC(n);
    for (const r in t)
        e.setAttribute(r, t[r])
}
  , Mi = n => {
    OR() && console.error(`Clerk: ${n}`)
}
;
function Am(n, e, t) {
    if (typeof n == "function")
        return n(e);
    if (typeof n < "u")
        return n;
    if (typeof t < "u")
        return t
}
var tM = wE();
const CC = ME(tM);
var xb = (n, ...e) => {
    const t = {
        ...n
    };
    for (const r of e)
        delete t[r];
    return t
}
  , DC = (n, e, t) => !n && t ? UC(t) : LC(e)
  , UC = n => {
    const e = n.userId
      , t = n.user
      , r = n.sessionId
      , s = n.sessionStatus
      , o = n.sessionClaims
      , u = n.session
      , d = n.organization
      , f = n.orgId
      , h = n.orgRole
      , m = n.orgPermissions
      , g = n.orgSlug
      , _ = n.actor
      , x = n.factorVerificationAge;
    return {
        userId: e,
        user: t,
        sessionId: r,
        session: u,
        sessionStatus: s,
        sessionClaims: o,
        organization: d,
        orgId: f,
        orgRole: h,
        orgPermissions: m,
        orgSlug: g,
        actor: _,
        factorVerificationAge: x
    }
}
  , LC = n => {
    var M, b, y, T;
    const e = n.user ? n.user.id : n.user
      , t = n.user
      , r = n.session ? n.session.id : n.session
      , s = n.session
      , o = (M = n.session) == null ? void 0 : M.status
      , u = n.session ? (y = (b = n.session.lastActiveToken) == null ? void 0 : b.jwt) == null ? void 0 : y.claims : null
      , d = n.session ? n.session.factorVerificationAge : null
      , f = s == null ? void 0 : s.actor
      , h = n.organization
      , m = n.organization ? n.organization.id : n.organization
      , g = h == null ? void 0 : h.slug
      , _ = h && ((T = t == null ? void 0 : t.organizationMemberships) == null ? void 0 : T.find(D => D.organization.id === m))
      , x = _ && _.permissions
      , E = _ && _.role;
    return {
        userId: e,
        user: t,
        sessionId: r,
        session: s,
        sessionStatus: o,
        sessionClaims: u,
        organization: h,
        orgId: m,
        orgRole: E,
        orgSlug: g,
        orgPermissions: x,
        actor: f,
        factorVerificationAge: d
    }
}
;
function bb() {
    return typeof window < "u"
}
typeof window < "u" && !window.global && (window.global = typeof global > "u" ? window : global);
var qf = n => e => {
    try {
        return K.Children.only(n)
    } catch {
        return Nr.throw(HR(e))
    }
}
  , Yf = (n, e) => (n || (n = e),
typeof n == "string" && (n = K.createElement("button", null, n)),
n)
  , Zf = n => (...e) => {
    if (n && typeof n == "function")
        return n(...e)
}
;
function NC(n) {
    return typeof n == "function"
}
var Dd = new Map;
function OC(n, e, t=1) {
    K.useEffect( () => {
        const r = Dd.get(n) || 0;
        return r == t ? Nr.throw(e) : (Dd.set(n, r + 1),
        () => {
            Dd.set(n, (Dd.get(n) || 1) - 1)
        }
        )
    }
    , [])
}
function PC(n, e, t) {
    const r = n.displayName || n.name || e || "Component"
      , s = o => (OC(e, t),
    K.createElement(n, {
        ...o
    }));
    return s.displayName = `withMaxAllowedInstancesGuard(${r})`,
    s
}
var jc = n => {
    const e = Array(n.length).fill(null)
      , [t,r] = $.useState(e);
    return n.map( (s, o) => ({
        id: s.id,
        mount: u => r(d => d.map( (f, h) => h === o ? u : f)),
        unmount: () => r(u => u.map( (d, f) => f === o ? null : d)),
        portal: () => K.createElement(K.Fragment, null, t[o] ? tM.createPortal(s.component, t[o]) : null)
    }))
}
  , Si = (n, e) => !!n && K.isValidElement(n) && (n == null ? void 0 : n.type) === e
  , nM = (n, e) => aM({
    children: n,
    reorderItemsLabels: ["account", "security"],
    LinkComponent: cu,
    PageComponent: lu,
    MenuItemsComponent: Kf,
    componentName: "UserProfile"
}, e)
  , iM = (n, e) => aM({
    children: n,
    reorderItemsLabels: ["general", "members"],
    LinkComponent: Jf,
    PageComponent: Qf,
    componentName: "OrganizationProfile"
}, e)
  , rM = n => {
    const e = []
      , t = [Jf, Qf, Kf, lu, cu];
    return K.Children.forEach(n, r => {
        t.some(s => Si(r, s)) || e.push(r)
    }
    ),
    e
}
  , aM = (n, e) => {
    const {children: t, LinkComponent: r, PageComponent: s, MenuItemsComponent: o, reorderItemsLabels: u, componentName: d} = n
      , {allowForAnyChildren: f=!1} = e || {}
      , h = [];
    K.Children.forEach(t, T => {
        if (!Si(T, s) && !Si(T, r) && !Si(T, o)) {
            T && !f && Mi(YR(d));
            return
        }
        const {props: D} = T
          , {children: C, label: P, url: A, labelIcon: F} = D;
        if (Si(T, s))
            if (Sb(D, u))
                h.push({
                    label: P
                });
            else if (Rm(D))
                h.push({
                    label: P,
                    labelIcon: F,
                    children: C,
                    url: A
                });
            else {
                Mi(ZR(d));
                return
            }
        if (Si(T, r))
            if (Cm(D))
                h.push({
                    label: P,
                    labelIcon: F,
                    url: A
                });
            else {
                Mi($R(d));
                return
            }
    }
    );
    const m = []
      , g = []
      , _ = [];
    h.forEach( (T, D) => {
        if (Rm(T)) {
            m.push({
                component: T.children,
                id: D
            }),
            g.push({
                component: T.labelIcon,
                id: D
            });
            return
        }
        Cm(T) && _.push({
            component: T.labelIcon,
            id: D
        })
    }
    );
    const x = jc(m)
      , E = jc(g)
      , M = jc(_)
      , b = []
      , y = [];
    return h.forEach( (T, D) => {
        if (Sb(T, u)) {
            b.push({
                label: T.label
            });
            return
        }
        if (Rm(T)) {
            const {portal: C, mount: P, unmount: A} = x.find(R => R.id === D)
              , {portal: F, mount: z, unmount: U} = E.find(R => R.id === D);
            b.push({
                label: T.label,
                url: T.url,
                mount: P,
                unmount: A,
                mountIcon: z,
                unmountIcon: U
            }),
            y.push(C),
            y.push(F);
            return
        }
        if (Cm(T)) {
            const {portal: C, mount: P, unmount: A} = M.find(F => F.id === D);
            b.push({
                label: T.label,
                url: T.url,
                mountIcon: P,
                unmountIcon: A
            }),
            y.push(C);
            return
        }
    }
    ),
    {
        customPages: b,
        customPagesPortals: y
    }
}
  , Sb = (n, e) => {
    const {children: t, label: r, url: s, labelIcon: o} = n;
    return !t && !s && !o && e.some(u => u === r)
}
  , Rm = n => {
    const {children: e, label: t, url: r, labelIcon: s} = n;
    return !!e && !!r && !!s && !!t
}
  , Cm = n => {
    const {children: e, label: t, url: r, labelIcon: s} = n;
    return !e && !!r && !!s && !!t
}
  , IC = n => zC({
    children: n,
    reorderItemsLabels: ["manageAccount", "signOut"],
    MenuItemsComponent: Kf,
    MenuActionComponent: oM,
    MenuLinkComponent: lM,
    UserProfileLinkComponent: cu,
    UserProfilePageComponent: lu
})
  , zC = ({children: n, MenuItemsComponent: e, MenuActionComponent: t, MenuLinkComponent: r, UserProfileLinkComponent: s, UserProfilePageComponent: o, reorderItemsLabels: u}) => {
    const d = []
      , f = []
      , h = [];
    K.Children.forEach(n, E => {
        if (!Si(E, e) && !Si(E, s) && !Si(E, o)) {
            E && Mi(KR);
            return
        }
        if (Si(E, s) || Si(E, o))
            return;
        const {props: M} = E;
        K.Children.forEach(M.children, b => {
            if (!Si(b, t) && !Si(b, r)) {
                b && Mi(QR);
                return
            }
            const {props: y} = b
              , {label: T, labelIcon: D, href: C, onClick: P, open: A} = y;
            if (Si(b, t))
                if (Eb(y, u))
                    d.push({
                        label: T
                    });
                else if (Dm(y)) {
                    const F = {
                        label: T,
                        labelIcon: D
                    };
                    if (P !== void 0)
                        d.push({
                            ...F,
                            onClick: P
                        });
                    else if (A !== void 0)
                        d.push({
                            ...F,
                            open: A.startsWith("/") ? A : `/${A}`
                        });
                    else {
                        Mi("Custom menu item must have either onClick or open property");
                        return
                    }
                } else {
                    Mi(iC);
                    return
                }
            if (Si(b, r))
                if (Um(y))
                    d.push({
                        label: T,
                        labelIcon: D,
                        href: C
                    });
                else {
                    Mi(nC);
                    return
                }
        }
        )
    }
    );
    const m = []
      , g = [];
    d.forEach( (E, M) => {
        Dm(E) && m.push({
            component: E.labelIcon,
            id: M
        }),
        Um(E) && g.push({
            component: E.labelIcon,
            id: M
        })
    }
    );
    const _ = jc(m)
      , x = jc(g);
    return d.forEach( (E, M) => {
        if (Eb(E, u) && f.push({
            label: E.label
        }),
        Dm(E)) {
            const {portal: b, mount: y, unmount: T} = _.find(C => C.id === M)
              , D = {
                label: E.label,
                mountIcon: y,
                unmountIcon: T
            };
            "onClick"in E ? D.onClick = E.onClick : "open"in E && (D.open = E.open),
            f.push(D),
            h.push(b)
        }
        if (Um(E)) {
            const {portal: b, mount: y, unmount: T} = x.find(D => D.id === M);
            f.push({
                label: E.label,
                href: E.href,
                mountIcon: y,
                unmountIcon: T
            }),
            h.push(b)
        }
    }
    ),
    {
        customMenuItems: f,
        customMenuItemsPortals: h
    }
}
  , Eb = (n, e) => {
    const {children: t, label: r, onClick: s, labelIcon: o} = n;
    return !t && !s && !o && e.some(u => u === r)
}
  , Dm = n => {
    const {label: e, labelIcon: t, onClick: r, open: s} = n;
    return !!t && !!e && (typeof r == "function" || typeof s == "string")
}
  , Um = n => {
    const {label: e, href: t, labelIcon: r} = n;
    return !!t && !!r && !!e
}
;
function kC(n) {
    const {root: e=document == null ? void 0 : document.body, selector: t, timeout: r=0} = n;
    return new Promise( (s, o) => {
        if (!e) {
            o(new Error("No root element provided"));
            return
        }
        let u = e;
        if (t && (u = e == null ? void 0 : e.querySelector(t)),
        (u == null ? void 0 : u.childElementCount) && u.childElementCount > 0) {
            s();
            return
        }
        const f = new MutationObserver(h => {
            for (const m of h)
                if (m.type === "childList" && (!u && t && (u = e == null ? void 0 : e.querySelector(t)),
                u != null && u.childElementCount && u.childElementCount > 0)) {
                    f.disconnect(),
                    s();
                    return
                }
        }
        );
        f.observe(e, {
            childList: !0,
            subtree: !0
        }),
        r > 0 && setTimeout( () => {
            f.disconnect(),
            o(new Error("Timeout waiting for element children"))
        }
        , r)
    }
    )
}
function kr(n) {
    const e = $.useRef()
      , [t,r] = $.useState("rendering");
    return $.useEffect( () => {
        if (!n)
            throw new Error("Clerk: no component name provided, unable to detect mount.");
        typeof window < "u" && !e.current && (e.current = kC({
            selector: `[data-clerk-component="${n}"]`
        }).then( () => {
            r("rendered")
        }
        ).catch( () => {
            r("error")
        }
        ))
    }
    , [n]),
    t
}
var Ud = n => "mount"in n
  , Mb = n => "open"in n
  , wb = n => n == null ? void 0 : n.map( ({mountIcon: e, unmountIcon: t, ...r}) => r)
  , lr = class extends K.PureComponent {
    constructor() {
        super(...arguments),
        this.rootRef = K.createRef()
    }
    componentDidUpdate(n) {
        var e, t, r, s;
        if (!Ud(n) || !Ud(this.props))
            return;
        const o = xb(n.props, "customPages", "customMenuItems", "children")
          , u = xb(this.props.props, "customPages", "customMenuItems", "children")
          , d = ((e = o.customPages) == null ? void 0 : e.length) !== ((t = u.customPages) == null ? void 0 : t.length)
          , f = ((r = o.customMenuItems) == null ? void 0 : r.length) !== ((s = u.customMenuItems) == null ? void 0 : s.length)
          , h = wb(n.props.customMenuItems)
          , m = wb(this.props.props.customMenuItems);
        (!gb(o, u) || !gb(h, m) || d || f) && this.rootRef.current && this.props.updateProps({
            node: this.rootRef.current,
            props: this.props.props
        })
    }
    componentDidMount() {
        this.rootRef.current && (Ud(this.props) && this.props.mount(this.rootRef.current, this.props.props),
        Mb(this.props) && this.props.open(this.props.props))
    }
    componentWillUnmount() {
        this.rootRef.current && (Ud(this.props) && this.props.unmount(this.rootRef.current),
        Mb(this.props) && this.props.close())
    }
    render() {
        const {hideRootHtmlElement: n=!1} = this.props
          , e = {
            ref: this.rootRef,
            ...this.props.rootProps,
            ...this.props.component && {
                "data-clerk-component": this.props.component
            }
        };
        return K.createElement(K.Fragment, null, !n && K.createElement("div", {
            ...e
        }), this.props.children)
    }
}
  , $f = n => {
    var e, t;
    return K.createElement(K.Fragment, null, (e = n == null ? void 0 : n.customPagesPortals) == null ? void 0 : e.map( (r, s) => $.createElement(r, {
        key: s
    })), (t = n == null ? void 0 : n.customMenuItemsPortals) == null ? void 0 : t.map( (r, s) => $.createElement(r, {
        key: s
    })))
}
;
Xn( ({clerk: n, component: e, fallback: t, ...r}) => {
    const o = kr(e) === "rendering" || !n.loaded
      , u = {
        ...o && t && {
            style: {
                display: "none"
            }
        }
    };
    return K.createElement(K.Fragment, null, o && t, n.loaded && K.createElement(lr, {
        component: e,
        mount: n.mountSignIn,
        unmount: n.unmountSignIn,
        updateProps: n.__unstable__updateProps,
        props: r,
        rootProps: u
    }))
}
, {
    component: "SignIn",
    renderWhileLoading: !0
});
Xn( ({clerk: n, component: e, fallback: t, ...r}) => {
    const o = kr(e) === "rendering" || !n.loaded
      , u = {
        ...o && t && {
            style: {
                display: "none"
            }
        }
    };
    return K.createElement(K.Fragment, null, o && t, n.loaded && K.createElement(lr, {
        component: e,
        mount: n.mountSignUp,
        unmount: n.unmountSignUp,
        updateProps: n.__unstable__updateProps,
        props: r,
        rootProps: u
    }))
}
, {
    component: "SignUp",
    renderWhileLoading: !0
});
function lu({children: n}) {
    return Mi(jR),
    K.createElement(K.Fragment, null, n)
}
function cu({children: n}) {
    return Mi(WR),
    K.createElement(K.Fragment, null, n)
}
var FC = Xn( ({clerk: n, component: e, fallback: t, ...r}) => {
    const o = kr(e) === "rendering" || !n.loaded
      , u = {
        ...o && t && {
            style: {
                display: "none"
            }
        }
    }
      , {customPages: d, customPagesPortals: f} = nM(r.children);
    return K.createElement(K.Fragment, null, o && t, K.createElement(lr, {
        component: e,
        mount: n.mountUserProfile,
        unmount: n.unmountUserProfile,
        updateProps: n.__unstable__updateProps,
        props: {
            ...r,
            customPages: d
        },
        rootProps: u
    }, K.createElement($f, {
        customPagesPortals: f
    })))
}
, {
    component: "UserProfile",
    renderWhileLoading: !0
});
Object.assign(FC, {
    Page: lu,
    Link: cu
});
var sM = $.createContext({
    mount: () => {}
    ,
    unmount: () => {}
    ,
    updateProps: () => {}
})
  , BC = Xn( ({clerk: n, component: e, fallback: t, ...r}) => {
    const o = kr(e) === "rendering" || !n.loaded
      , u = {
        ...o && t && {
            style: {
                display: "none"
            }
        }
    }
      , {customPages: d, customPagesPortals: f} = nM(r.children, {
        allowForAnyChildren: !!r.__experimental_asProvider
    })
      , h = Object.assign(r.userProfileProps || {}, {
        customPages: d
    })
      , {customMenuItems: m, customMenuItemsPortals: g} = IC(r.children)
      , _ = rM(r.children)
      , x = {
        mount: n.mountUserButton,
        unmount: n.unmountUserButton,
        updateProps: n.__unstable__updateProps,
        props: {
            ...r,
            userProfileProps: h,
            customMenuItems: m
        }
    }
      , E = {
        customPagesPortals: f,
        customMenuItemsPortals: g
    };
    return K.createElement(sM.Provider, {
        value: x
    }, o && t, n.loaded && K.createElement(lr, {
        component: e,
        ...x,
        hideRootHtmlElement: !!r.__experimental_asProvider,
        rootProps: u
    }, r.__experimental_asProvider ? _ : null, K.createElement($f, {
        ...E
    })))
}
, {
    component: "UserButton",
    renderWhileLoading: !0
});
function Kf({children: n}) {
    return Mi(JR),
    K.createElement(K.Fragment, null, n)
}
function oM({children: n}) {
    return Mi(eC),
    K.createElement(K.Fragment, null, n)
}
function lM({children: n}) {
    return Mi(tC),
    K.createElement(K.Fragment, null, n)
}
function VC(n) {
    const e = $.useContext(sM)
      , t = {
        ...e,
        props: {
            ...e.props,
            ...n
        }
    };
    return K.createElement(lr, {
        ...t
    })
}
var HC = Object.assign(BC, {
    UserProfilePage: lu,
    UserProfileLink: cu,
    MenuItems: Kf,
    Action: oM,
    Link: lM,
    __experimental_Outlet: VC
});
function Qf({children: n}) {
    return Mi(XR),
    K.createElement(K.Fragment, null, n)
}
function Jf({children: n}) {
    return Mi(qR),
    K.createElement(K.Fragment, null, n)
}
var GC = Xn( ({clerk: n, component: e, fallback: t, ...r}) => {
    const o = kr(e) === "rendering" || !n.loaded
      , u = {
        ...o && t && {
            style: {
                display: "none"
            }
        }
    }
      , {customPages: d, customPagesPortals: f} = iM(r.children);
    return K.createElement(K.Fragment, null, o && t, n.loaded && K.createElement(lr, {
        component: e,
        mount: n.mountOrganizationProfile,
        unmount: n.unmountOrganizationProfile,
        updateProps: n.__unstable__updateProps,
        props: {
            ...r,
            customPages: d
        },
        rootProps: u
    }, K.createElement($f, {
        customPagesPortals: f
    })))
}
, {
    component: "OrganizationProfile",
    renderWhileLoading: !0
});
Object.assign(GC, {
    Page: Qf,
    Link: Jf
});
Xn( ({clerk: n, component: e, fallback: t, ...r}) => {
    const o = kr(e) === "rendering" || !n.loaded
      , u = {
        ...o && t && {
            style: {
                display: "none"
            }
        }
    };
    return K.createElement(K.Fragment, null, o && t, n.loaded && K.createElement(lr, {
        component: e,
        mount: n.mountCreateOrganization,
        unmount: n.unmountCreateOrganization,
        updateProps: n.__unstable__updateProps,
        props: r,
        rootProps: u
    }))
}
, {
    component: "CreateOrganization",
    renderWhileLoading: !0
});
var cM = $.createContext({
    mount: () => {}
    ,
    unmount: () => {}
    ,
    updateProps: () => {}
})
  , jC = Xn( ({clerk: n, component: e, fallback: t, ...r}) => {
    const o = kr(e) === "rendering" || !n.loaded
      , u = {
        ...o && t && {
            style: {
                display: "none"
            }
        }
    }
      , {customPages: d, customPagesPortals: f} = iM(r.children, {
        allowForAnyChildren: !!r.__experimental_asProvider
    })
      , h = Object.assign(r.organizationProfileProps || {}, {
        customPages: d
    })
      , m = rM(r.children)
      , g = {
        mount: n.mountOrganizationSwitcher,
        unmount: n.unmountOrganizationSwitcher,
        updateProps: n.__unstable__updateProps,
        props: {
            ...r,
            organizationProfileProps: h
        },
        rootProps: u,
        component: e
    };
    return n.__experimental_prefetchOrganizationSwitcher(),
    K.createElement(cM.Provider, {
        value: g
    }, K.createElement(K.Fragment, null, o && t, n.loaded && K.createElement(lr, {
        ...g,
        hideRootHtmlElement: !!r.__experimental_asProvider
    }, r.__experimental_asProvider ? m : null, K.createElement($f, {
        customPagesPortals: f
    }))))
}
, {
    component: "OrganizationSwitcher",
    renderWhileLoading: !0
});
function WC(n) {
    const e = $.useContext(cM)
      , t = {
        ...e,
        props: {
            ...e.props,
            ...n
        }
    };
    return K.createElement(lr, {
        ...t
    })
}
Object.assign(jC, {
    OrganizationProfilePage: Qf,
    OrganizationProfileLink: Jf,
    __experimental_Outlet: WC
});
Xn( ({clerk: n, component: e, fallback: t, ...r}) => {
    const o = kr(e) === "rendering" || !n.loaded
      , u = {
        ...o && t && {
            style: {
                display: "none"
            }
        }
    };
    return K.createElement(K.Fragment, null, o && t, n.loaded && K.createElement(lr, {
        component: e,
        mount: n.mountOrganizationList,
        unmount: n.unmountOrganizationList,
        updateProps: n.__unstable__updateProps,
        props: r,
        rootProps: u
    }))
}
, {
    component: "OrganizationList",
    renderWhileLoading: !0
});
Xn( ({clerk: n, component: e, fallback: t, ...r}) => {
    const o = kr(e) === "rendering" || !n.loaded
      , u = {
        ...o && t && {
            style: {
                display: "none"
            }
        }
    };
    return K.createElement(K.Fragment, null, o && t, n.loaded && K.createElement(lr, {
        component: e,
        open: n.openGoogleOneTap,
        close: n.closeGoogleOneTap,
        updateProps: n.__unstable__updateProps,
        props: r,
        rootProps: u
    }))
}
, {
    component: "GoogleOneTap",
    renderWhileLoading: !0
});
Xn( ({clerk: n, component: e, fallback: t, ...r}) => {
    const o = kr(e) === "rendering" || !n.loaded
      , u = {
        ...o && t && {
            style: {
                display: "none"
            }
        }
    };
    return K.createElement(K.Fragment, null, o && t, n.loaded && K.createElement(lr, {
        component: e,
        mount: n.mountWaitlist,
        unmount: n.unmountWaitlist,
        updateProps: n.__unstable__updateProps,
        props: r,
        rootProps: u
    }))
}
, {
    component: "Waitlist",
    renderWhileLoading: !0
});
Xn( ({clerk: n, children: e, ...t}) => {
    const {signUpFallbackRedirectUrl: r, forceRedirectUrl: s, fallbackRedirectUrl: o, signUpForceRedirectUrl: u, mode: d, initialValues: f, withSignUp: h, oauthFlow: m, ...g} = t;
    e = Yf(e, "Sign in");
    const _ = qf(e)("SignInButton")
      , x = () => {
        const b = {
            forceRedirectUrl: s,
            fallbackRedirectUrl: o,
            signUpFallbackRedirectUrl: r,
            signUpForceRedirectUrl: u,
            initialValues: f,
            withSignUp: h,
            oauthFlow: m
        };
        return d === "modal" ? n.openSignIn({
            ...b,
            appearance: t.appearance
        }) : n.redirectToSignIn({
            ...b,
            signInFallbackRedirectUrl: o,
            signInForceRedirectUrl: s
        })
    }
      , M = {
        ...g,
        onClick: async b => (_ && typeof _ == "object" && "props"in _ && await Zf(_.props.onClick)(b),
        x())
    };
    return K.cloneElement(_, M)
}
, {
    component: "SignInButton",
    renderWhileLoading: !0
});
Xn( ({clerk: n, children: e, ...t}) => {
    const {fallbackRedirectUrl: r, forceRedirectUrl: s, signInFallbackRedirectUrl: o, signInForceRedirectUrl: u, mode: d, unsafeMetadata: f, initialValues: h, oauthFlow: m, ...g} = t;
    e = Yf(e, "Sign up");
    const _ = qf(e)("SignUpButton")
      , x = () => {
        const b = {
            fallbackRedirectUrl: r,
            forceRedirectUrl: s,
            signInFallbackRedirectUrl: o,
            signInForceRedirectUrl: u,
            unsafeMetadata: f,
            initialValues: h,
            oauthFlow: m
        };
        return d === "modal" ? n.openSignUp({
            ...b,
            appearance: t.appearance
        }) : n.redirectToSignUp({
            ...b,
            signUpFallbackRedirectUrl: r,
            signUpForceRedirectUrl: s
        })
    }
      , M = {
        ...g,
        onClick: async b => (_ && typeof _ == "object" && "props"in _ && await Zf(_.props.onClick)(b),
        x())
    };
    return K.cloneElement(_, M)
}
, {
    component: "SignUpButton",
    renderWhileLoading: !0
});
Xn( ({clerk: n, children: e, ...t}) => {
    const {redirectUrl: r="/", signOutOptions: s, ...o} = t;
    e = Yf(e, "Sign out");
    const u = qf(e)("SignOutButton")
      , d = () => n.signOut({
        redirectUrl: r,
        ...s
    })
      , h = {
        ...o,
        onClick: async m => (await Zf(u.props.onClick)(m),
        d())
    };
    return K.cloneElement(u, h)
}
, {
    component: "SignOutButton",
    renderWhileLoading: !0
});
Xn( ({clerk: n, children: e, ...t}) => {
    const {redirectUrl: r, ...s} = t;
    e = Yf(e, "Sign in with Metamask");
    const o = qf(e)("SignInWithMetamaskButton")
      , u = async () => {
        async function h() {
            await n.authenticateWithMetamask({
                redirectUrl: r || void 0
            })
        }
        h()
    }
      , f = {
        ...s,
        onClick: async h => (await Zf(o.props.onClick)(h),
        u())
    };
    return K.cloneElement(o, f)
}
, {
    component: "SignInWithMetamask",
    renderWhileLoading: !0
});
typeof globalThis.__BUILD_DISABLE_RHC__ > "u" && (globalThis.__BUILD_DISABLE_RHC__ = !1);
var XC = {
    name: "@clerk/clerk-react",
    version: "5.28.2",
    environment: "production"
}, Ze, rl, al, ss, cs, lf, Lg, uM = class dM {
    constructor(e) {
        il(this, lf),
        this.clerkjs = null,
        this.preopenOneTap = null,
        this.preopenUserVerification = null,
        this.preopenSignIn = null,
        this.preopenCheckout = null,
        this.preopenSignUp = null,
        this.preopenUserProfile = null,
        this.preopenOrganizationProfile = null,
        this.preopenCreateOrganization = null,
        this.preOpenWaitlist = null,
        this.premountSignInNodes = new Map,
        this.premountSignUpNodes = new Map,
        this.premountUserProfileNodes = new Map,
        this.premountUserButtonNodes = new Map,
        this.premountOrganizationProfileNodes = new Map,
        this.premountCreateOrganizationNodes = new Map,
        this.premountOrganizationSwitcherNodes = new Map,
        this.premountOrganizationListNodes = new Map,
        this.premountMethodCalls = new Map,
        this.premountWaitlistNodes = new Map,
        this.premountPricingTableNodes = new Map,
        this.premountAddListenerCalls = new Map,
        this.loadedListeners = [],
        il(this, Ze, !1),
        il(this, rl),
        il(this, al),
        il(this, ss),
        this.buildSignInUrl = s => {
            const o = () => {
                var u;
                return ((u = this.clerkjs) == null ? void 0 : u.buildSignInUrl(s)) || ""
            }
            ;
            if (this.clerkjs && Be(this, Ze))
                return o();
            this.premountMethodCalls.set("buildSignInUrl", o)
        }
        ,
        this.buildSignUpUrl = s => {
            const o = () => {
                var u;
                return ((u = this.clerkjs) == null ? void 0 : u.buildSignUpUrl(s)) || ""
            }
            ;
            if (this.clerkjs && Be(this, Ze))
                return o();
            this.premountMethodCalls.set("buildSignUpUrl", o)
        }
        ,
        this.buildAfterSignInUrl = (...s) => {
            const o = () => {
                var u;
                return ((u = this.clerkjs) == null ? void 0 : u.buildAfterSignInUrl(...s)) || ""
            }
            ;
            if (this.clerkjs && Be(this, Ze))
                return o();
            this.premountMethodCalls.set("buildAfterSignInUrl", o)
        }
        ,
        this.buildAfterSignUpUrl = (...s) => {
            const o = () => {
                var u;
                return ((u = this.clerkjs) == null ? void 0 : u.buildAfterSignUpUrl(...s)) || ""
            }
            ;
            if (this.clerkjs && Be(this, Ze))
                return o();
            this.premountMethodCalls.set("buildAfterSignUpUrl", o)
        }
        ,
        this.buildAfterSignOutUrl = () => {
            const s = () => {
                var o;
                return ((o = this.clerkjs) == null ? void 0 : o.buildAfterSignOutUrl()) || ""
            }
            ;
            if (this.clerkjs && Be(this, Ze))
                return s();
            this.premountMethodCalls.set("buildAfterSignOutUrl", s)
        }
        ,
        this.buildAfterMultiSessionSingleSignOutUrl = () => {
            const s = () => {
                var o;
                return ((o = this.clerkjs) == null ? void 0 : o.buildAfterMultiSessionSingleSignOutUrl()) || ""
            }
            ;
            if (this.clerkjs && Be(this, Ze))
                return s();
            this.premountMethodCalls.set("buildAfterMultiSessionSingleSignOutUrl", s)
        }
        ,
        this.buildUserProfileUrl = () => {
            const s = () => {
                var o;
                return ((o = this.clerkjs) == null ? void 0 : o.buildUserProfileUrl()) || ""
            }
            ;
            if (this.clerkjs && Be(this, Ze))
                return s();
            this.premountMethodCalls.set("buildUserProfileUrl", s)
        }
        ,
        this.buildCreateOrganizationUrl = () => {
            const s = () => {
                var o;
                return ((o = this.clerkjs) == null ? void 0 : o.buildCreateOrganizationUrl()) || ""
            }
            ;
            if (this.clerkjs && Be(this, Ze))
                return s();
            this.premountMethodCalls.set("buildCreateOrganizationUrl", s)
        }
        ,
        this.buildOrganizationProfileUrl = () => {
            const s = () => {
                var o;
                return ((o = this.clerkjs) == null ? void 0 : o.buildOrganizationProfileUrl()) || ""
            }
            ;
            if (this.clerkjs && Be(this, Ze))
                return s();
            this.premountMethodCalls.set("buildOrganizationProfileUrl", s)
        }
        ,
        this.buildWaitlistUrl = () => {
            const s = () => {
                var o;
                return ((o = this.clerkjs) == null ? void 0 : o.buildWaitlistUrl()) || ""
            }
            ;
            if (this.clerkjs && Be(this, Ze))
                return s();
            this.premountMethodCalls.set("buildWaitlistUrl", s)
        }
        ,
        this.buildUrlWithAuth = s => {
            const o = () => {
                var u;
                return ((u = this.clerkjs) == null ? void 0 : u.buildUrlWithAuth(s)) || ""
            }
            ;
            if (this.clerkjs && Be(this, Ze))
                return o();
            this.premountMethodCalls.set("buildUrlWithAuth", o)
        }
        ,
        this.handleUnauthenticated = async () => {
            const s = () => {
                var o;
                return (o = this.clerkjs) == null ? void 0 : o.handleUnauthenticated()
            }
            ;
            this.clerkjs && Be(this, Ze) ? s() : this.premountMethodCalls.set("handleUnauthenticated", s)
        }
        ,
        this.addOnLoaded = s => {
            this.loadedListeners.push(s),
            this.loaded && this.emitLoaded()
        }
        ,
        this.emitLoaded = () => {
            this.loadedListeners.forEach(s => s()),
            this.loadedListeners = []
        }
        ,
        this.hydrateClerkJS = s => {
            if (!s)
                throw new Error("Failed to hydrate latest Clerk JS");
            return this.clerkjs = s,
            this.premountMethodCalls.forEach(o => o()),
            this.premountAddListenerCalls.forEach( (o, u) => {
                o.nativeUnsubscribe = s.addListener(u)
            }
            ),
            this.preopenSignIn !== null && s.openSignIn(this.preopenSignIn),
            this.preopenCheckout !== null && s.__internal_openCheckout(this.preopenCheckout),
            this.preopenSignUp !== null && s.openSignUp(this.preopenSignUp),
            this.preopenUserProfile !== null && s.openUserProfile(this.preopenUserProfile),
            this.preopenUserVerification !== null && s.__internal_openReverification(this.preopenUserVerification),
            this.preopenOneTap !== null && s.openGoogleOneTap(this.preopenOneTap),
            this.preopenOrganizationProfile !== null && s.openOrganizationProfile(this.preopenOrganizationProfile),
            this.preopenCreateOrganization !== null && s.openCreateOrganization(this.preopenCreateOrganization),
            this.preOpenWaitlist !== null && s.openWaitlist(this.preOpenWaitlist),
            this.premountSignInNodes.forEach( (o, u) => {
                s.mountSignIn(u, o)
            }
            ),
            this.premountSignUpNodes.forEach( (o, u) => {
                s.mountSignUp(u, o)
            }
            ),
            this.premountUserProfileNodes.forEach( (o, u) => {
                s.mountUserProfile(u, o)
            }
            ),
            this.premountUserButtonNodes.forEach( (o, u) => {
                s.mountUserButton(u, o)
            }
            ),
            this.premountOrganizationListNodes.forEach( (o, u) => {
                s.mountOrganizationList(u, o)
            }
            ),
            this.premountWaitlistNodes.forEach( (o, u) => {
                s.mountWaitlist(u, o)
            }
            ),
            this.premountPricingTableNodes.forEach( (o, u) => {
                s.__experimental_mountPricingTable(u, o)
            }
            ),
            Bo(this, Ze, !0),
            this.emitLoaded(),
            this.clerkjs
        }
        ,
        this.__unstable__updateProps = async s => {
            const o = await _b(this, lf, Lg).call(this);
            if (o && "__unstable__updateProps"in o)
                return o.__unstable__updateProps(s)
        }
        ,
        this.__experimental_nextTask = async s => this.clerkjs ? this.clerkjs.__experimental_nextTask(s) : Promise.reject(),
        this.setActive = s => this.clerkjs ? this.clerkjs.setActive(s) : Promise.reject(),
        this.openSignIn = s => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.openSignIn(s) : this.preopenSignIn = s
        }
        ,
        this.closeSignIn = () => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.closeSignIn() : this.preopenSignIn = null
        }
        ,
        this.__internal_openCheckout = s => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.__internal_openCheckout(s) : this.preopenCheckout = s
        }
        ,
        this.__internal_closeCheckout = () => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.__internal_closeCheckout() : this.preopenCheckout = null
        }
        ,
        this.__internal_openReverification = s => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.__internal_openReverification(s) : this.preopenUserVerification = s
        }
        ,
        this.__internal_closeReverification = () => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.__internal_closeReverification() : this.preopenUserVerification = null
        }
        ,
        this.openGoogleOneTap = s => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.openGoogleOneTap(s) : this.preopenOneTap = s
        }
        ,
        this.closeGoogleOneTap = () => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.closeGoogleOneTap() : this.preopenOneTap = null
        }
        ,
        this.openUserProfile = s => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.openUserProfile(s) : this.preopenUserProfile = s
        }
        ,
        this.closeUserProfile = () => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.closeUserProfile() : this.preopenUserProfile = null
        }
        ,
        this.openOrganizationProfile = s => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.openOrganizationProfile(s) : this.preopenOrganizationProfile = s
        }
        ,
        this.closeOrganizationProfile = () => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.closeOrganizationProfile() : this.preopenOrganizationProfile = null
        }
        ,
        this.openCreateOrganization = s => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.openCreateOrganization(s) : this.preopenCreateOrganization = s
        }
        ,
        this.closeCreateOrganization = () => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.closeCreateOrganization() : this.preopenCreateOrganization = null
        }
        ,
        this.openWaitlist = s => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.openWaitlist(s) : this.preOpenWaitlist = s
        }
        ,
        this.closeWaitlist = () => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.closeWaitlist() : this.preOpenWaitlist = null
        }
        ,
        this.openSignUp = s => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.openSignUp(s) : this.preopenSignUp = s
        }
        ,
        this.closeSignUp = () => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.closeSignUp() : this.preopenSignUp = null
        }
        ,
        this.mountSignIn = (s, o) => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.mountSignIn(s, o) : this.premountSignInNodes.set(s, o)
        }
        ,
        this.unmountSignIn = s => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.unmountSignIn(s) : this.premountSignInNodes.delete(s)
        }
        ,
        this.__experimental_mountPricingTable = (s, o) => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.__experimental_mountPricingTable(s, o) : this.premountPricingTableNodes.set(s, o)
        }
        ,
        this.__experimental_unmountPricingTable = s => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.__experimental_unmountPricingTable(s) : this.premountPricingTableNodes.delete(s)
        }
        ,
        this.mountSignUp = (s, o) => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.mountSignUp(s, o) : this.premountSignUpNodes.set(s, o)
        }
        ,
        this.unmountSignUp = s => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.unmountSignUp(s) : this.premountSignUpNodes.delete(s)
        }
        ,
        this.mountUserProfile = (s, o) => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.mountUserProfile(s, o) : this.premountUserProfileNodes.set(s, o)
        }
        ,
        this.unmountUserProfile = s => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.unmountUserProfile(s) : this.premountUserProfileNodes.delete(s)
        }
        ,
        this.mountOrganizationProfile = (s, o) => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.mountOrganizationProfile(s, o) : this.premountOrganizationProfileNodes.set(s, o)
        }
        ,
        this.unmountOrganizationProfile = s => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.unmountOrganizationProfile(s) : this.premountOrganizationProfileNodes.delete(s)
        }
        ,
        this.mountCreateOrganization = (s, o) => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.mountCreateOrganization(s, o) : this.premountCreateOrganizationNodes.set(s, o)
        }
        ,
        this.unmountCreateOrganization = s => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.unmountCreateOrganization(s) : this.premountCreateOrganizationNodes.delete(s)
        }
        ,
        this.mountOrganizationSwitcher = (s, o) => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.mountOrganizationSwitcher(s, o) : this.premountOrganizationSwitcherNodes.set(s, o)
        }
        ,
        this.unmountOrganizationSwitcher = s => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.unmountOrganizationSwitcher(s) : this.premountOrganizationSwitcherNodes.delete(s)
        }
        ,
        this.__experimental_prefetchOrganizationSwitcher = () => {
            const s = () => {
                var o;
                return (o = this.clerkjs) == null ? void 0 : o.__experimental_prefetchOrganizationSwitcher()
            }
            ;
            this.clerkjs && Be(this, Ze) ? s() : this.premountMethodCalls.set("__experimental_prefetchOrganizationSwitcher", s)
        }
        ,
        this.mountOrganizationList = (s, o) => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.mountOrganizationList(s, o) : this.premountOrganizationListNodes.set(s, o)
        }
        ,
        this.unmountOrganizationList = s => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.unmountOrganizationList(s) : this.premountOrganizationListNodes.delete(s)
        }
        ,
        this.mountUserButton = (s, o) => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.mountUserButton(s, o) : this.premountUserButtonNodes.set(s, o)
        }
        ,
        this.unmountUserButton = s => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.unmountUserButton(s) : this.premountUserButtonNodes.delete(s)
        }
        ,
        this.mountWaitlist = (s, o) => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.mountWaitlist(s, o) : this.premountWaitlistNodes.set(s, o)
        }
        ,
        this.unmountWaitlist = s => {
            this.clerkjs && Be(this, Ze) ? this.clerkjs.unmountWaitlist(s) : this.premountWaitlistNodes.delete(s)
        }
        ,
        this.addListener = s => {
            if (this.clerkjs)
                return this.clerkjs.addListener(s);
            {
                const o = () => {
                    var u;
                    const d = this.premountAddListenerCalls.get(s);
                    d && ((u = d.nativeUnsubscribe) == null || u.call(d),
                    this.premountAddListenerCalls.delete(s))
                }
                ;
                return this.premountAddListenerCalls.set(s, {
                    unsubscribe: o,
                    nativeUnsubscribe: void 0
                }),
                o
            }
        }
        ,
        this.navigate = s => {
            const o = () => {
                var u;
                return (u = this.clerkjs) == null ? void 0 : u.navigate(s)
            }
            ;
            this.clerkjs && Be(this, Ze) ? o() : this.premountMethodCalls.set("navigate", o)
        }
        ,
        this.redirectWithAuth = async (...s) => {
            const o = () => {
                var u;
                return (u = this.clerkjs) == null ? void 0 : u.redirectWithAuth(...s)
            }
            ;
            if (this.clerkjs && Be(this, Ze))
                return o();
            this.premountMethodCalls.set("redirectWithAuth", o)
        }
        ,
        this.redirectToSignIn = async s => {
            const o = () => {
                var u;
                return (u = this.clerkjs) == null ? void 0 : u.redirectToSignIn(s)
            }
            ;
            if (this.clerkjs && Be(this, Ze))
                return o();
            this.premountMethodCalls.set("redirectToSignIn", o)
        }
        ,
        this.redirectToSignUp = async s => {
            const o = () => {
                var u;
                return (u = this.clerkjs) == null ? void 0 : u.redirectToSignUp(s)
            }
            ;
            if (this.clerkjs && Be(this, Ze))
                return o();
            this.premountMethodCalls.set("redirectToSignUp", o)
        }
        ,
        this.redirectToUserProfile = async () => {
            const s = () => {
                var o;
                return (o = this.clerkjs) == null ? void 0 : o.redirectToUserProfile()
            }
            ;
            if (this.clerkjs && Be(this, Ze))
                return s();
            this.premountMethodCalls.set("redirectToUserProfile", s)
        }
        ,
        this.redirectToAfterSignUp = () => {
            const s = () => {
                var o;
                return (o = this.clerkjs) == null ? void 0 : o.redirectToAfterSignUp()
            }
            ;
            if (this.clerkjs && Be(this, Ze))
                return s();
            this.premountMethodCalls.set("redirectToAfterSignUp", s)
        }
        ,
        this.redirectToAfterSignIn = () => {
            const s = () => {
                var o;
                return (o = this.clerkjs) == null ? void 0 : o.redirectToAfterSignIn()
            }
            ;
            this.clerkjs && Be(this, Ze) ? s() : this.premountMethodCalls.set("redirectToAfterSignIn", s)
        }
        ,
        this.redirectToAfterSignOut = () => {
            const s = () => {
                var o;
                return (o = this.clerkjs) == null ? void 0 : o.redirectToAfterSignOut()
            }
            ;
            this.clerkjs && Be(this, Ze) ? s() : this.premountMethodCalls.set("redirectToAfterSignOut", s)
        }
        ,
        this.redirectToOrganizationProfile = async () => {
            const s = () => {
                var o;
                return (o = this.clerkjs) == null ? void 0 : o.redirectToOrganizationProfile()
            }
            ;
            if (this.clerkjs && Be(this, Ze))
                return s();
            this.premountMethodCalls.set("redirectToOrganizationProfile", s)
        }
        ,
        this.redirectToCreateOrganization = async () => {
            const s = () => {
                var o;
                return (o = this.clerkjs) == null ? void 0 : o.redirectToCreateOrganization()
            }
            ;
            if (this.clerkjs && Be(this, Ze))
                return s();
            this.premountMethodCalls.set("redirectToCreateOrganization", s)
        }
        ,
        this.redirectToWaitlist = async () => {
            const s = () => {
                var o;
                return (o = this.clerkjs) == null ? void 0 : o.redirectToWaitlist()
            }
            ;
            if (this.clerkjs && Be(this, Ze))
                return s();
            this.premountMethodCalls.set("redirectToWaitlist", s)
        }
        ,
        this.handleRedirectCallback = async s => {
            var o;
            const u = () => {
                var d;
                return (d = this.clerkjs) == null ? void 0 : d.handleRedirectCallback(s)
            }
            ;
            this.clerkjs && Be(this, Ze) ? (o = u()) == null || o.catch( () => {}
            ) : this.premountMethodCalls.set("handleRedirectCallback", u)
        }
        ,
        this.handleGoogleOneTapCallback = async (s, o) => {
            var u;
            const d = () => {
                var f;
                return (f = this.clerkjs) == null ? void 0 : f.handleGoogleOneTapCallback(s, o)
            }
            ;
            this.clerkjs && Be(this, Ze) ? (u = d()) == null || u.catch( () => {}
            ) : this.premountMethodCalls.set("handleGoogleOneTapCallback", d)
        }
        ,
        this.handleEmailLinkVerification = async s => {
            const o = () => {
                var u;
                return (u = this.clerkjs) == null ? void 0 : u.handleEmailLinkVerification(s)
            }
            ;
            if (this.clerkjs && Be(this, Ze))
                return o();
            this.premountMethodCalls.set("handleEmailLinkVerification", o)
        }
        ,
        this.authenticateWithMetamask = async s => {
            const o = () => {
                var u;
                return (u = this.clerkjs) == null ? void 0 : u.authenticateWithMetamask(s)
            }
            ;
            if (this.clerkjs && Be(this, Ze))
                return o();
            this.premountMethodCalls.set("authenticateWithMetamask", o)
        }
        ,
        this.authenticateWithCoinbaseWallet = async s => {
            const o = () => {
                var u;
                return (u = this.clerkjs) == null ? void 0 : u.authenticateWithCoinbaseWallet(s)
            }
            ;
            if (this.clerkjs && Be(this, Ze))
                return o();
            this.premountMethodCalls.set("authenticateWithCoinbaseWallet", o)
        }
        ,
        this.authenticateWithOKXWallet = async s => {
            const o = () => {
                var u;
                return (u = this.clerkjs) == null ? void 0 : u.authenticateWithOKXWallet(s)
            }
            ;
            if (this.clerkjs && Be(this, Ze))
                return o();
            this.premountMethodCalls.set("authenticateWithOKXWallet", o)
        }
        ,
        this.authenticateWithWeb3 = async s => {
            const o = () => {
                var u;
                return (u = this.clerkjs) == null ? void 0 : u.authenticateWithWeb3(s)
            }
            ;
            if (this.clerkjs && Be(this, Ze))
                return o();
            this.premountMethodCalls.set("authenticateWithWeb3", o)
        }
        ,
        this.authenticateWithGoogleOneTap = async s => (await _b(this, lf, Lg).call(this)).authenticateWithGoogleOneTap(s),
        this.createOrganization = async s => {
            const o = () => {
                var u;
                return (u = this.clerkjs) == null ? void 0 : u.createOrganization(s)
            }
            ;
            if (this.clerkjs && Be(this, Ze))
                return o();
            this.premountMethodCalls.set("createOrganization", o)
        }
        ,
        this.getOrganization = async s => {
            const o = () => {
                var u;
                return (u = this.clerkjs) == null ? void 0 : u.getOrganization(s)
            }
            ;
            if (this.clerkjs && Be(this, Ze))
                return o();
            this.premountMethodCalls.set("getOrganization", o)
        }
        ,
        this.joinWaitlist = async s => {
            const o = () => {
                var u;
                return (u = this.clerkjs) == null ? void 0 : u.joinWaitlist(s)
            }
            ;
            if (this.clerkjs && Be(this, Ze))
                return o();
            this.premountMethodCalls.set("joinWaitlist", o)
        }
        ,
        this.signOut = async (...s) => {
            const o = () => {
                var u;
                return (u = this.clerkjs) == null ? void 0 : u.signOut(...s)
            }
            ;
            if (this.clerkjs && Be(this, Ze))
                return o();
            this.premountMethodCalls.set("signOut", o)
        }
        ;
        const {Clerk: t=null, publishableKey: r} = e || {};
        Bo(this, ss, r),
        Bo(this, al, e == null ? void 0 : e.proxyUrl),
        Bo(this, rl, e == null ? void 0 : e.domain),
        this.options = e,
        this.Clerk = t,
        this.mode = bb() ? "browser" : "server",
        this.options.sdkMetadata || (this.options.sdkMetadata = XC),
        Be(this, ss) && this.loadClerkJS()
    }
    get publishableKey() {
        return Be(this, ss)
    }
    get loaded() {
        return Be(this, Ze)
    }
    static getOrCreateInstance(e) {
        return (!bb() || !Be(this, cs) || e.Clerk && Be(this, cs).Clerk !== e.Clerk || Be(this, cs).publishableKey !== e.publishableKey) && Bo(this, cs, new dM(e)),
        Be(this, cs)
    }
    static clearInstance() {
        Bo(this, cs, null)
    }
    get domain() {
        return typeof window < "u" && window.location ? Am(Be(this, rl), new URL(window.location.href), "") : typeof Be(this, rl) == "function" ? Nr.throw(Tm) : Be(this, rl) || ""
    }
    get proxyUrl() {
        return typeof window < "u" && window.location ? Am(Be(this, al), new URL(window.location.href), "") : typeof Be(this, al) == "function" ? Nr.throw(Tm) : Be(this, al) || ""
    }
    __internal_getOption(e) {
        var t, r;
        return (t = this.clerkjs) != null && t.__internal_getOption ? (r = this.clerkjs) == null ? void 0 : r.__internal_getOption(e) : this.options[e]
    }
    get sdkMetadata() {
        var e;
        return ((e = this.clerkjs) == null ? void 0 : e.sdkMetadata) || this.options.sdkMetadata || void 0
    }
    get instanceType() {
        var e;
        return (e = this.clerkjs) == null ? void 0 : e.instanceType
    }
    get frontendApi() {
        var e;
        return ((e = this.clerkjs) == null ? void 0 : e.frontendApi) || ""
    }
    get isStandardBrowser() {
        var e;
        return ((e = this.clerkjs) == null ? void 0 : e.isStandardBrowser) || this.options.standardBrowser || !1
    }
    get isSatellite() {
        return typeof window < "u" && window.location ? Am(this.options.isSatellite, new URL(window.location.href), !1) : typeof this.options.isSatellite == "function" ? Nr.throw(Tm) : !1
    }
    async loadClerkJS() {
        var e;
        if (!(this.mode !== "browser" || Be(this, Ze))) {
            typeof window < "u" && (window.__clerk_publishable_key = Be(this, ss),
            window.__clerk_proxy_url = this.proxyUrl,
            window.__clerk_domain = this.domain);
            try {
                if (this.Clerk) {
                    let t;
                    NC(this.Clerk) ? (t = new this.Clerk(Be(this, ss),{
                        proxyUrl: this.proxyUrl,
                        domain: this.domain
                    }),
                    await t.load(this.options)) : (t = this.Clerk,
                    t.loaded || await t.load(this.options)),
                    global.Clerk = t
                } else if (!__BUILD_DISABLE_RHC__) {
                    if (global.Clerk || await wC({
                        ...this.options,
                        publishableKey: Be(this, ss),
                        proxyUrl: this.proxyUrl,
                        domain: this.domain,
                        nonce: this.options.nonce
                    }),
                    !global.Clerk)
                        throw new Error("Failed to download latest ClerkJS. Contact support@clerk.com.");
                    await global.Clerk.load(this.options)
                }
                return (e = global.Clerk) != null && e.loaded ? this.hydrateClerkJS(global.Clerk) : void 0
            } catch (t) {
                const r = t;
                console.error(r.stack || r.message || r);
                return
            }
        }
    }
    get version() {
        var e;
        return (e = this.clerkjs) == null ? void 0 : e.version
    }
    get client() {
        if (this.clerkjs)
            return this.clerkjs.client
    }
    get session() {
        if (this.clerkjs)
            return this.clerkjs.session
    }
    get user() {
        if (this.clerkjs)
            return this.clerkjs.user
    }
    get organization() {
        if (this.clerkjs)
            return this.clerkjs.organization
    }
    get telemetry() {
        if (this.clerkjs)
            return this.clerkjs.telemetry
    }
    get __unstable__environment() {
        if (this.clerkjs)
            return this.clerkjs.__unstable__environment
    }
    get isSignedIn() {
        return this.clerkjs ? this.clerkjs.isSignedIn : !1
    }
    get __experimental_commerce() {
        var e;
        return (e = this.clerkjs) == null ? void 0 : e.__experimental_commerce
    }
    __unstable__setEnvironment(...e) {
        if (this.clerkjs && "__unstable__setEnvironment"in this.clerkjs)
            this.clerkjs.__unstable__setEnvironment(e);
        else
            return
    }
}
;
Ze = new WeakMap;
rl = new WeakMap;
al = new WeakMap;
ss = new WeakMap;
cs = new WeakMap;
lf = new WeakSet;
Lg = function() {
    return new Promise(n => {
        this.addOnLoaded( () => n(this.clerkjs))
    }
    )
}
;
il(uM, cs);
var Tb = uM;
function qC(n) {
    const {isomorphicClerkOptions: e, initialState: t, children: r} = n
      , {isomorphicClerk: s, loaded: o} = YC(e)
      , [u,d] = K.useState({
        client: s.client,
        session: s.session,
        user: s.user,
        organization: s.organization
    });
    K.useEffect( () => s.addListener(Q => d({
        ...Q
    })), []);
    const f = DC(o, u, t)
      , h = K.useMemo( () => ({
        value: s
    }), [o])
      , m = K.useMemo( () => ({
        value: u.client
    }), [u.client])
      , {sessionId: g, sessionStatus: _, sessionClaims: x, session: E, userId: M, user: b, orgId: y, actor: T, organization: D, orgRole: C, orgSlug: P, orgPermissions: A, factorVerificationAge: F} = f
      , z = K.useMemo( () => ({
        value: {
            sessionId: g,
            sessionStatus: _,
            sessionClaims: x,
            userId: M,
            actor: T,
            orgId: y,
            orgRole: C,
            orgSlug: P,
            orgPermissions: A,
            factorVerificationAge: F
        }
    }), [g, _, M, T, y, C, P, F, x == null ? void 0 : x.__raw])
      , U = K.useMemo( () => ({
        value: E
    }), [g, E])
      , R = K.useMemo( () => ({
        value: b
    }), [M, b])
      , V = K.useMemo( () => ({
        value: {
            organization: D
        }
    }), [y, D]);
    return K.createElement(BR.Provider, {
        value: h
    }, K.createElement(DR.Provider, {
        value: m
    }, K.createElement(UR.Provider, {
        value: U
    }, K.createElement(NR, {
        ...V.value
    }, K.createElement(kR.Provider, {
        value: z
    }, K.createElement(RR.Provider, {
        value: R
    }, r))))))
}
var YC = n => {
    const [e,t] = K.useState(!1)
      , r = K.useMemo( () => Tb.getOrCreateInstance(n), []);
    return K.useEffect( () => {
        r.__unstable__updateProps({
            appearance: n.appearance
        })
    }
    , [n.appearance]),
    K.useEffect( () => {
        r.__unstable__updateProps({
            options: n
        })
    }
    , [n.localization]),
    K.useEffect( () => {
        r.addOnLoaded( () => t(!0))
    }
    , []),
    K.useEffect( () => () => {
        Tb.clearInstance(),
        t(!1)
    }
    , []),
    {
        isomorphicClerk: r,
        loaded: e
    }
}
;
function ZC(n) {
    const {initialState: e, children: t, __internal_bypassMissingPublishableKey: r, ...s} = n
      , {publishableKey: o="", Clerk: u} = s;
    return !u && !r && (o ? o && !yg(o) && Nr.throwInvalidPublishableKeyError({
        key: o
    }) : Nr.throwMissingPublishableKeyError()),
    K.createElement(qC, {
        initialState: e,
        isomorphicClerkOptions: s
    }, t)
}
var fM = PC(ZC, "ClerkProvider", VR);
fM.displayName = "ClerkProvider";
zR({
    packageName: "@clerk/clerk-react"
});
MC("@clerk/clerk-react");
var Mc = {}, Ab;
function $C() {
    if (Ab)
        return Mc;
    Ab = 1,
    Object.defineProperty(Mc, "__esModule", {
        value: !0
    }),
    Mc.parse = u,
    Mc.serialize = h;
    const n = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/
      , e = /^[\u0021-\u003A\u003C-\u007E]*$/
      , t = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i
      , r = /^[\u0020-\u003A\u003D-\u007E]*$/
      , s = Object.prototype.toString
      , o = ( () => {
        const _ = function() {};
        return _.prototype = Object.create(null),
        _
    }
    )();
    function u(_, x) {
        const E = new o
          , M = _.length;
        if (M < 2)
            return E;
        const b = (x == null ? void 0 : x.decode) || m;
        let y = 0;
        do {
            const T = _.indexOf("=", y);
            if (T === -1)
                break;
            const D = _.indexOf(";", y)
              , C = D === -1 ? M : D;
            if (T > C) {
                y = _.lastIndexOf(";", T - 1) + 1;
                continue
            }
            const P = d(_, y, T)
              , A = f(_, T, P)
              , F = _.slice(P, A);
            if (E[F] === void 0) {
                let z = d(_, T + 1, C)
                  , U = f(_, C, z);
                const R = b(_.slice(z, U));
                E[F] = R
            }
            y = C + 1
        } while (y < M);
        return E
    }
    function d(_, x, E) {
        do {
            const M = _.charCodeAt(x);
            if (M !== 32 && M !== 9)
                return x
        } while (++x < E);
        return E
    }
    function f(_, x, E) {
        for (; x > E; ) {
            const M = _.charCodeAt(--x);
            if (M !== 32 && M !== 9)
                return x + 1
        }
        return E
    }
    function h(_, x, E) {
        const M = (E == null ? void 0 : E.encode) || encodeURIComponent;
        if (!n.test(_))
            throw new TypeError(`argument name is invalid: ${_}`);
        const b = M(x);
        if (!e.test(b))
            throw new TypeError(`argument val is invalid: ${x}`);
        let y = _ + "=" + b;
        if (!E)
            return y;
        if (E.maxAge !== void 0) {
            if (!Number.isInteger(E.maxAge))
                throw new TypeError(`option maxAge is invalid: ${E.maxAge}`);
            y += "; Max-Age=" + E.maxAge
        }
        if (E.domain) {
            if (!t.test(E.domain))
                throw new TypeError(`option domain is invalid: ${E.domain}`);
            y += "; Domain=" + E.domain
        }
        if (E.path) {
            if (!r.test(E.path))
                throw new TypeError(`option path is invalid: ${E.path}`);
            y += "; Path=" + E.path
        }
        if (E.expires) {
            if (!g(E.expires) || !Number.isFinite(E.expires.valueOf()))
                throw new TypeError(`option expires is invalid: ${E.expires}`);
            y += "; Expires=" + E.expires.toUTCString()
        }
        if (E.httpOnly && (y += "; HttpOnly"),
        E.secure && (y += "; Secure"),
        E.partitioned && (y += "; Partitioned"),
        E.priority)
            switch (typeof E.priority == "string" ? E.priority.toLowerCase() : void 0) {
            case "low":
                y += "; Priority=Low";
                break;
            case "medium":
                y += "; Priority=Medium";
                break;
            case "high":
                y += "; Priority=High";
                break;
            default:
                throw new TypeError(`option priority is invalid: ${E.priority}`)
            }
        if (E.sameSite)
            switch (typeof E.sameSite == "string" ? E.sameSite.toLowerCase() : E.sameSite) {
            case !0:
            case "strict":
                y += "; SameSite=Strict";
                break;
            case "lax":
                y += "; SameSite=Lax";
                break;
            case "none":
                y += "; SameSite=None";
                break;
            default:
                throw new TypeError(`option sameSite is invalid: ${E.sameSite}`)
            }
        return y
    }
    function m(_) {
        if (_.indexOf("%") === -1)
            return _;
        try {
            return decodeURIComponent(_)
        } catch {
            return _
        }
    }
    function g(_) {
        return s.call(_) === "[object Date]"
    }
    return Mc
}
$C();
/**
 * react-router v7.5.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
var hM = n => {
    throw TypeError(n)
}
  , KC = (n, e, t) => e.has(n) || hM("Cannot " + t)
  , Lm = (n, e, t) => (KC(n, e, "read from private field"),
t ? t.call(n) : e.get(n))
  , QC = (n, e, t) => e.has(n) ? hM("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(n) : e.set(n, t)
  , Rb = "popstate";
function JC(n={}) {
    function e(r, s) {
        let {pathname: o, search: u, hash: d} = r.location;
        return $c("", {
            pathname: o,
            search: u,
            hash: d
        }, s.state && s.state.usr || null, s.state && s.state.key || "default")
    }
    function t(r, s) {
        return typeof s == "string" ? s : vs(s)
    }
    return t2(e, t, null, n)
}
function en(n, e) {
    if (n === !1 || n === null || typeof n > "u")
        throw new Error(e)
}
function Wn(n, e) {
    if (!n) {
        typeof console < "u" && console.warn(e);
        try {
            throw new Error(e)
        } catch {}
    }
}
function e2() {
    return Math.random().toString(36).substring(2, 10)
}
function Cb(n, e) {
    return {
        usr: n.state,
        key: n.key,
        idx: e
    }
}
function $c(n, e, t=null, r) {
    return {
        pathname: typeof n == "string" ? n : n.pathname,
        search: "",
        hash: "",
        ...typeof e == "string" ? bs(e) : e,
        state: t,
        key: e && e.key || r || e2()
    }
}
function vs({pathname: n="/", search: e="", hash: t=""}) {
    return e && e !== "?" && (n += e.charAt(0) === "?" ? e : "?" + e),
    t && t !== "#" && (n += t.charAt(0) === "#" ? t : "#" + t),
    n
}
function bs(n) {
    let e = {};
    if (n) {
        let t = n.indexOf("#");
        t >= 0 && (e.hash = n.substring(t),
        n = n.substring(0, t));
        let r = n.indexOf("?");
        r >= 0 && (e.search = n.substring(r),
        n = n.substring(0, r)),
        n && (e.pathname = n)
    }
    return e
}
function t2(n, e, t, r={}) {
    let {window: s=document.defaultView, v5Compat: o=!1} = r
      , u = s.history
      , d = "POP"
      , f = null
      , h = m();
    h == null && (h = 0,
    u.replaceState({
        ...u.state,
        idx: h
    }, ""));
    function m() {
        return (u.state || {
            idx: null
        }).idx
    }
    function g() {
        d = "POP";
        let b = m()
          , y = b == null ? null : b - h;
        h = b,
        f && f({
            action: d,
            location: M.location,
            delta: y
        })
    }
    function _(b, y) {
        d = "PUSH";
        let T = $c(M.location, b, y);
        h = m() + 1;
        let D = Cb(T, h)
          , C = M.createHref(T);
        try {
            u.pushState(D, "", C)
        } catch (P) {
            if (P instanceof DOMException && P.name === "DataCloneError")
                throw P;
            s.location.assign(C)
        }
        o && f && f({
            action: d,
            location: M.location,
            delta: 1
        })
    }
    function x(b, y) {
        d = "REPLACE";
        let T = $c(M.location, b, y);
        h = m();
        let D = Cb(T, h)
          , C = M.createHref(T);
        u.replaceState(D, "", C),
        o && f && f({
            action: d,
            location: M.location,
            delta: 0
        })
    }
    function E(b) {
        let y = s.location.origin !== "null" ? s.location.origin : s.location.href
          , T = typeof b == "string" ? b : vs(b);
        return T = T.replace(/ $/, "%20"),
        en(y, `No window.location.(origin|href) available to create URL for href: ${T}`),
        new URL(T,y)
    }
    let M = {
        get action() {
            return d
        },
        get location() {
            return n(s, u)
        },
        listen(b) {
            if (f)
                throw new Error("A history only accepts one active listener");
            return s.addEventListener(Rb, g),
            f = b,
            () => {
                s.removeEventListener(Rb, g),
                f = null
            }
        },
        createHref(b) {
            return e(s, b)
        },
        createURL: E,
        encodeLocation(b) {
            let y = E(b);
            return {
                pathname: y.pathname,
                search: y.search,
                hash: y.hash
            }
        },
        push: _,
        replace: x,
        go(b) {
            return u.go(b)
        }
    };
    return M
}
var Ic, Db = class {
    constructor(n) {
        if (QC(this, Ic, new Map),
        n)
            for (let[e,t] of n)
                this.set(e, t)
    }
    get(n) {
        if (Lm(this, Ic).has(n))
            return Lm(this, Ic).get(n);
        if (n.defaultValue !== void 0)
            return n.defaultValue;
        throw new Error("No value found for context")
    }
    set(n, e) {
        Lm(this, Ic).set(n, e)
    }
}
;
Ic = new WeakMap;
var n2 = new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
function i2(n) {
    return n2.has(n)
}
var r2 = new Set(["lazy", "caseSensitive", "path", "id", "index", "unstable_middleware", "children"]);
function a2(n) {
    return r2.has(n)
}
function s2(n) {
    return n.index === !0
}
function bf(n, e, t=[], r={}) {
    return n.map( (s, o) => {
        let u = [...t, String(o)]
          , d = typeof s.id == "string" ? s.id : u.join("-");
        if (en(s.index !== !0 || !s.children, "Cannot specify children on an index route"),
        en(!r[d], `Found a route id collision on id "${d}".  Route id's must be globally unique within Data Router usages`),
        s2(s)) {
            let f = {
                ...s,
                ...e(s),
                id: d
            };
            return r[d] = f,
            f
        } else {
            let f = {
                ...s,
                ...e(s),
                id: d,
                children: void 0
            };
            return r[d] = f,
            s.children && (f.children = bf(s.children, e, u, r)),
            f
        }
    }
    )
}
function ds(n, e, t="/") {
    return cf(n, e, t, !1)
}
function cf(n, e, t, r) {
    let s = typeof e == "string" ? bs(e) : e
      , o = or(s.pathname || "/", t);
    if (o == null)
        return null;
    let u = pM(n);
    l2(u);
    let d = null;
    for (let f = 0; d == null && f < u.length; ++f) {
        let h = y2(o);
        d = v2(u[f], h, r)
    }
    return d
}
function o2(n, e) {
    let {route: t, pathname: r, params: s} = n;
    return {
        id: t.id,
        pathname: r,
        params: s,
        data: e[t.id],
        handle: t.handle
    }
}
function pM(n, e=[], t=[], r="") {
    let s = (o, u, d) => {
        let f = {
            relativePath: d === void 0 ? o.path || "" : d,
            caseSensitive: o.caseSensitive === !0,
            childrenIndex: u,
            route: o
        };
        f.relativePath.startsWith("/") && (en(f.relativePath.startsWith(r), `Absolute route path "${f.relativePath}" nested under path "${r}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`),
        f.relativePath = f.relativePath.slice(r.length));
        let h = Or([r, f.relativePath])
          , m = t.concat(f);
        o.children && o.children.length > 0 && (en(o.index !== !0, `Index routes must not have child routes. Please remove all child routes from route path "${h}".`),
        pM(o.children, e, m, h)),
        !(o.path == null && !o.index) && e.push({
            path: h,
            score: m2(h, o.index),
            routesMeta: m
        })
    }
    ;
    return n.forEach( (o, u) => {
        var d;
        if (o.path === "" || !((d = o.path) != null && d.includes("?")))
            s(o, u);
        else
            for (let f of mM(o.path))
                s(o, u, f)
    }
    ),
    e
}
function mM(n) {
    let e = n.split("/");
    if (e.length === 0)
        return [];
    let[t,...r] = e
      , s = t.endsWith("?")
      , o = t.replace(/\?$/, "");
    if (r.length === 0)
        return s ? [o, ""] : [o];
    let u = mM(r.join("/"))
      , d = [];
    return d.push(...u.map(f => f === "" ? o : [o, f].join("/"))),
    s && d.push(...u),
    d.map(f => n.startsWith("/") && f === "" ? "/" : f)
}
function l2(n) {
    n.sort( (e, t) => e.score !== t.score ? t.score - e.score : g2(e.routesMeta.map(r => r.childrenIndex), t.routesMeta.map(r => r.childrenIndex)))
}
var c2 = /^:[\w-]+$/
  , u2 = 3
  , d2 = 2
  , f2 = 1
  , h2 = 10
  , p2 = -2
  , Ub = n => n === "*";
function m2(n, e) {
    let t = n.split("/")
      , r = t.length;
    return t.some(Ub) && (r += p2),
    e && (r += d2),
    t.filter(s => !Ub(s)).reduce( (s, o) => s + (c2.test(o) ? u2 : o === "" ? f2 : h2), r)
}
function g2(n, e) {
    return n.length === e.length && n.slice(0, -1).every( (r, s) => r === e[s]) ? n[n.length - 1] - e[e.length - 1] : 0
}
function v2(n, e, t=!1) {
    let {routesMeta: r} = n
      , s = {}
      , o = "/"
      , u = [];
    for (let d = 0; d < r.length; ++d) {
        let f = r[d]
          , h = d === r.length - 1
          , m = o === "/" ? e : e.slice(o.length) || "/"
          , g = Sf({
            path: f.relativePath,
            caseSensitive: f.caseSensitive,
            end: h
        }, m)
          , _ = f.route;
        if (!g && h && t && !r[r.length - 1].route.index && (g = Sf({
            path: f.relativePath,
            caseSensitive: f.caseSensitive,
            end: !1
        }, m)),
        !g)
            return null;
        Object.assign(s, g.params),
        u.push({
            params: s,
            pathname: Or([o, g.pathname]),
            pathnameBase: S2(Or([o, g.pathnameBase])),
            route: _
        }),
        g.pathnameBase !== "/" && (o = Or([o, g.pathnameBase]))
    }
    return u
}
function Sf(n, e) {
    typeof n == "string" && (n = {
        path: n,
        caseSensitive: !1,
        end: !0
    });
    let[t,r] = _2(n.path, n.caseSensitive, n.end)
      , s = e.match(t);
    if (!s)
        return null;
    let o = s[0]
      , u = o.replace(/(.)\/+$/, "$1")
      , d = s.slice(1);
    return {
        params: r.reduce( (h, {paramName: m, isOptional: g}, _) => {
            if (m === "*") {
                let E = d[_] || "";
                u = o.slice(0, o.length - E.length).replace(/(.)\/+$/, "$1")
            }
            const x = d[_];
            return g && !x ? h[m] = void 0 : h[m] = (x || "").replace(/%2F/g, "/"),
            h
        }
        , {}),
        pathname: o,
        pathnameBase: u,
        pattern: n
    }
}
function _2(n, e=!1, t=!0) {
    Wn(n === "*" || !n.endsWith("*") || n.endsWith("/*"), `Route path "${n}" will be treated as if it were "${n.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${n.replace(/\*$/, "/*")}".`);
    let r = []
      , s = "^" + n.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (u, d, f) => (r.push({
        paramName: d,
        isOptional: f != null
    }),
    f ? "/?([^\\/]+)?" : "/([^\\/]+)"));
    return n.endsWith("*") ? (r.push({
        paramName: "*"
    }),
    s += n === "*" || n === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : t ? s += "\\/*$" : n !== "" && n !== "/" && (s += "(?:(?=\\/|$))"),
    [new RegExp(s,e ? void 0 : "i"), r]
}
function y2(n) {
    try {
        return n.split("/").map(e => decodeURIComponent(e).replace(/\//g, "%2F")).join("/")
    } catch (e) {
        return Wn(!1, `The URL path "${n}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${e}).`),
        n
    }
}
function or(n, e) {
    if (e === "/")
        return n;
    if (!n.toLowerCase().startsWith(e.toLowerCase()))
        return null;
    let t = e.endsWith("/") ? e.length - 1 : e.length
      , r = n.charAt(t);
    return r && r !== "/" ? null : n.slice(t) || "/"
}
function x2(n, e="/") {
    let {pathname: t, search: r="", hash: s=""} = typeof n == "string" ? bs(n) : n;
    return {
        pathname: t ? t.startsWith("/") ? t : b2(t, e) : e,
        search: E2(r),
        hash: M2(s)
    }
}
function b2(n, e) {
    let t = e.replace(/\/+$/, "").split("/");
    return n.split("/").forEach(s => {
        s === ".." ? t.length > 1 && t.pop() : s !== "." && t.push(s)
    }
    ),
    t.length > 1 ? t.join("/") : "/"
}
function Nm(n, e, t, r) {
    return `Cannot include a '${n}' character in a manually specified \`to.${e}\` field [${JSON.stringify(r)}].  Please separate it out to the \`to.${t}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`
}
function gM(n) {
    return n.filter( (e, t) => t === 0 || e.route.path && e.route.path.length > 0)
}
function qv(n) {
    let e = gM(n);
    return e.map( (t, r) => r === e.length - 1 ? t.pathname : t.pathnameBase)
}
function Yv(n, e, t, r=!1) {
    let s;
    typeof n == "string" ? s = bs(n) : (s = {
        ...n
    },
    en(!s.pathname || !s.pathname.includes("?"), Nm("?", "pathname", "search", s)),
    en(!s.pathname || !s.pathname.includes("#"), Nm("#", "pathname", "hash", s)),
    en(!s.search || !s.search.includes("#"), Nm("#", "search", "hash", s)));
    let o = n === "" || s.pathname === "", u = o ? "/" : s.pathname, d;
    if (u == null)
        d = t;
    else {
        let g = e.length - 1;
        if (!r && u.startsWith("..")) {
            let _ = u.split("/");
            for (; _[0] === ".."; )
                _.shift(),
                g -= 1;
            s.pathname = _.join("/")
        }
        d = g >= 0 ? e[g] : "/"
    }
    let f = x2(s, d)
      , h = u && u !== "/" && u.endsWith("/")
      , m = (o || u === ".") && t.endsWith("/");
    return !f.pathname.endsWith("/") && (h || m) && (f.pathname += "/"),
    f
}
var Or = n => n.join("/").replace(/\/\/+/g, "/")
  , S2 = n => n.replace(/\/+$/, "").replace(/^\/*/, "/")
  , E2 = n => !n || n === "?" ? "" : n.startsWith("?") ? n : "?" + n
  , M2 = n => !n || n === "#" ? "" : n.startsWith("#") ? n : "#" + n
  , Ef = class {
    constructor(n, e, t, r=!1) {
        this.status = n,
        this.statusText = e || "",
        this.internal = r,
        t instanceof Error ? (this.data = t.toString(),
        this.error = t) : this.data = t
    }
}
;
function Kc(n) {
    return n != null && typeof n.status == "number" && typeof n.statusText == "string" && typeof n.internal == "boolean" && "data"in n
}
var vM = ["POST", "PUT", "PATCH", "DELETE"]
  , w2 = new Set(vM)
  , T2 = ["GET", ...vM]
  , A2 = new Set(T2)
  , R2 = new Set([301, 302, 303, 307, 308])
  , C2 = new Set([307, 308])
  , Om = {
    state: "idle",
    location: void 0,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0
}
  , D2 = {
    state: "idle",
    data: void 0,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0
}
  , wc = {
    state: "unblocked",
    proceed: void 0,
    reset: void 0,
    location: void 0
}
  , Zv = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i
  , U2 = n => ({
    hasErrorBoundary: !!n.hasErrorBoundary
})
  , _M = "remix-router-transitions"
  , yM = Symbol("ResetLoaderData");
function L2(n) {
    const e = n.window ? n.window : typeof window < "u" ? window : void 0
      , t = typeof e < "u" && typeof e.document < "u" && typeof e.document.createElement < "u";
    en(n.routes.length > 0, "You must provide a non-empty routes array to createRouter");
    let r = n.hydrationRouteProperties || [], s = n.mapRouteProperties || U2, o = {}, u = bf(n.routes, s, void 0, o), d, f = n.basename || "/", h = n.dataStrategy || z2, m = {
        unstable_middleware: !1,
        ...n.future
    }, g = null, _ = new Set, x = null, E = null, M = null, b = n.hydrationData != null, y = ds(u, n.history.location, f), T = !1, D = null;
    if (y == null && !n.patchRoutesOnNavigation) {
        let j = nr(404, {
            pathname: n.history.location.pathname
        })
          , {matches: ie, route: fe} = Gb(u);
        y = ie,
        D = {
            [fe.id]: j
        }
    }
    y && !n.hydrationData && Ce(y, u, n.history.location.pathname).active && (y = null);
    let C;
    if (y)
        if (y.some(j => j.route.lazy))
            C = !1;
        else if (!y.some(j => j.route.loader))
            C = !0;
        else {
            let j = n.hydrationData ? n.hydrationData.loaderData : null
              , ie = n.hydrationData ? n.hydrationData.errors : null;
            if (ie) {
                let fe = y.findIndex(Ue => ie[Ue.route.id] !== void 0);
                C = y.slice(0, fe + 1).every(Ue => !Og(Ue.route, j, ie))
            } else
                C = y.every(fe => !Og(fe.route, j, ie))
        }
    else {
        C = !1,
        y = [];
        let j = Ce(null, u, n.history.location.pathname);
        j.active && j.matches && (T = !0,
        y = j.matches)
    }
    let P, A = {
        historyAction: n.history.action,
        location: n.history.location,
        matches: y,
        initialized: C,
        navigation: Om,
        restoreScrollPosition: n.hydrationData != null ? !1 : null,
        preventScrollReset: !1,
        revalidation: "idle",
        loaderData: n.hydrationData && n.hydrationData.loaderData || {},
        actionData: n.hydrationData && n.hydrationData.actionData || null,
        errors: n.hydrationData && n.hydrationData.errors || D,
        fetchers: new Map,
        blockers: new Map
    }, F = "POP", z = !1, U, R = !1, V = new Map, Q = null, X = !1, oe = !1, le = new Set, O = new Map, W = 0, H = -1, Me = new Map, k = new Set, ee = new Map, ge = new Map, pe = new Set, te = new Map, we, Se = null;
    function De() {
        if (g = n.history.listen( ({action: j, location: ie, delta: fe}) => {
            if (we) {
                we(),
                we = void 0;
                return
            }
            Wn(te.size === 0 || fe != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
            let Ue = qt({
                currentLocation: A.location,
                nextLocation: ie,
                historyAction: j
            });
            if (Ue && fe != null) {
                let ze = new Promise(je => {
                    we = je
                }
                );
                n.history.go(fe * -1),
                Tt(Ue, {
                    state: "blocked",
                    location: ie,
                    proceed() {
                        Tt(Ue, {
                            state: "proceeding",
                            proceed: void 0,
                            reset: void 0,
                            location: ie
                        }),
                        ze.then( () => n.history.go(fe))
                    },
                    reset() {
                        let je = new Map(A.blockers);
                        je.set(Ue, wc),
                        He({
                            blockers: je
                        })
                    }
                });
                return
            }
            return G(j, ie)
        }
        ),
        t) {
            Y2(e, V);
            let j = () => Z2(e, V);
            e.addEventListener("pagehide", j),
            Q = () => e.removeEventListener("pagehide", j)
        }
        return A.initialized || G("POP", A.location, {
            initialHydration: !0
        }),
        P
    }
    function Ve() {
        g && g(),
        Q && Q(),
        _.clear(),
        U && U.abort(),
        A.fetchers.forEach( (j, ie) => Ae(ie)),
        A.blockers.forEach( (j, ie) => Lt(ie))
    }
    function _t(j) {
        return _.add(j),
        () => _.delete(j)
    }
    function He(j, ie={}) {
        A = {
            ...A,
            ...j
        };
        let fe = []
          , Ue = [];
        A.fetchers.forEach( (ze, je) => {
            ze.state === "idle" && (pe.has(je) ? fe.push(je) : Ue.push(je))
        }
        ),
        pe.forEach(ze => {
            !A.fetchers.has(ze) && !O.has(ze) && fe.push(ze)
        }
        ),
        [..._].forEach(ze => ze(A, {
            deletedFetchers: fe,
            viewTransitionOpts: ie.viewTransitionOpts,
            flushSync: ie.flushSync === !0
        })),
        fe.forEach(ze => Ae(ze)),
        Ue.forEach(ze => A.fetchers.delete(ze))
    }
    function Pt(j, ie, {flushSync: fe}={}) {
        var mt, Rt;
        let Ue = A.actionData != null && A.navigation.formMethod != null && Wi(A.navigation.formMethod) && A.navigation.state === "loading" && ((mt = j.state) == null ? void 0 : mt._isRedirect) !== !0, ze;
        ie.actionData ? Object.keys(ie.actionData).length > 0 ? ze = ie.actionData : ze = null : Ue ? ze = A.actionData : ze = null;
        let je = ie.loaderData ? Vb(A.loaderData, ie.loaderData, ie.matches || [], ie.errors) : A.loaderData
          , bt = A.blockers;
        bt.size > 0 && (bt = new Map(bt),
        bt.forEach( (ft, Dt) => bt.set(Dt, wc)));
        let Qe = z === !0 || A.navigation.formMethod != null && Wi(A.navigation.formMethod) && ((Rt = j.state) == null ? void 0 : Rt._isRedirect) !== !0;
        d && (u = d,
        d = void 0),
        X || F === "POP" || (F === "PUSH" ? n.history.push(j, j.state) : F === "REPLACE" && n.history.replace(j, j.state));
        let xt;
        if (F === "POP") {
            let ft = V.get(A.location.pathname);
            ft && ft.has(j.pathname) ? xt = {
                currentLocation: A.location,
                nextLocation: j
            } : V.has(j.pathname) && (xt = {
                currentLocation: j,
                nextLocation: A.location
            })
        } else if (R) {
            let ft = V.get(A.location.pathname);
            ft ? ft.add(j.pathname) : (ft = new Set([j.pathname]),
            V.set(A.location.pathname, ft)),
            xt = {
                currentLocation: A.location,
                nextLocation: j
            }
        }
        He({
            ...ie,
            actionData: ze,
            loaderData: je,
            historyAction: F,
            location: j,
            initialized: !0,
            navigation: Om,
            revalidation: "idle",
            restoreScrollPosition: Ke(j, ie.matches || A.matches),
            preventScrollReset: Qe,
            blockers: bt
        }, {
            viewTransitionOpts: xt,
            flushSync: fe === !0
        }),
        F = "POP",
        z = !1,
        R = !1,
        X = !1,
        oe = !1,
        Se == null || Se.resolve(),
        Se = null
    }
    async function kt(j, ie) {
        if (typeof j == "number") {
            n.history.go(j);
            return
        }
        let fe = Ng(A.location, A.matches, f, j, ie == null ? void 0 : ie.fromRouteId, ie == null ? void 0 : ie.relative)
          , {path: Ue, submission: ze, error: je} = Lb(!1, fe, ie)
          , bt = A.location
          , Qe = $c(A.location, Ue, ie && ie.state);
        Qe = {
            ...Qe,
            ...n.history.encodeLocation(Qe)
        };
        let xt = ie && ie.replace != null ? ie.replace : void 0
          , mt = "PUSH";
        xt === !0 ? mt = "REPLACE" : xt === !1 || ze != null && Wi(ze.formMethod) && ze.formAction === A.location.pathname + A.location.search && (mt = "REPLACE");
        let Rt = ie && "preventScrollReset"in ie ? ie.preventScrollReset === !0 : void 0
          , ft = (ie && ie.flushSync) === !0
          , Dt = qt({
            currentLocation: bt,
            nextLocation: Qe,
            historyAction: mt
        });
        if (Dt) {
            Tt(Dt, {
                state: "blocked",
                location: Qe,
                proceed() {
                    Tt(Dt, {
                        state: "proceeding",
                        proceed: void 0,
                        reset: void 0,
                        location: Qe
                    }),
                    kt(j, ie)
                },
                reset() {
                    let rn = new Map(A.blockers);
                    rn.set(Dt, wc),
                    He({
                        blockers: rn
                    })
                }
            });
            return
        }
        await G(mt, Qe, {
            submission: ze,
            pendingError: je,
            preventScrollReset: Rt,
            replace: ie && ie.replace,
            enableViewTransition: ie && ie.viewTransition,
            flushSync: ft
        })
    }
    function nt() {
        Se || (Se = $2()),
        se(),
        He({
            revalidation: "loading"
        });
        let j = Se.promise;
        return A.navigation.state === "submitting" ? j : A.navigation.state === "idle" ? (G(A.historyAction, A.location, {
            startUninterruptedRevalidation: !0
        }),
        j) : (G(F || A.historyAction, A.navigation.location, {
            overrideNavigation: A.navigation,
            enableViewTransition: R === !0
        }),
        j)
    }
    async function G(j, ie, fe) {
        U && U.abort(),
        U = null,
        F = j,
        X = (fe && fe.startUninterruptedRevalidation) === !0,
        Ne(A.location, A.matches),
        z = (fe && fe.preventScrollReset) === !0,
        R = (fe && fe.enableViewTransition) === !0;
        let Ue = d || u
          , ze = fe && fe.overrideNavigation
          , je = fe != null && fe.initialHydration && A.matches && A.matches.length > 0 && !T ? A.matches : ds(Ue, ie, f)
          , bt = (fe && fe.flushSync) === !0;
        if (je && A.initialized && !oe && G2(A.location, ie) && !(fe && fe.submission && Wi(fe.submission.formMethod))) {
            Pt(ie, {
                matches: je
            }, {
                flushSync: bt
            });
            return
        }
        let Qe = Ce(je, Ue, ie.pathname);
        if (Qe.active && Qe.matches && (je = Qe.matches),
        !je) {
            let {error: Cn, notFoundMatches: on, route: $t} = re(ie.pathname);
            Pt(ie, {
                matches: on,
                loaderData: {},
                errors: {
                    [$t.id]: Cn
                }
            }, {
                flushSync: bt
            });
            return
        }
        U = new AbortController;
        let xt = sl(n.history, ie, U.signal, fe && fe.submission), mt = new Db(n.unstable_getContext ? await n.unstable_getContext() : void 0), Rt;
        if (fe && fe.pendingError)
            Rt = [qs(je).route.id, {
                type: "error",
                error: fe.pendingError
            }];
        else if (fe && fe.submission && Wi(fe.submission.formMethod)) {
            let Cn = await Zt(xt, ie, fe.submission, je, mt, Qe.active, fe && fe.initialHydration === !0, {
                replace: fe.replace,
                flushSync: bt
            });
            if (Cn.shortCircuited)
                return;
            if (Cn.pendingActionResult) {
                let[on,$t] = Cn.pendingActionResult;
                if (ji($t) && Kc($t.error) && $t.error.status === 404) {
                    U = null,
                    Pt(ie, {
                        matches: Cn.matches,
                        loaderData: {},
                        errors: {
                            [on]: $t.error
                        }
                    });
                    return
                }
            }
            je = Cn.matches || je,
            Rt = Cn.pendingActionResult,
            ze = Pm(ie, fe.submission),
            bt = !1,
            Qe.active = !1,
            xt = sl(n.history, xt.url, xt.signal)
        }
        let {shortCircuited: ft, matches: Dt, loaderData: rn, errors: En} = await ot(xt, ie, je, mt, Qe.active, ze, fe && fe.submission, fe && fe.fetcherSubmission, fe && fe.replace, fe && fe.initialHydration === !0, bt, Rt);
        ft || (U = null,
        Pt(ie, {
            matches: Dt || je,
            ...Hb(Rt),
            loaderData: rn,
            errors: En
        }))
    }
    async function Zt(j, ie, fe, Ue, ze, je, bt, Qe={}) {
        se();
        let xt = X2(ie, fe);
        if (He({
            navigation: xt
        }, {
            flushSync: Qe.flushSync === !0
        }),
        je) {
            let ft = await at(Ue, ie.pathname, j.signal);
            if (ft.type === "aborted")
                return {
                    shortCircuited: !0
                };
            if (ft.type === "error") {
                let Dt = qs(ft.partialMatches).route.id;
                return {
                    matches: ft.partialMatches,
                    pendingActionResult: [Dt, {
                        type: "error",
                        error: ft.error
                    }]
                }
            } else if (ft.matches)
                Ue = ft.matches;
            else {
                let {notFoundMatches: Dt, error: rn, route: En} = re(ie.pathname);
                return {
                    matches: Dt,
                    pendingActionResult: [En.id, {
                        type: "error",
                        error: rn
                    }]
                }
            }
        }
        let mt, Rt = zc(Ue, ie);
        if (!Rt.route.action && !Rt.route.lazy)
            mt = {
                type: "error",
                error: nr(405, {
                    method: j.method,
                    pathname: ie.pathname,
                    routeId: Rt.route.id
                })
            };
        else {
            let ft = cl(s, o, j, Ue, Rt, bt ? [] : r, ze)
              , Dt = await I(j, ft, ze, null);
            if (mt = Dt[Rt.route.id],
            !mt) {
                for (let rn of Ue)
                    if (Dt[rn.route.id]) {
                        mt = Dt[rn.route.id];
                        break
                    }
            }
            if (j.signal.aborted)
                return {
                    shortCircuited: !0
                }
        }
        if ($s(mt)) {
            let ft;
            return Qe && Qe.replace != null ? ft = Qe.replace : ft = kb(mt.response.headers.get("Location"), new URL(j.url), f) === A.location.pathname + A.location.search,
            await S(j, mt, !0, {
                submission: fe,
                replace: ft
            }),
            {
                shortCircuited: !0
            }
        }
        if (ji(mt)) {
            let ft = qs(Ue, Rt.route.id);
            return (Qe && Qe.replace) !== !0 && (F = "PUSH"),
            {
                matches: Ue,
                pendingActionResult: [ft.route.id, mt]
            }
        }
        return {
            matches: Ue,
            pendingActionResult: [Rt.route.id, mt]
        }
    }
    async function ot(j, ie, fe, Ue, ze, je, bt, Qe, xt, mt, Rt, ft) {
        let Dt = je || Pm(ie, bt)
          , rn = bt || Qe || Wb(Dt)
          , En = !X && !mt;
        if (ze) {
            if (En) {
                let We = it(ft);
                He({
                    navigation: Dt,
                    ...We !== void 0 ? {
                        actionData: We
                    } : {}
                }, {
                    flushSync: Rt
                })
            }
            let Ie = await at(fe, ie.pathname, j.signal);
            if (Ie.type === "aborted")
                return {
                    shortCircuited: !0
                };
            if (Ie.type === "error") {
                let We = qs(Ie.partialMatches).route.id;
                return {
                    matches: Ie.partialMatches,
                    loaderData: {},
                    errors: {
                        [We]: Ie.error
                    }
                }
            } else if (Ie.matches)
                fe = Ie.matches;
            else {
                let {error: We, notFoundMatches: Mt, route: St} = re(ie.pathname);
                return {
                    matches: Mt,
                    loaderData: {},
                    errors: {
                        [St.id]: We
                    }
                }
            }
        }
        let Cn = d || u
          , {dsMatches: on, revalidatingFetchers: $t} = Nb(j, Ue, s, o, n.history, A, fe, rn, ie, mt ? [] : r, mt === !0, oe, le, pe, ee, k, Cn, f, ft);
        if (H = ++W,
        !n.dataStrategy && !on.some(Ie => Ie.shouldLoad) && $t.length === 0) {
            let Ie = ht();
            return Pt(ie, {
                matches: fe,
                loaderData: {},
                errors: ft && ji(ft[1]) ? {
                    [ft[0]]: ft[1].error
                } : null,
                ...Hb(ft),
                ...Ie ? {
                    fetchers: new Map(A.fetchers)
                } : {}
            }, {
                flushSync: Rt
            }),
            {
                shortCircuited: !0
            }
        }
        if (En) {
            let Ie = {};
            if (!ze) {
                Ie.navigation = Dt;
                let We = it(ft);
                We !== void 0 && (Ie.actionData = We)
            }
            $t.length > 0 && (Ie.fetchers = rt($t)),
            He(Ie, {
                flushSync: Rt
            })
        }
        $t.forEach(Ie => {
            Le(Ie.key),
            Ie.controller && O.set(Ie.key, Ie.controller)
        }
        );
        let br = () => $t.forEach(Ie => Le(Ie.key));
        U && U.signal.addEventListener("abort", br);
        let {loaderResults: si, fetcherResults: N} = await q(on, $t, j, Ue);
        if (j.signal.aborted)
            return {
                shortCircuited: !0
            };
        U && U.signal.removeEventListener("abort", br),
        $t.forEach(Ie => O.delete(Ie.key));
        let ae = Ld(si);
        if (ae)
            return await S(j, ae.result, !0, {
                replace: xt
            }),
            {
                shortCircuited: !0
            };
        if (ae = Ld(N),
        ae)
            return k.add(ae.key),
            await S(j, ae.result, !0, {
                replace: xt
            }),
            {
                shortCircuited: !0
            };
        let {loaderData: ye, errors: xe} = Bb(A, fe, si, ft, $t, N);
        mt && A.errors && (xe = {
            ...A.errors,
            ...xe
        });
        let ue = ht()
          , ke = yt(H)
          , Ge = ue || ke || $t.length > 0;
        return {
            matches: fe,
            loaderData: ye,
            errors: xe,
            ...Ge ? {
                fetchers: new Map(A.fetchers)
            } : {}
        }
    }
    function it(j) {
        if (j && !ji(j[1]))
            return {
                [j[0]]: j[1].data
            };
        if (A.actionData)
            return Object.keys(A.actionData).length === 0 ? null : A.actionData
    }
    function rt(j) {
        return j.forEach(ie => {
            let fe = A.fetchers.get(ie.key)
              , Ue = Tc(void 0, fe ? fe.data : void 0);
            A.fetchers.set(ie.key, Ue)
        }
        ),
        new Map(A.fetchers)
    }
    async function pt(j, ie, fe, Ue) {
        Le(j);
        let ze = (Ue && Ue.flushSync) === !0
          , je = d || u
          , bt = Ng(A.location, A.matches, f, fe, ie, Ue == null ? void 0 : Ue.relative)
          , Qe = ds(je, bt, f)
          , xt = Ce(Qe, je, bt);
        if (xt.active && xt.matches && (Qe = xt.matches),
        !Qe) {
            de(j, ie, nr(404, {
                pathname: bt
            }), {
                flushSync: ze
            });
            return
        }
        let {path: mt, submission: Rt, error: ft} = Lb(!0, bt, Ue);
        if (ft) {
            de(j, ie, ft, {
                flushSync: ze
            });
            return
        }
        let Dt = zc(Qe, mt)
          , rn = new Db(n.unstable_getContext ? await n.unstable_getContext() : void 0)
          , En = (Ue && Ue.preventScrollReset) === !0;
        if (Rt && Wi(Rt.formMethod)) {
            await Xe(j, ie, mt, Dt, Qe, rn, xt.active, ze, En, Rt);
            return
        }
        ee.set(j, {
            routeId: ie,
            path: mt
        }),
        await B(j, ie, mt, Dt, Qe, rn, xt.active, ze, En, Rt)
    }
    async function Xe(j, ie, fe, Ue, ze, je, bt, Qe, xt, mt) {
        se(),
        ee.delete(j);
        function Rt(Et) {
            if (!Et.route.action && !Et.route.lazy) {
                let jt = nr(405, {
                    method: mt.formMethod,
                    pathname: fe,
                    routeId: ie
                });
                return de(j, ie, jt, {
                    flushSync: Qe
                }),
                !0
            }
            return !1
        }
        if (!bt && Rt(Ue))
            return;
        let ft = A.fetchers.get(j);
        J(j, q2(mt, ft), {
            flushSync: Qe
        });
        let Dt = new AbortController
          , rn = sl(n.history, fe, Dt.signal, mt);
        if (bt) {
            let Et = await at(ze, fe, rn.signal, j);
            if (Et.type === "aborted")
                return;
            if (Et.type === "error") {
                de(j, ie, Et.error, {
                    flushSync: Qe
                });
                return
            } else if (Et.matches) {
                if (ze = Et.matches,
                Ue = zc(ze, fe),
                Rt(Ue))
                    return
            } else {
                de(j, ie, nr(404, {
                    pathname: fe
                }), {
                    flushSync: Qe
                });
                return
            }
        }
        O.set(j, Dt);
        let En = W
          , Cn = cl(s, o, rn, ze, Ue, r, je)
          , $t = (await I(rn, Cn, je, j))[Ue.route.id];
        if (rn.signal.aborted) {
            O.get(j) === Dt && O.delete(j);
            return
        }
        if (pe.has(j)) {
            if ($s($t) || ji($t)) {
                J(j, os(void 0));
                return
            }
        } else {
            if ($s($t))
                if (O.delete(j),
                H > En) {
                    J(j, os(void 0));
                    return
                } else
                    return k.add(j),
                    J(j, Tc(mt)),
                    S(rn, $t, !1, {
                        fetcherSubmission: mt,
                        preventScrollReset: xt
                    });
            if (ji($t)) {
                de(j, ie, $t.error);
                return
            }
        }
        let br = A.navigation.location || A.location
          , si = sl(n.history, br, Dt.signal)
          , N = d || u
          , ae = A.navigation.state !== "idle" ? ds(N, A.navigation.location, f) : A.matches;
        en(ae, "Didn't find any matches after fetcher action");
        let ye = ++W;
        Me.set(j, ye);
        let xe = Tc(mt, $t.data);
        A.fetchers.set(j, xe);
        let {dsMatches: ue, revalidatingFetchers: ke} = Nb(si, je, s, o, n.history, A, ae, mt, br, r, !1, oe, le, pe, ee, k, N, f, [Ue.route.id, $t]);
        ke.filter(Et => Et.key !== j).forEach(Et => {
            let jt = Et.key
              , Tn = A.fetchers.get(jt)
              , Kt = Tc(void 0, Tn ? Tn.data : void 0);
            A.fetchers.set(jt, Kt),
            Le(jt),
            Et.controller && O.set(jt, Et.controller)
        }
        ),
        He({
            fetchers: new Map(A.fetchers)
        });
        let Ge = () => ke.forEach(Et => Le(Et.key));
        Dt.signal.addEventListener("abort", Ge);
        let {loaderResults: Ie, fetcherResults: We} = await q(ue, ke, si, je);
        if (Dt.signal.aborted)
            return;
        Dt.signal.removeEventListener("abort", Ge),
        Me.delete(j),
        O.delete(j),
        ke.forEach(Et => O.delete(Et.key));
        let Mt = Ld(Ie);
        if (Mt)
            return S(si, Mt.result, !1, {
                preventScrollReset: xt
            });
        if (Mt = Ld(We),
        Mt)
            return k.add(Mt.key),
            S(si, Mt.result, !1, {
                preventScrollReset: xt
            });
        let {loaderData: St, errors: gt} = Bb(A, ae, Ie, void 0, ke, We);
        if (A.fetchers.has(j)) {
            let Et = os($t.data);
            A.fetchers.set(j, Et)
        }
        yt(ye),
        A.navigation.state === "loading" && ye > H ? (en(F, "Expected pending action"),
        U && U.abort(),
        Pt(A.navigation.location, {
            matches: ae,
            loaderData: St,
            errors: gt,
            fetchers: new Map(A.fetchers)
        })) : (He({
            errors: gt,
            loaderData: Vb(A.loaderData, St, ae, gt),
            fetchers: new Map(A.fetchers)
        }),
        oe = !1)
    }
    async function B(j, ie, fe, Ue, ze, je, bt, Qe, xt, mt) {
        let Rt = A.fetchers.get(j);
        J(j, Tc(mt, Rt ? Rt.data : void 0), {
            flushSync: Qe
        });
        let ft = new AbortController
          , Dt = sl(n.history, fe, ft.signal);
        if (bt) {
            let $t = await at(ze, fe, Dt.signal, j);
            if ($t.type === "aborted")
                return;
            if ($t.type === "error") {
                de(j, ie, $t.error, {
                    flushSync: Qe
                });
                return
            } else if ($t.matches)
                ze = $t.matches,
                Ue = zc(ze, fe);
            else {
                de(j, ie, nr(404, {
                    pathname: fe
                }), {
                    flushSync: Qe
                });
                return
            }
        }
        O.set(j, ft);
        let rn = W
          , En = cl(s, o, Dt, ze, Ue, r, je)
          , on = (await I(Dt, En, je, j))[Ue.route.id];
        if (O.get(j) === ft && O.delete(j),
        !Dt.signal.aborted) {
            if (pe.has(j)) {
                J(j, os(void 0));
                return
            }
            if ($s(on))
                if (H > rn) {
                    J(j, os(void 0));
                    return
                } else {
                    k.add(j),
                    await S(Dt, on, !1, {
                        preventScrollReset: xt
                    });
                    return
                }
            if (ji(on)) {
                de(j, ie, on.error);
                return
            }
            J(j, os(on.data))
        }
    }
    async function S(j, ie, fe, {submission: Ue, fetcherSubmission: ze, preventScrollReset: je, replace: bt}={}) {
        ie.response.headers.has("X-Remix-Revalidate") && (oe = !0);
        let Qe = ie.response.headers.get("Location");
        en(Qe, "Expected a Location header on the redirect Response"),
        Qe = kb(Qe, new URL(j.url), f);
        let xt = $c(A.location, Qe, {
            _isRedirect: !0
        });
        if (t) {
            let En = !1;
            if (ie.response.headers.has("X-Remix-Reload-Document"))
                En = !0;
            else if (Zv.test(Qe)) {
                const Cn = n.history.createURL(Qe);
                En = Cn.origin !== e.location.origin || or(Cn.pathname, f) == null
            }
            if (En) {
                bt ? e.location.replace(Qe) : e.location.assign(Qe);
                return
            }
        }
        U = null;
        let mt = bt === !0 || ie.response.headers.has("X-Remix-Replace") ? "REPLACE" : "PUSH"
          , {formMethod: Rt, formAction: ft, formEncType: Dt} = A.navigation;
        !Ue && !ze && Rt && ft && Dt && (Ue = Wb(A.navigation));
        let rn = Ue || ze;
        if (C2.has(ie.response.status) && rn && Wi(rn.formMethod))
            await G(mt, xt, {
                submission: {
                    ...rn,
                    formAction: Qe
                },
                preventScrollReset: je || z,
                enableViewTransition: fe ? R : void 0
            });
        else {
            let En = Pm(xt, Ue);
            await G(mt, xt, {
                overrideNavigation: En,
                fetcherSubmission: ze,
                preventScrollReset: je || z,
                enableViewTransition: fe ? R : void 0
            })
        }
    }
    async function I(j, ie, fe, Ue) {
        let ze, je = {};
        try {
            ze = await k2(h, j, ie, Ue, fe, !1)
        } catch (bt) {
            return ie.filter(Qe => Qe.shouldLoad).forEach(Qe => {
                je[Qe.route.id] = {
                    type: "error",
                    error: bt
                }
            }
            ),
            je
        }
        for (let[bt,Qe] of Object.entries(ze))
            if (j2(Qe)) {
                let xt = Qe.result;
                je[bt] = {
                    type: "redirect",
                    response: V2(xt, j, bt, ie, f)
                }
            } else
                je[bt] = await B2(Qe);
        return je
    }
    async function q(j, ie, fe, Ue) {
        let ze = I(fe, j, Ue, null)
          , je = Promise.all(ie.map(async xt => {
            if (xt.matches && xt.match && xt.request && xt.controller) {
                let Rt = (await I(xt.request, xt.matches, Ue, xt.key))[xt.match.route.id];
                return {
                    [xt.key]: Rt
                }
            } else
                return Promise.resolve({
                    [xt.key]: {
                        type: "error",
                        error: nr(404, {
                            pathname: xt.path
                        })
                    }
                })
        }
        ))
          , bt = await ze
          , Qe = (await je).reduce( (xt, mt) => Object.assign(xt, mt), {});
        return {
            loaderResults: bt,
            fetcherResults: Qe
        }
    }
    function se() {
        oe = !0,
        ee.forEach( (j, ie) => {
            O.has(ie) && le.add(ie),
            Le(ie)
        }
        )
    }
    function J(j, ie, fe={}) {
        A.fetchers.set(j, ie),
        He({
            fetchers: new Map(A.fetchers)
        }, {
            flushSync: (fe && fe.flushSync) === !0
        })
    }
    function de(j, ie, fe, Ue={}) {
        let ze = qs(A.matches, ie);
        Ae(j),
        He({
            errors: {
                [ze.route.id]: fe
            },
            fetchers: new Map(A.fetchers)
        }, {
            flushSync: (Ue && Ue.flushSync) === !0
        })
    }
    function _e(j) {
        return ge.set(j, (ge.get(j) || 0) + 1),
        pe.has(j) && pe.delete(j),
        A.fetchers.get(j) || D2
    }
    function Ae(j) {
        let ie = A.fetchers.get(j);
        O.has(j) && !(ie && ie.state === "loading" && Me.has(j)) && Le(j),
        ee.delete(j),
        Me.delete(j),
        k.delete(j),
        pe.delete(j),
        le.delete(j),
        A.fetchers.delete(j)
    }
    function lt(j) {
        let ie = (ge.get(j) || 0) - 1;
        ie <= 0 ? (ge.delete(j),
        pe.add(j)) : ge.set(j, ie),
        He({
            fetchers: new Map(A.fetchers)
        })
    }
    function Le(j) {
        let ie = O.get(j);
        ie && (ie.abort(),
        O.delete(j))
    }
    function $e(j) {
        for (let ie of j) {
            let fe = _e(ie)
              , Ue = os(fe.data);
            A.fetchers.set(ie, Ue)
        }
    }
    function ht() {
        let j = []
          , ie = !1;
        for (let fe of k) {
            let Ue = A.fetchers.get(fe);
            en(Ue, `Expected fetcher: ${fe}`),
            Ue.state === "loading" && (k.delete(fe),
            j.push(fe),
            ie = !0)
        }
        return $e(j),
        ie
    }
    function yt(j) {
        let ie = [];
        for (let[fe,Ue] of Me)
            if (Ue < j) {
                let ze = A.fetchers.get(fe);
                en(ze, `Expected fetcher: ${fe}`),
                ze.state === "loading" && (Le(fe),
                Me.delete(fe),
                ie.push(fe))
            }
        return $e(ie),
        ie.length > 0
    }
    function qe(j, ie) {
        let fe = A.blockers.get(j) || wc;
        return te.get(j) !== ie && te.set(j, ie),
        fe
    }
    function Lt(j) {
        A.blockers.delete(j),
        te.delete(j)
    }
    function Tt(j, ie) {
        let fe = A.blockers.get(j) || wc;
        en(fe.state === "unblocked" && ie.state === "blocked" || fe.state === "blocked" && ie.state === "blocked" || fe.state === "blocked" && ie.state === "proceeding" || fe.state === "blocked" && ie.state === "unblocked" || fe.state === "proceeding" && ie.state === "unblocked", `Invalid blocker state transition: ${fe.state} -> ${ie.state}`);
        let Ue = new Map(A.blockers);
        Ue.set(j, ie),
        He({
            blockers: Ue
        })
    }
    function qt({currentLocation: j, nextLocation: ie, historyAction: fe}) {
        if (te.size === 0)
            return;
        te.size > 1 && Wn(!1, "A router only supports one blocker at a time");
        let Ue = Array.from(te.entries())
          , [ze,je] = Ue[Ue.length - 1]
          , bt = A.blockers.get(ze);
        if (!(bt && bt.state === "proceeding") && je({
            currentLocation: j,
            nextLocation: ie,
            historyAction: fe
        }))
            return ze
    }
    function re(j) {
        let ie = nr(404, {
            pathname: j
        })
          , fe = d || u
          , {matches: Ue, route: ze} = Gb(fe);
        return {
            notFoundMatches: Ue,
            route: ze,
            error: ie
        }
    }
    function Ye(j, ie, fe) {
        if (x = j,
        M = ie,
        E = fe || null,
        !b && A.navigation === Om) {
            b = !0;
            let Ue = Ke(A.location, A.matches);
            Ue != null && He({
                restoreScrollPosition: Ue
            })
        }
        return () => {
            x = null,
            M = null,
            E = null
        }
    }
    function Te(j, ie) {
        return E && E(j, ie.map(Ue => o2(Ue, A.loaderData))) || j.key
    }
    function Ne(j, ie) {
        if (x && M) {
            let fe = Te(j, ie);
            x[fe] = M()
        }
    }
    function Ke(j, ie) {
        if (x) {
            let fe = Te(j, ie)
              , Ue = x[fe];
            if (typeof Ue == "number")
                return Ue
        }
        return null
    }
    function Ce(j, ie, fe) {
        if (n.patchRoutesOnNavigation)
            if (j) {
                if (Object.keys(j[0].params).length > 0)
                    return {
                        active: !0,
                        matches: cf(ie, fe, f, !0)
                    }
            } else
                return {
                    active: !0,
                    matches: cf(ie, fe, f, !0) || []
                };
        return {
            active: !1,
            matches: null
        }
    }
    async function at(j, ie, fe, Ue) {
        if (!n.patchRoutesOnNavigation)
            return {
                type: "success",
                matches: j
            };
        let ze = j;
        for (; ; ) {
            let je = d == null
              , bt = d || u
              , Qe = o;
            try {
                await n.patchRoutesOnNavigation({
                    signal: fe,
                    path: ie,
                    matches: ze,
                    fetcherKey: Ue,
                    patch: (Rt, ft) => {
                        fe.aborted || Ob(Rt, ft, bt, Qe, s)
                    }
                })
            } catch (Rt) {
                return {
                    type: "error",
                    error: Rt,
                    partialMatches: ze
                }
            } finally {
                je && !fe.aborted && (u = [...u])
            }
            if (fe.aborted)
                return {
                    type: "aborted"
                };
            let xt = ds(bt, ie, f);
            if (xt)
                return {
                    type: "success",
                    matches: xt
                };
            let mt = cf(bt, ie, f, !0);
            if (!mt || ze.length === mt.length && ze.every( (Rt, ft) => Rt.route.id === mt[ft].route.id))
                return {
                    type: "success",
                    matches: null
                };
            ze = mt
        }
    }
    function zt(j) {
        o = {},
        d = bf(j, s, void 0, o)
    }
    function nn(j, ie) {
        let fe = d == null;
        Ob(j, ie, d || u, o, s),
        fe && (u = [...u],
        He({}))
    }
    return P = {
        get basename() {
            return f
        },
        get future() {
            return m
        },
        get state() {
            return A
        },
        get routes() {
            return u
        },
        get window() {
            return e
        },
        initialize: De,
        subscribe: _t,
        enableScrollRestoration: Ye,
        navigate: kt,
        fetch: pt,
        revalidate: nt,
        createHref: j => n.history.createHref(j),
        encodeLocation: j => n.history.encodeLocation(j),
        getFetcher: _e,
        deleteFetcher: lt,
        dispose: Ve,
        getBlocker: qe,
        deleteBlocker: Lt,
        patchRoutes: nn,
        _internalFetchControllers: O,
        _internalSetRoutes: zt
    },
    P
}
function N2(n) {
    return n != null && ("formData"in n && n.formData != null || "body"in n && n.body !== void 0)
}
function Ng(n, e, t, r, s, o) {
    let u, d;
    if (s) {
        u = [];
        for (let h of e)
            if (u.push(h),
            h.route.id === s) {
                d = h;
                break
            }
    } else
        u = e,
        d = e[e.length - 1];
    let f = Yv(r || ".", qv(u), or(n.pathname, t) || n.pathname, o === "path");
    if (r == null && (f.search = n.search,
    f.hash = n.hash),
    (r == null || r === "" || r === ".") && d) {
        let h = $v(f.search);
        if (d.route.index && !h)
            f.search = f.search ? f.search.replace(/^\?/, "?index&") : "?index";
        else if (!d.route.index && h) {
            let m = new URLSearchParams(f.search)
              , g = m.getAll("index");
            m.delete("index"),
            g.filter(x => x).forEach(x => m.append("index", x));
            let _ = m.toString();
            f.search = _ ? `?${_}` : ""
        }
    }
    return t !== "/" && (f.pathname = f.pathname === "/" ? t : Or([t, f.pathname])),
    vs(f)
}
function Lb(n, e, t) {
    if (!t || !N2(t))
        return {
            path: e
        };
    if (t.formMethod && !W2(t.formMethod))
        return {
            path: e,
            error: nr(405, {
                method: t.formMethod
            })
        };
    let r = () => ({
        path: e,
        error: nr(400, {
            type: "invalid-body"
        })
    })
      , o = (t.formMethod || "get").toUpperCase()
      , u = wM(e);
    if (t.body !== void 0) {
        if (t.formEncType === "text/plain") {
            if (!Wi(o))
                return r();
            let g = typeof t.body == "string" ? t.body : t.body instanceof FormData || t.body instanceof URLSearchParams ? Array.from(t.body.entries()).reduce( (_, [x,E]) => `${_}${x}=${E}
`, "") : String(t.body);
            return {
                path: e,
                submission: {
                    formMethod: o,
                    formAction: u,
                    formEncType: t.formEncType,
                    formData: void 0,
                    json: void 0,
                    text: g
                }
            }
        } else if (t.formEncType === "application/json") {
            if (!Wi(o))
                return r();
            try {
                let g = typeof t.body == "string" ? JSON.parse(t.body) : t.body;
                return {
                    path: e,
                    submission: {
                        formMethod: o,
                        formAction: u,
                        formEncType: t.formEncType,
                        formData: void 0,
                        json: g,
                        text: void 0
                    }
                }
            } catch {
                return r()
            }
        }
    }
    en(typeof FormData == "function", "FormData is not available in this environment");
    let d, f;
    if (t.formData)
        d = Ig(t.formData),
        f = t.formData;
    else if (t.body instanceof FormData)
        d = Ig(t.body),
        f = t.body;
    else if (t.body instanceof URLSearchParams)
        d = t.body,
        f = Fb(d);
    else if (t.body == null)
        d = new URLSearchParams,
        f = new FormData;
    else
        try {
            d = new URLSearchParams(t.body),
            f = Fb(d)
        } catch {
            return r()
        }
    let h = {
        formMethod: o,
        formAction: u,
        formEncType: t && t.formEncType || "application/x-www-form-urlencoded",
        formData: f,
        json: void 0,
        text: void 0
    };
    if (Wi(h.formMethod))
        return {
            path: e,
            submission: h
        };
    let m = bs(e);
    return n && m.search && $v(m.search) && d.append("index", ""),
    m.search = `?${d}`,
    {
        path: vs(m),
        submission: h
    }
}
function Nb(n, e, t, r, s, o, u, d, f, h, m, g, _, x, E, M, b, y, T) {
    var Q;
    let D = T ? ji(T[1]) ? T[1].error : T[1].data : void 0, C = s.createURL(o.location), P = s.createURL(f), A;
    if (m && o.errors) {
        let X = Object.keys(o.errors)[0];
        A = u.findIndex(oe => oe.route.id === X)
    } else if (T && ji(T[1])) {
        let X = T[0];
        A = u.findIndex(oe => oe.route.id === X) - 1
    }
    let F = T ? T[1].statusCode : void 0
      , z = F && F >= 400
      , U = {
        currentUrl: C,
        currentParams: ((Q = o.matches[0]) == null ? void 0 : Q.params) || {},
        nextUrl: P,
        nextParams: u[0].params,
        ...d,
        actionResult: D,
        actionStatus: F
    }
      , R = u.map( (X, oe) => {
        let {route: le} = X
          , O = null;
        if (A != null && oe > A ? O = !1 : le.lazy ? O = !0 : le.loader == null ? O = !1 : m ? O = Og(le, o.loaderData, o.errors) : O2(o.loaderData, o.matches[oe], X) && (O = !0),
        O !== null)
            return Pg(t, r, n, X, h, e, O);
        let W = z ? !1 : g || C.pathname + C.search === P.pathname + P.search || C.search !== P.search || P2(o.matches[oe], X)
          , H = {
            ...U,
            defaultShouldRevalidate: W
        }
          , Me = Mf(X, H);
        return Pg(t, r, n, X, h, e, Me, H)
    }
    )
      , V = [];
    return E.forEach( (X, oe) => {
        if (m || !u.some(ee => ee.route.id === X.routeId) || x.has(oe))
            return;
        let le = ds(b, X.path, y);
        if (!le) {
            V.push({
                key: oe,
                routeId: X.routeId,
                path: X.path,
                matches: null,
                match: null,
                request: null,
                controller: null
            });
            return
        }
        if (M.has(oe))
            return;
        let O = o.fetchers.get(oe)
          , W = zc(le, X.path)
          , H = new AbortController
          , Me = sl(s, X.path, H.signal)
          , k = null;
        if (_.has(oe))
            _.delete(oe),
            k = cl(t, r, Me, le, W, h, e);
        else if (O && O.state !== "idle" && O.data === void 0)
            g && (k = cl(t, r, Me, le, W, h, e));
        else {
            let ee = {
                ...U,
                defaultShouldRevalidate: z ? !1 : g
            };
            Mf(W, ee) && (k = cl(t, r, Me, le, W, h, e, ee))
        }
        k && V.push({
            key: oe,
            routeId: X.routeId,
            path: X.path,
            matches: k,
            match: W,
            request: Me,
            controller: H
        })
    }
    ),
    {
        dsMatches: R,
        revalidatingFetchers: V
    }
}
function Og(n, e, t) {
    if (n.lazy)
        return !0;
    if (!n.loader)
        return !1;
    let r = e != null && e[n.id] !== void 0
      , s = t != null && t[n.id] !== void 0;
    return !r && s ? !1 : typeof n.loader == "function" && n.loader.hydrate === !0 ? !0 : !r && !s
}
function O2(n, e, t) {
    let r = !e || t.route.id !== e.route.id
      , s = !n.hasOwnProperty(t.route.id);
    return r || s
}
function P2(n, e) {
    let t = n.route.path;
    return n.pathname !== e.pathname || t != null && t.endsWith("*") && n.params["*"] !== e.params["*"]
}
function Mf(n, e) {
    if (n.route.shouldRevalidate) {
        let t = n.route.shouldRevalidate(e);
        if (typeof t == "boolean")
            return t
    }
    return e.defaultShouldRevalidate
}
function Ob(n, e, t, r, s) {
    let o;
    if (n) {
        let f = r[n];
        en(f, `No route found to patch children into: routeId = ${n}`),
        f.children || (f.children = []),
        o = f.children
    } else
        o = t;
    let u = e.filter(f => !o.some(h => xM(f, h)))
      , d = bf(u, s, [n || "_", "patch", String((o == null ? void 0 : o.length) || "0")], r);
    o.push(...d)
}
function xM(n, e) {
    return "id"in n && "id"in e && n.id === e.id ? !0 : n.index === e.index && n.path === e.path && n.caseSensitive === e.caseSensitive ? (!n.children || n.children.length === 0) && (!e.children || e.children.length === 0) ? !0 : n.children.every( (t, r) => {
        var s;
        return (s = e.children) == null ? void 0 : s.some(o => xM(t, o))
    }
    ) : !1
}
var Pb = new WeakMap
  , bM = ({key: n, route: e, manifest: t, mapRouteProperties: r}) => {
    let s = t[e.id];
    if (en(s, "No route found in manifest"),
    !s.lazy || typeof s.lazy != "object")
        return;
    let o = s.lazy[n];
    if (!o)
        return;
    let u = Pb.get(s);
    u || (u = {},
    Pb.set(s, u));
    let d = u[n];
    if (d)
        return d;
    let f = (async () => {
        let h = i2(n)
          , g = s[n] !== void 0 && n !== "hasErrorBoundary";
        if (h)
            Wn(!h, "Route property " + n + " is not a supported lazy route property. This property will be ignored."),
            u[n] = Promise.resolve();
        else if (g)
            Wn(!1, `Route "${s.id}" has a static property "${n}" defined. The lazy property will be ignored.`);
        else {
            let _ = await o();
            _ != null && (Object.assign(s, {
                [n]: _
            }),
            Object.assign(s, r(s)))
        }
        typeof s.lazy == "object" && (s.lazy[n] = void 0,
        Object.values(s.lazy).every(_ => _ === void 0) && (s.lazy = void 0))
    }
    )();
    return u[n] = f,
    f
}
  , Ib = new WeakMap;
function I2(n, e, t, r, s) {
    let o = t[n.id];
    if (en(o, "No route found in manifest"),
    !n.lazy)
        return {
            lazyRoutePromise: void 0,
            lazyHandlerPromise: void 0
        };
    if (typeof n.lazy == "function") {
        let m = Ib.get(o);
        if (m)
            return {
                lazyRoutePromise: m,
                lazyHandlerPromise: m
            };
        let g = (async () => {
            en(typeof n.lazy == "function", "No lazy route function found");
            let _ = await n.lazy()
              , x = {};
            for (let E in _) {
                let M = _[E];
                if (M === void 0)
                    continue;
                let b = a2(E)
                  , T = o[E] !== void 0 && E !== "hasErrorBoundary";
                b ? Wn(!b, "Route property " + E + " is not a supported property to be returned from a lazy route function. This property will be ignored.") : T ? Wn(!T, `Route "${o.id}" has a static property "${E}" defined but its lazy function is also returning a value for this property. The lazy route property "${E}" will be ignored.`) : x[E] = M
            }
            Object.assign(o, x),
            Object.assign(o, {
                ...r(o),
                lazy: void 0
            })
        }
        )();
        return Ib.set(o, g),
        g.catch( () => {}
        ),
        {
            lazyRoutePromise: g,
            lazyHandlerPromise: g
        }
    }
    let u = Object.keys(n.lazy), d = [], f;
    for (let m of u) {
        if (s && s.includes(m))
            continue;
        let g = bM({
            key: m,
            route: n,
            manifest: t,
            mapRouteProperties: r
        });
        g && (d.push(g),
        m === e && (f = g))
    }
    let h = d.length > 0 ? Promise.all(d).then( () => {}
    ) : void 0;
    return h == null || h.catch( () => {}
    ),
    f == null || f.catch( () => {}
    ),
    {
        lazyRoutePromise: h,
        lazyHandlerPromise: f
    }
}
async function zb(n) {
    let e = n.matches.filter(s => s.shouldLoad)
      , t = {};
    return (await Promise.all(e.map(s => s.resolve()))).forEach( (s, o) => {
        t[e[o].route.id] = s
    }
    ),
    t
}
async function z2(n) {
    return n.matches.some(e => e.route.unstable_middleware) ? SM(n, !1, () => zb(n), (e, t) => ({
        [t]: {
            type: "error",
            result: e
        }
    })) : zb(n)
}
async function SM(n, e, t, r) {
    let {matches: s, request: o, params: u, context: d} = n
      , f = {
        handlerResult: void 0
    };
    try {
        let h = s.flatMap(g => g.route.unstable_middleware ? g.route.unstable_middleware.map(_ => [g.route.id, _]) : [])
          , m = await EM({
            request: o,
            params: u,
            context: d
        }, h, e, f, t);
        return e ? m : f.handlerResult
    } catch (h) {
        if (!f.middlewareError)
            throw h;
        let m = await r(f.middlewareError.error, f.middlewareError.routeId);
        return f.handlerResult ? Object.assign(f.handlerResult, m) : m
    }
}
async function EM(n, e, t, r, s, o=0) {
    let {request: u} = n;
    if (u.signal.aborted)
        throw u.signal.reason ? u.signal.reason : new Error(`Request aborted without an \`AbortSignal.reason\`: ${u.method} ${u.url}`);
    let d = e[o];
    if (!d)
        return r.handlerResult = await s(),
        r.handlerResult;
    let[f,h] = d, m = !1, g, _ = async () => {
        if (m)
            throw new Error("You may only call `next()` once per middleware");
        m = !0,
        await EM(n, e, t, r, s, o + 1)
    }
    ;
    try {
        let x = await h({
            request: n.request,
            params: n.params,
            context: n.context
        }, _);
        return m ? x === void 0 ? g : x : _()
    } catch (x) {
        throw r.middlewareError ? r.middlewareError.error !== x && (r.middlewareError = {
            routeId: f,
            error: x
        }) : r.middlewareError = {
            routeId: f,
            error: x
        },
        x
    }
}
function MM(n, e, t, r, s) {
    let o = bM({
        key: "unstable_middleware",
        route: r.route,
        manifest: e,
        mapRouteProperties: n
    })
      , u = I2(r.route, Wi(t.method) ? "action" : "loader", e, n, s);
    return {
        middleware: o,
        route: u.lazyRoutePromise,
        handler: u.lazyHandlerPromise
    }
}
function Pg(n, e, t, r, s, o, u, d=null) {
    let f = !1
      , h = MM(n, e, t, r, s);
    return {
        ...r,
        _lazyPromises: h,
        shouldLoad: u,
        unstable_shouldRevalidateArgs: d,
        unstable_shouldCallHandler(m) {
            return f = !0,
            d ? typeof m == "boolean" ? Mf(r, {
                ...d,
                defaultShouldRevalidate: m
            }) : Mf(r, d) : u
        },
        resolve(m) {
            return f || u || m && t.method === "GET" && (r.route.lazy || r.route.loader) ? F2({
                request: t,
                match: r,
                lazyHandlerPromise: h == null ? void 0 : h.handler,
                lazyRoutePromise: h == null ? void 0 : h.route,
                handlerOverride: m,
                scopedContext: o
            }) : Promise.resolve({
                type: "data",
                result: void 0
            })
        }
    }
}
function cl(n, e, t, r, s, o, u, d=null) {
    return r.map(f => f.route.id !== s.route.id ? {
        ...f,
        shouldLoad: !1,
        unstable_shouldRevalidateArgs: d,
        unstable_shouldCallHandler: () => !1,
        _lazyPromises: MM(n, e, t, f, o),
        resolve: () => Promise.resolve({
            type: "data",
            result: void 0
        })
    } : Pg(n, e, t, f, o, u, !0, d))
}
async function k2(n, e, t, r, s, o) {
    t.some(h => {
        var m;
        return (m = h._lazyPromises) == null ? void 0 : m.middleware
    }
    ) && await Promise.all(t.map(h => {
        var m;
        return (m = h._lazyPromises) == null ? void 0 : m.middleware
    }
    ));
    let u = {
        request: e,
        params: t[0].params,
        context: s,
        matches: t
    }
      , f = await n({
        ...u,
        fetcherKey: r,
        unstable_runClientMiddleware: h => {
            let m = u;
            return SM(m, !1, () => h({
                ...m,
                fetcherKey: r,
                unstable_runClientMiddleware: () => {
                    throw new Error("Cannot call `unstable_runClientMiddleware()` from within an `unstable_runClientMiddleware` handler")
                }
            }), (g, _) => ({
                [_]: {
                    type: "error",
                    result: g
                }
            }))
        }
    });
    try {
        await Promise.all(t.flatMap(h => {
            var m, g;
            return [(m = h._lazyPromises) == null ? void 0 : m.handler, (g = h._lazyPromises) == null ? void 0 : g.route]
        }
        ))
    } catch {}
    return f
}
async function F2({request: n, match: e, lazyHandlerPromise: t, lazyRoutePromise: r, handlerOverride: s, scopedContext: o}) {
    let u, d, f = Wi(n.method), h = f ? "action" : "loader", m = g => {
        let _, x = new Promise( (b, y) => _ = y);
        d = () => _(),
        n.signal.addEventListener("abort", d);
        let E = b => typeof g != "function" ? Promise.reject(new Error(`You cannot call the handler for a route which defines a boolean "${h}" [routeId: ${e.route.id}]`)) : g({
            request: n,
            params: e.params,
            context: o
        }, ...b !== void 0 ? [b] : [])
          , M = (async () => {
            try {
                return {
                    type: "data",
                    result: await (s ? s(y => E(y)) : E())
                }
            } catch (b) {
                return {
                    type: "error",
                    result: b
                }
            }
        }
        )();
        return Promise.race([M, x])
    }
    ;
    try {
        let g = f ? e.route.action : e.route.loader;
        if (t || r)
            if (g) {
                let _, [x] = await Promise.all([m(g).catch(E => {
                    _ = E
                }
                ), t, r]);
                if (_ !== void 0)
                    throw _;
                u = x
            } else {
                await t;
                let _ = f ? e.route.action : e.route.loader;
                if (_)
                    [u] = await Promise.all([m(_), r]);
                else if (h === "action") {
                    let x = new URL(n.url)
                      , E = x.pathname + x.search;
                    throw nr(405, {
                        method: n.method,
                        pathname: E,
                        routeId: e.route.id
                    })
                } else
                    return {
                        type: "data",
                        result: void 0
                    }
            }
        else if (g)
            u = await m(g);
        else {
            let _ = new URL(n.url)
              , x = _.pathname + _.search;
            throw nr(404, {
                pathname: x
            })
        }
    } catch (g) {
        return {
            type: "error",
            result: g
        }
    } finally {
        d && n.signal.removeEventListener("abort", d)
    }
    return u
}
async function B2(n) {
    var r, s, o, u, d, f;
    let {result: e, type: t} = n;
    if (TM(e)) {
        let h;
        try {
            let m = e.headers.get("Content-Type");
            m && /\bapplication\/json\b/.test(m) ? e.body == null ? h = null : h = await e.json() : h = await e.text()
        } catch (m) {
            return {
                type: "error",
                error: m
            }
        }
        return t === "error" ? {
            type: "error",
            error: new Ef(e.status,e.statusText,h),
            statusCode: e.status,
            headers: e.headers
        } : {
            type: "data",
            data: h,
            statusCode: e.status,
            headers: e.headers
        }
    }
    return t === "error" ? jb(e) ? e.data instanceof Error ? {
        type: "error",
        error: e.data,
        statusCode: (r = e.init) == null ? void 0 : r.status,
        headers: (s = e.init) != null && s.headers ? new Headers(e.init.headers) : void 0
    } : {
        type: "error",
        error: new Ef(((o = e.init) == null ? void 0 : o.status) || 500,void 0,e.data),
        statusCode: Kc(e) ? e.status : void 0,
        headers: (u = e.init) != null && u.headers ? new Headers(e.init.headers) : void 0
    } : {
        type: "error",
        error: e,
        statusCode: Kc(e) ? e.status : void 0
    } : jb(e) ? {
        type: "data",
        data: e.data,
        statusCode: (d = e.init) == null ? void 0 : d.status,
        headers: (f = e.init) != null && f.headers ? new Headers(e.init.headers) : void 0
    } : {
        type: "data",
        data: e
    }
}
function V2(n, e, t, r, s) {
    let o = n.headers.get("Location");
    if (en(o, "Redirects returned/thrown from loaders/actions must have a Location header"),
    !Zv.test(o)) {
        let u = r.slice(0, r.findIndex(d => d.route.id === t) + 1);
        o = Ng(new URL(e.url), u, s, o),
        n.headers.set("Location", o)
    }
    return n
}
function kb(n, e, t) {
    if (Zv.test(n)) {
        let r = n
          , s = r.startsWith("//") ? new URL(e.protocol + r) : new URL(r)
          , o = or(s.pathname, t) != null;
        if (s.origin === e.origin && o)
            return s.pathname + s.search + s.hash
    }
    return n
}
function sl(n, e, t, r) {
    let s = n.createURL(wM(e)).toString()
      , o = {
        signal: t
    };
    if (r && Wi(r.formMethod)) {
        let {formMethod: u, formEncType: d} = r;
        o.method = u.toUpperCase(),
        d === "application/json" ? (o.headers = new Headers({
            "Content-Type": d
        }),
        o.body = JSON.stringify(r.json)) : d === "text/plain" ? o.body = r.text : d === "application/x-www-form-urlencoded" && r.formData ? o.body = Ig(r.formData) : o.body = r.formData
    }
    return new Request(s,o)
}
function Ig(n) {
    let e = new URLSearchParams;
    for (let[t,r] of n.entries())
        e.append(t, typeof r == "string" ? r : r.name);
    return e
}
function Fb(n) {
    let e = new FormData;
    for (let[t,r] of n.entries())
        e.append(t, r);
    return e
}
function H2(n, e, t, r=!1, s=!1) {
    let o = {}, u = null, d, f = !1, h = {}, m = t && ji(t[1]) ? t[1].error : void 0;
    return n.forEach(g => {
        if (!(g.route.id in e))
            return;
        let _ = g.route.id
          , x = e[_];
        if (en(!$s(x), "Cannot handle redirect results in processLoaderData"),
        ji(x)) {
            let E = x.error;
            if (m !== void 0 && (E = m,
            m = void 0),
            u = u || {},
            s)
                u[_] = E;
            else {
                let M = qs(n, _);
                u[M.route.id] == null && (u[M.route.id] = E)
            }
            r || (o[_] = yM),
            f || (f = !0,
            d = Kc(x.error) ? x.error.status : 500),
            x.headers && (h[_] = x.headers)
        } else
            o[_] = x.data,
            x.statusCode && x.statusCode !== 200 && !f && (d = x.statusCode),
            x.headers && (h[_] = x.headers)
    }
    ),
    m !== void 0 && t && (u = {
        [t[0]]: m
    },
    o[t[0]] = void 0),
    {
        loaderData: o,
        errors: u,
        statusCode: d || 200,
        loaderHeaders: h
    }
}
function Bb(n, e, t, r, s, o) {
    let {loaderData: u, errors: d} = H2(e, t, r);
    return s.filter(f => !f.matches || f.matches.some(h => h.shouldLoad)).forEach(f => {
        let {key: h, match: m, controller: g} = f
          , _ = o[h];
        if (en(_, "Did not find corresponding fetcher result"),
        !(g && g.signal.aborted))
            if (ji(_)) {
                let x = qs(n.matches, m == null ? void 0 : m.route.id);
                d && d[x.route.id] || (d = {
                    ...d,
                    [x.route.id]: _.error
                }),
                n.fetchers.delete(h)
            } else if ($s(_))
                en(!1, "Unhandled fetcher revalidation redirect");
            else {
                let x = os(_.data);
                n.fetchers.set(h, x)
            }
    }
    ),
    {
        loaderData: u,
        errors: d
    }
}
function Vb(n, e, t, r) {
    let s = Object.entries(e).filter( ([,o]) => o !== yM).reduce( (o, [u,d]) => (o[u] = d,
    o), {});
    for (let o of t) {
        let u = o.route.id;
        if (!e.hasOwnProperty(u) && n.hasOwnProperty(u) && o.route.loader && (s[u] = n[u]),
        r && r.hasOwnProperty(u))
            break
    }
    return s
}
function Hb(n) {
    return n ? ji(n[1]) ? {
        actionData: {}
    } : {
        actionData: {
            [n[0]]: n[1].data
        }
    } : {}
}
function qs(n, e) {
    return (e ? n.slice(0, n.findIndex(r => r.route.id === e) + 1) : [...n]).reverse().find(r => r.route.hasErrorBoundary === !0) || n[0]
}
function Gb(n) {
    let e = n.length === 1 ? n[0] : n.find(t => t.index || !t.path || t.path === "/") || {
        id: "__shim-error-route__"
    };
    return {
        matches: [{
            params: {},
            pathname: "",
            pathnameBase: "",
            route: e
        }],
        route: e
    }
}
function nr(n, {pathname: e, routeId: t, method: r, type: s, message: o}={}) {
    let u = "Unknown Server Error"
      , d = "Unknown @remix-run/router error";
    return n === 400 ? (u = "Bad Request",
    r && e && t ? d = `You made a ${r} request to "${e}" but did not provide a \`loader\` for route "${t}", so there is no way to handle the request.` : s === "invalid-body" && (d = "Unable to encode submission body")) : n === 403 ? (u = "Forbidden",
    d = `Route "${t}" does not match URL "${e}"`) : n === 404 ? (u = "Not Found",
    d = `No route matches URL "${e}"`) : n === 405 && (u = "Method Not Allowed",
    r && e && t ? d = `You made a ${r.toUpperCase()} request to "${e}" but did not provide an \`action\` for route "${t}", so there is no way to handle the request.` : r && (d = `Invalid request method "${r.toUpperCase()}"`)),
    new Ef(n || 500,u,new Error(d),!0)
}
function Ld(n) {
    let e = Object.entries(n);
    for (let t = e.length - 1; t >= 0; t--) {
        let[r,s] = e[t];
        if ($s(s))
            return {
                key: r,
                result: s
            }
    }
}
function wM(n) {
    let e = typeof n == "string" ? bs(n) : n;
    return vs({
        ...e,
        hash: ""
    })
}
function G2(n, e) {
    return n.pathname !== e.pathname || n.search !== e.search ? !1 : n.hash === "" ? e.hash !== "" : n.hash === e.hash ? !0 : e.hash !== ""
}
function j2(n) {
    return TM(n.result) && R2.has(n.result.status)
}
function ji(n) {
    return n.type === "error"
}
function $s(n) {
    return (n && n.type) === "redirect"
}
function jb(n) {
    return typeof n == "object" && n != null && "type"in n && "data"in n && "init"in n && n.type === "DataWithResponseInit"
}
function TM(n) {
    return n != null && typeof n.status == "number" && typeof n.statusText == "string" && typeof n.headers == "object" && typeof n.body < "u"
}
function W2(n) {
    return A2.has(n.toUpperCase())
}
function Wi(n) {
    return w2.has(n.toUpperCase())
}
function $v(n) {
    return new URLSearchParams(n).getAll("index").some(e => e === "")
}
function zc(n, e) {
    let t = typeof e == "string" ? bs(e).search : e.search;
    if (n[n.length - 1].route.index && $v(t || ""))
        return n[n.length - 1];
    let r = gM(n);
    return r[r.length - 1]
}
function Wb(n) {
    let {formMethod: e, formAction: t, formEncType: r, text: s, formData: o, json: u} = n;
    if (!(!e || !t || !r)) {
        if (s != null)
            return {
                formMethod: e,
                formAction: t,
                formEncType: r,
                formData: void 0,
                json: void 0,
                text: s
            };
        if (o != null)
            return {
                formMethod: e,
                formAction: t,
                formEncType: r,
                formData: o,
                json: void 0,
                text: void 0
            };
        if (u !== void 0)
            return {
                formMethod: e,
                formAction: t,
                formEncType: r,
                formData: void 0,
                json: u,
                text: void 0
            }
    }
}
function Pm(n, e) {
    return e ? {
        state: "loading",
        location: n,
        formMethod: e.formMethod,
        formAction: e.formAction,
        formEncType: e.formEncType,
        formData: e.formData,
        json: e.json,
        text: e.text
    } : {
        state: "loading",
        location: n,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0
    }
}
function X2(n, e) {
    return {
        state: "submitting",
        location: n,
        formMethod: e.formMethod,
        formAction: e.formAction,
        formEncType: e.formEncType,
        formData: e.formData,
        json: e.json,
        text: e.text
    }
}
function Tc(n, e) {
    return n ? {
        state: "loading",
        formMethod: n.formMethod,
        formAction: n.formAction,
        formEncType: n.formEncType,
        formData: n.formData,
        json: n.json,
        text: n.text,
        data: e
    } : {
        state: "loading",
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0,
        data: e
    }
}
function q2(n, e) {
    return {
        state: "submitting",
        formMethod: n.formMethod,
        formAction: n.formAction,
        formEncType: n.formEncType,
        formData: n.formData,
        json: n.json,
        text: n.text,
        data: e ? e.data : void 0
    }
}
function os(n) {
    return {
        state: "idle",
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0,
        data: n
    }
}
function Y2(n, e) {
    try {
        let t = n.sessionStorage.getItem(_M);
        if (t) {
            let r = JSON.parse(t);
            for (let[s,o] of Object.entries(r || {}))
                o && Array.isArray(o) && e.set(s, new Set(o || []))
        }
    } catch {}
}
function Z2(n, e) {
    if (e.size > 0) {
        let t = {};
        for (let[r,s] of e)
            t[r] = [...s];
        try {
            n.sessionStorage.setItem(_M, JSON.stringify(t))
        } catch (r) {
            Wn(!1, `Failed to save applied view transitions in sessionStorage (${r}).`)
        }
    }
}
function $2() {
    let n, e, t = new Promise( (r, s) => {
        n = async o => {
            r(o);
            try {
                await t
            } catch {}
        }
        ,
        e = async o => {
            s(o);
            try {
                await t
            } catch {}
        }
    }
    );
    return {
        promise: t,
        resolve: n,
        reject: e
    }
}
var so = $.createContext(null);
so.displayName = "DataRouter";
var uu = $.createContext(null);
uu.displayName = "DataRouterState";
var Kv = $.createContext({
    isTransitioning: !1
});
Kv.displayName = "ViewTransition";
var AM = $.createContext(new Map);
AM.displayName = "Fetchers";
var K2 = $.createContext(null);
K2.displayName = "Await";
var Fr = $.createContext(null);
Fr.displayName = "Navigation";
var eh = $.createContext(null);
eh.displayName = "Location";
var Br = $.createContext({
    outlet: null,
    matches: [],
    isDataRoute: !1
});
Br.displayName = "Route";
var Qv = $.createContext(null);
Qv.displayName = "RouteError";
function Q2(n, {relative: e}={}) {
    en(du(), "useHref() may be used only in the context of a <Router> component.");
    let {basename: t, navigator: r} = $.useContext(Fr)
      , {hash: s, pathname: o, search: u} = fu(n, {
        relative: e
    })
      , d = o;
    return t !== "/" && (d = o === "/" ? t : Or([t, o])),
    r.createHref({
        pathname: d,
        search: u,
        hash: s
    })
}
function du() {
    return $.useContext(eh) != null
}
function oo() {
    return en(du(), "useLocation() may be used only in the context of a <Router> component."),
    $.useContext(eh).location
}
var RM = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function CM(n) {
    $.useContext(Fr).static || $.useLayoutEffect(n)
}
function Ml() {
    let {isDataRoute: n} = $.useContext(Br);
    return n ? hD() : J2()
}
function J2() {
    en(du(), "useNavigate() may be used only in the context of a <Router> component.");
    let n = $.useContext(so)
      , {basename: e, navigator: t} = $.useContext(Fr)
      , {matches: r} = $.useContext(Br)
      , {pathname: s} = oo()
      , o = JSON.stringify(qv(r))
      , u = $.useRef(!1);
    return CM( () => {
        u.current = !0
    }
    ),
    $.useCallback( (f, h={}) => {
        if (Wn(u.current, RM),
        !u.current)
            return;
        if (typeof f == "number") {
            t.go(f);
            return
        }
        let m = Yv(f, JSON.parse(o), s, h.relative === "path");
        n == null && e !== "/" && (m.pathname = m.pathname === "/" ? e : Or([e, m.pathname])),
        (h.replace ? t.replace : t.push)(m, h.state, h)
    }
    , [e, t, o, s, n])
}
var eD = $.createContext(null);
function tD(n) {
    let e = $.useContext(Br).outlet;
    return e && $.createElement(eD.Provider, {
        value: n
    }, e)
}
function fu(n, {relative: e}={}) {
    let {matches: t} = $.useContext(Br)
      , {pathname: r} = oo()
      , s = JSON.stringify(qv(t));
    return $.useMemo( () => Yv(n, JSON.parse(s), r, e === "path"), [n, s, r, e])
}
function nD(n, e, t, r) {
    en(du(), "useRoutes() may be used only in the context of a <Router> component.");
    let {navigator: s, static: o} = $.useContext(Fr)
      , {matches: u} = $.useContext(Br)
      , d = u[u.length - 1]
      , f = d ? d.params : {}
      , h = d ? d.pathname : "/"
      , m = d ? d.pathnameBase : "/"
      , g = d && d.route;
    {
        let T = g && g.path || "";
        DM(h, !g || T.endsWith("*") || T.endsWith("*?"), `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${h}" (under <Route path="${T}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${T}"> to <Route path="${T === "/" ? "*" : `${T}/*`}">.`)
    }
    let _ = oo(), x;
    x = _;
    let E = x.pathname || "/"
      , M = E;
    if (m !== "/") {
        let T = m.replace(/^\//, "").split("/");
        M = "/" + E.replace(/^\//, "").split("/").slice(T.length).join("/")
    }
    let b = !o && t && t.matches && t.matches.length > 0 ? t.matches : ds(n, {
        pathname: M
    });
    return Wn(g || b != null, `No routes matched location "${x.pathname}${x.search}${x.hash}" `),
    Wn(b == null || b[b.length - 1].route.element !== void 0 || b[b.length - 1].route.Component !== void 0 || b[b.length - 1].route.lazy !== void 0, `Matched leaf route at location "${x.pathname}${x.search}${x.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`),
    oD(b && b.map(T => Object.assign({}, T, {
        params: Object.assign({}, f, T.params),
        pathname: Or([m, s.encodeLocation ? s.encodeLocation(T.pathname).pathname : T.pathname]),
        pathnameBase: T.pathnameBase === "/" ? m : Or([m, s.encodeLocation ? s.encodeLocation(T.pathnameBase).pathname : T.pathnameBase])
    })), u, t, r)
}
function iD() {
    let n = fD()
      , e = Kc(n) ? `${n.status} ${n.statusText}` : n instanceof Error ? n.message : JSON.stringify(n)
      , t = n instanceof Error ? n.stack : null
      , r = "rgba(200,200,200, 0.5)"
      , s = {
        padding: "0.5rem",
        backgroundColor: r
    }
      , o = {
        padding: "2px 4px",
        backgroundColor: r
    }
      , u = null;
    return console.error("Error handled by React Router default ErrorBoundary:", n),
    u = $.createElement($.Fragment, null, $.createElement("p", null, " Hey developer "), $.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", $.createElement("code", {
        style: o
    }, "ErrorBoundary"), " or", " ", $.createElement("code", {
        style: o
    }, "errorElement"), " prop on your route.")),
    $.createElement($.Fragment, null, $.createElement("h2", null, "Unexpected Application Error!"), $.createElement("h3", {
        style: {
            fontStyle: "italic"
        }
    }, e), t ? $.createElement("pre", {
        style: s
    }, t) : null, u)
}
var rD = $.createElement(iD, null)
  , aD = class extends $.Component {
    constructor(n) {
        super(n),
        this.state = {
            location: n.location,
            revalidation: n.revalidation,
            error: n.error
        }
    }
    static getDerivedStateFromError(n) {
        return {
            error: n
        }
    }
    static getDerivedStateFromProps(n, e) {
        return e.location !== n.location || e.revalidation !== "idle" && n.revalidation === "idle" ? {
            error: n.error,
            location: n.location,
            revalidation: n.revalidation
        } : {
            error: n.error !== void 0 ? n.error : e.error,
            location: e.location,
            revalidation: n.revalidation || e.revalidation
        }
    }
    componentDidCatch(n, e) {
        console.error("React Router caught the following error during render", n, e)
    }
    render() {
        return this.state.error !== void 0 ? $.createElement(Br.Provider, {
            value: this.props.routeContext
        }, $.createElement(Qv.Provider, {
            value: this.state.error,
            children: this.props.component
        })) : this.props.children
    }
}
;
function sD({routeContext: n, match: e, children: t}) {
    let r = $.useContext(so);
    return r && r.static && r.staticContext && (e.route.errorElement || e.route.ErrorBoundary) && (r.staticContext._deepestRenderedBoundaryId = e.route.id),
    $.createElement(Br.Provider, {
        value: n
    }, t)
}
function oD(n, e=[], t=null, r=null) {
    if (n == null) {
        if (!t)
            return null;
        if (t.errors)
            n = t.matches;
        else if (e.length === 0 && !t.initialized && t.matches.length > 0)
            n = t.matches;
        else
            return null
    }
    let s = n
      , o = t == null ? void 0 : t.errors;
    if (o != null) {
        let f = s.findIndex(h => h.route.id && (o == null ? void 0 : o[h.route.id]) !== void 0);
        en(f >= 0, `Could not find a matching route for errors on route IDs: ${Object.keys(o).join(",")}`),
        s = s.slice(0, Math.min(s.length, f + 1))
    }
    let u = !1
      , d = -1;
    if (t)
        for (let f = 0; f < s.length; f++) {
            let h = s[f];
            if ((h.route.HydrateFallback || h.route.hydrateFallbackElement) && (d = f),
            h.route.id) {
                let {loaderData: m, errors: g} = t
                  , _ = h.route.loader && !m.hasOwnProperty(h.route.id) && (!g || g[h.route.id] === void 0);
                if (h.route.lazy || _) {
                    u = !0,
                    d >= 0 ? s = s.slice(0, d + 1) : s = [s[0]];
                    break
                }
            }
        }
    return s.reduceRight( (f, h, m) => {
        let g, _ = !1, x = null, E = null;
        t && (g = o && h.route.id ? o[h.route.id] : void 0,
        x = h.route.errorElement || rD,
        u && (d < 0 && m === 0 ? (DM("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"),
        _ = !0,
        E = null) : d === m && (_ = !0,
        E = h.route.hydrateFallbackElement || null)));
        let M = e.concat(s.slice(0, m + 1))
          , b = () => {
            let y;
            return g ? y = x : _ ? y = E : h.route.Component ? y = $.createElement(h.route.Component, null) : h.route.element ? y = h.route.element : y = f,
            $.createElement(sD, {
                match: h,
                routeContext: {
                    outlet: f,
                    matches: M,
                    isDataRoute: t != null
                },
                children: y
            })
        }
        ;
        return t && (h.route.ErrorBoundary || h.route.errorElement || m === 0) ? $.createElement(aD, {
            location: t.location,
            revalidation: t.revalidation,
            component: x,
            error: g,
            children: b(),
            routeContext: {
                outlet: null,
                matches: M,
                isDataRoute: !0
            }
        }) : b()
    }
    , null)
}
function Jv(n) {
    return `${n} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`
}
function lD(n) {
    let e = $.useContext(so);
    return en(e, Jv(n)),
    e
}
function cD(n) {
    let e = $.useContext(uu);
    return en(e, Jv(n)),
    e
}
function uD(n) {
    let e = $.useContext(Br);
    return en(e, Jv(n)),
    e
}
function e_(n) {
    let e = uD(n)
      , t = e.matches[e.matches.length - 1];
    return en(t.route.id, `${n} can only be used on routes that contain a unique "id"`),
    t.route.id
}
function dD() {
    return e_("useRouteId")
}
function fD() {
    var r;
    let n = $.useContext(Qv)
      , e = cD("useRouteError")
      , t = e_("useRouteError");
    return n !== void 0 ? n : (r = e.errors) == null ? void 0 : r[t]
}
function hD() {
    let {router: n} = lD("useNavigate")
      , e = e_("useNavigate")
      , t = $.useRef(!1);
    return CM( () => {
        t.current = !0
    }
    ),
    $.useCallback(async (s, o={}) => {
        Wn(t.current, RM),
        t.current && (typeof s == "number" ? n.navigate(s) : await n.navigate(s, {
            fromRouteId: e,
            ...o
        }))
    }
    , [n, e])
}
var Xb = {};
function DM(n, e, t) {
    !e && !Xb[n] && (Xb[n] = !0,
    Wn(!1, t))
}
var qb = {};
function Yb(n, e) {
    !n && !qb[e] && (qb[e] = !0,
    console.warn(e))
}
function pD(n) {
    let e = {
        hasErrorBoundary: n.hasErrorBoundary || n.ErrorBoundary != null || n.errorElement != null
    };
    return n.Component && (n.element && Wn(!1, "You should not include both `Component` and `element` on your route - `Component` will be used."),
    Object.assign(e, {
        element: $.createElement(n.Component),
        Component: void 0
    })),
    n.HydrateFallback && (n.hydrateFallbackElement && Wn(!1, "You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used."),
    Object.assign(e, {
        hydrateFallbackElement: $.createElement(n.HydrateFallback),
        HydrateFallback: void 0
    })),
    n.ErrorBoundary && (n.errorElement && Wn(!1, "You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used."),
    Object.assign(e, {
        errorElement: $.createElement(n.ErrorBoundary),
        ErrorBoundary: void 0
    })),
    e
}
var mD = ["HydrateFallback", "hydrateFallbackElement"]
  , gD = class {
    constructor() {
        this.status = "pending",
        this.promise = new Promise( (n, e) => {
            this.resolve = t => {
                this.status === "pending" && (this.status = "resolved",
                n(t))
            }
            ,
            this.reject = t => {
                this.status === "pending" && (this.status = "rejected",
                e(t))
            }
        }
        )
    }
}
;
function vD({router: n, flushSync: e}) {
    let[t,r] = $.useState(n.state)
      , [s,o] = $.useState()
      , [u,d] = $.useState({
        isTransitioning: !1
    })
      , [f,h] = $.useState()
      , [m,g] = $.useState()
      , [_,x] = $.useState()
      , E = $.useRef(new Map)
      , M = $.useCallback( (D, {deletedFetchers: C, flushSync: P, viewTransitionOpts: A}) => {
        D.fetchers.forEach( (z, U) => {
            z.data !== void 0 && E.current.set(U, z.data)
        }
        ),
        C.forEach(z => E.current.delete(z)),
        Yb(P === !1 || e != null, 'You provided the `flushSync` option to a router update, but you are not using the `<RouterProvider>` from `react-router/dom` so `ReactDOM.flushSync()` is unavailable.  Please update your app to `import { RouterProvider } from "react-router/dom"` and ensure you have `react-dom` installed as a dependency to use the `flushSync` option.');
        let F = n.window != null && n.window.document != null && typeof n.window.document.startViewTransition == "function";
        if (Yb(A == null || F, "You provided the `viewTransition` option to a router update, but you do not appear to be running in a DOM environment as `window.startViewTransition` is not available."),
        !A || !F) {
            e && P ? e( () => r(D)) : $.startTransition( () => r(D));
            return
        }
        if (e && P) {
            e( () => {
                m && (f && f.resolve(),
                m.skipTransition()),
                d({
                    isTransitioning: !0,
                    flushSync: !0,
                    currentLocation: A.currentLocation,
                    nextLocation: A.nextLocation
                })
            }
            );
            let z = n.window.document.startViewTransition( () => {
                e( () => r(D))
            }
            );
            z.finished.finally( () => {
                e( () => {
                    h(void 0),
                    g(void 0),
                    o(void 0),
                    d({
                        isTransitioning: !1
                    })
                }
                )
            }
            ),
            e( () => g(z));
            return
        }
        m ? (f && f.resolve(),
        m.skipTransition(),
        x({
            state: D,
            currentLocation: A.currentLocation,
            nextLocation: A.nextLocation
        })) : (o(D),
        d({
            isTransitioning: !0,
            flushSync: !1,
            currentLocation: A.currentLocation,
            nextLocation: A.nextLocation
        }))
    }
    , [n.window, e, m, f]);
    $.useLayoutEffect( () => n.subscribe(M), [n, M]),
    $.useEffect( () => {
        u.isTransitioning && !u.flushSync && h(new gD)
    }
    , [u]),
    $.useEffect( () => {
        if (f && s && n.window) {
            let D = s
              , C = f.promise
              , P = n.window.document.startViewTransition(async () => {
                $.startTransition( () => r(D)),
                await C
            }
            );
            P.finished.finally( () => {
                h(void 0),
                g(void 0),
                o(void 0),
                d({
                    isTransitioning: !1
                })
            }
            ),
            g(P)
        }
    }
    , [s, f, n.window]),
    $.useEffect( () => {
        f && s && t.location.key === s.location.key && f.resolve()
    }
    , [f, m, t.location, s]),
    $.useEffect( () => {
        !u.isTransitioning && _ && (o(_.state),
        d({
            isTransitioning: !0,
            flushSync: !1,
            currentLocation: _.currentLocation,
            nextLocation: _.nextLocation
        }),
        x(void 0))
    }
    , [u.isTransitioning, _]);
    let b = $.useMemo( () => ({
        createHref: n.createHref,
        encodeLocation: n.encodeLocation,
        go: D => n.navigate(D),
        push: (D, C, P) => n.navigate(D, {
            state: C,
            preventScrollReset: P == null ? void 0 : P.preventScrollReset
        }),
        replace: (D, C, P) => n.navigate(D, {
            replace: !0,
            state: C,
            preventScrollReset: P == null ? void 0 : P.preventScrollReset
        })
    }), [n])
      , y = n.basename || "/"
      , T = $.useMemo( () => ({
        router: n,
        navigator: b,
        static: !1,
        basename: y
    }), [n, b, y]);
    return $.createElement($.Fragment, null, $.createElement(so.Provider, {
        value: T
    }, $.createElement(uu.Provider, {
        value: t
    }, $.createElement(AM.Provider, {
        value: E.current
    }, $.createElement(Kv.Provider, {
        value: u
    }, $.createElement(bD, {
        basename: y,
        location: t.location,
        navigationType: t.historyAction,
        navigator: b
    }, $.createElement(_D, {
        routes: n.routes,
        future: n.future,
        state: t
    })))))), null)
}
var _D = $.memo(yD);
function yD({routes: n, future: e, state: t}) {
    return nD(n, void 0, t, e)
}
function xD(n) {
    return tD(n.context)
}
function bD({basename: n="/", children: e=null, location: t, navigationType: r="POP", navigator: s, static: o=!1}) {
    en(!du(), "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");
    let u = n.replace(/^\/*/, "/")
      , d = $.useMemo( () => ({
        basename: u,
        navigator: s,
        static: o,
        future: {}
    }), [u, s, o]);
    typeof t == "string" && (t = bs(t));
    let {pathname: f="/", search: h="", hash: m="", state: g=null, key: _="default"} = t
      , x = $.useMemo( () => {
        let E = or(f, u);
        return E == null ? null : {
            location: {
                pathname: E,
                search: h,
                hash: m,
                state: g,
                key: _
            },
            navigationType: r
        }
    }
    , [u, f, h, m, g, _, r]);
    return Wn(x != null, `<Router basename="${u}"> is not able to match the URL "${f}${h}${m}" because it does not start with the basename, so the <Router> won't render anything.`),
    x == null ? null : $.createElement(Fr.Provider, {
        value: d
    }, $.createElement(eh.Provider, {
        children: e,
        value: x
    }))
}
var uf = "get"
  , df = "application/x-www-form-urlencoded";
function th(n) {
    return n != null && typeof n.tagName == "string"
}
function SD(n) {
    return th(n) && n.tagName.toLowerCase() === "button"
}
function ED(n) {
    return th(n) && n.tagName.toLowerCase() === "form"
}
function MD(n) {
    return th(n) && n.tagName.toLowerCase() === "input"
}
function wD(n) {
    return !!(n.metaKey || n.altKey || n.ctrlKey || n.shiftKey)
}
function TD(n, e) {
    return n.button === 0 && (!e || e === "_self") && !wD(n)
}
var Nd = null;
function AD() {
    if (Nd === null)
        try {
            new FormData(document.createElement("form"),0),
            Nd = !1
        } catch {
            Nd = !0
        }
    return Nd
}
var RD = new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
function Im(n) {
    return n != null && !RD.has(n) ? (Wn(!1, `"${n}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${df}"`),
    null) : n
}
function CD(n, e) {
    let t, r, s, o, u;
    if (ED(n)) {
        let d = n.getAttribute("action");
        r = d ? or(d, e) : null,
        t = n.getAttribute("method") || uf,
        s = Im(n.getAttribute("enctype")) || df,
        o = new FormData(n)
    } else if (SD(n) || MD(n) && (n.type === "submit" || n.type === "image")) {
        let d = n.form;
        if (d == null)
            throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
        let f = n.getAttribute("formaction") || d.getAttribute("action");
        if (r = f ? or(f, e) : null,
        t = n.getAttribute("formmethod") || d.getAttribute("method") || uf,
        s = Im(n.getAttribute("formenctype")) || Im(d.getAttribute("enctype")) || df,
        o = new FormData(d,n),
        !AD()) {
            let {name: h, type: m, value: g} = n;
            if (m === "image") {
                let _ = h ? `${h}.` : "";
                o.append(`${_}x`, "0"),
                o.append(`${_}y`, "0")
            } else
                h && o.append(h, g)
        }
    } else {
        if (th(n))
            throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
        t = uf,
        r = null,
        s = df,
        u = n
    }
    return o && s === "text/plain" && (u = o,
    o = void 0),
    {
        action: r,
        method: t.toLowerCase(),
        encType: s,
        formData: o,
        body: u
    }
}
function t_(n, e) {
    if (n === !1 || n === null || typeof n > "u")
        throw new Error(e)
}
async function DD(n, e) {
    if (n.id in e)
        return e[n.id];
    try {
        let t = await import(n.module);
        return e[n.id] = t,
        t
    } catch (t) {
        return console.error(`Error loading route module \`${n.module}\`, reloading page...`),
        console.error(t),
        window.__reactRouterContext && window.__reactRouterContext.isSpaMode,
        window.location.reload(),
        new Promise( () => {}
        )
    }
}
function UD(n) {
    return n == null ? !1 : n.href == null ? n.rel === "preload" && typeof n.imageSrcSet == "string" && typeof n.imageSizes == "string" : typeof n.rel == "string" && typeof n.href == "string"
}
async function LD(n, e, t) {
    let r = await Promise.all(n.map(async s => {
        let o = e.routes[s.route.id];
        if (o) {
            let u = await DD(o, t);
            return u.links ? u.links() : []
        }
        return []
    }
    ));
    return ID(r.flat(1).filter(UD).filter(s => s.rel === "stylesheet" || s.rel === "preload").map(s => s.rel === "stylesheet" ? {
        ...s,
        rel: "prefetch",
        as: "style"
    } : {
        ...s,
        rel: "prefetch"
    }))
}
function Zb(n, e, t, r, s, o) {
    let u = (f, h) => t[h] ? f.route.id !== t[h].route.id : !0
      , d = (f, h) => {
        var m;
        return t[h].pathname !== f.pathname || ((m = t[h].route.path) == null ? void 0 : m.endsWith("*")) && t[h].params["*"] !== f.params["*"]
    }
    ;
    return o === "assets" ? e.filter( (f, h) => u(f, h) || d(f, h)) : o === "data" ? e.filter( (f, h) => {
        var g;
        let m = r.routes[f.route.id];
        if (!m || !m.hasLoader)
            return !1;
        if (u(f, h) || d(f, h))
            return !0;
        if (f.route.shouldRevalidate) {
            let _ = f.route.shouldRevalidate({
                currentUrl: new URL(s.pathname + s.search + s.hash,window.origin),
                currentParams: ((g = t[0]) == null ? void 0 : g.params) || {},
                nextUrl: new URL(n,window.origin),
                nextParams: f.params,
                defaultShouldRevalidate: !0
            });
            if (typeof _ == "boolean")
                return _
        }
        return !0
    }
    ) : []
}
function ND(n, e, {includeHydrateFallback: t}={}) {
    return OD(n.map(r => {
        let s = e.routes[r.route.id];
        if (!s)
            return [];
        let o = [s.module];
        return s.clientActionModule && (o = o.concat(s.clientActionModule)),
        s.clientLoaderModule && (o = o.concat(s.clientLoaderModule)),
        t && s.hydrateFallbackModule && (o = o.concat(s.hydrateFallbackModule)),
        s.imports && (o = o.concat(s.imports)),
        o
    }
    ).flat(1))
}
function OD(n) {
    return [...new Set(n)]
}
function PD(n) {
    let e = {}
      , t = Object.keys(n).sort();
    for (let r of t)
        e[r] = n[r];
    return e
}
function ID(n, e) {
    let t = new Set;
    return new Set(e),
    n.reduce( (r, s) => {
        let o = JSON.stringify(PD(s));
        return t.has(o) || (t.add(o),
        r.push({
            key: o,
            link: s
        })),
        r
    }
    , [])
}
var zD = new Set([100, 101, 204, 205]);
function kD(n, e) {
    let t = typeof n == "string" ? new URL(n,typeof window > "u" ? "server://singlefetch/" : window.location.origin) : n;
    return t.pathname === "/" ? t.pathname = "_root.data" : e && or(t.pathname, e) === "/" ? t.pathname = `${e.replace(/\/$/, "")}/_root.data` : t.pathname = `${t.pathname.replace(/\/$/, "")}.data`,
    t
}
function UM() {
    let n = $.useContext(so);
    return t_(n, "You must render this element inside a <DataRouterContext.Provider> element"),
    n
}
function FD() {
    let n = $.useContext(uu);
    return t_(n, "You must render this element inside a <DataRouterStateContext.Provider> element"),
    n
}
var n_ = $.createContext(void 0);
n_.displayName = "FrameworkContext";
function LM() {
    let n = $.useContext(n_);
    return t_(n, "You must render this element inside a <HydratedRouter> element"),
    n
}
function BD(n, e) {
    let t = $.useContext(n_)
      , [r,s] = $.useState(!1)
      , [o,u] = $.useState(!1)
      , {onFocus: d, onBlur: f, onMouseEnter: h, onMouseLeave: m, onTouchStart: g} = e
      , _ = $.useRef(null);
    $.useEffect( () => {
        if (n === "render" && u(!0),
        n === "viewport") {
            let M = y => {
                y.forEach(T => {
                    u(T.isIntersecting)
                }
                )
            }
              , b = new IntersectionObserver(M,{
                threshold: .5
            });
            return _.current && b.observe(_.current),
            () => {
                b.disconnect()
            }
        }
    }
    , [n]),
    $.useEffect( () => {
        if (r) {
            let M = setTimeout( () => {
                u(!0)
            }
            , 100);
            return () => {
                clearTimeout(M)
            }
        }
    }
    , [r]);
    let x = () => {
        s(!0)
    }
      , E = () => {
        s(!1),
        u(!1)
    }
    ;
    return t ? n !== "intent" ? [o, _, {}] : [o, _, {
        onFocus: Ac(d, x),
        onBlur: Ac(f, E),
        onMouseEnter: Ac(h, x),
        onMouseLeave: Ac(m, E),
        onTouchStart: Ac(g, x)
    }] : [!1, _, {}]
}
function Ac(n, e) {
    return t => {
        n && n(t),
        t.defaultPrevented || e(t)
    }
}
function VD({page: n, ...e}) {
    let {router: t} = UM()
      , r = $.useMemo( () => ds(t.routes, n, t.basename), [t.routes, n, t.basename]);
    return r ? $.createElement(GD, {
        page: n,
        matches: r,
        ...e
    }) : null
}
function HD(n) {
    let {manifest: e, routeModules: t} = LM()
      , [r,s] = $.useState([]);
    return $.useEffect( () => {
        let o = !1;
        return LD(n, e, t).then(u => {
            o || s(u)
        }
        ),
        () => {
            o = !0
        }
    }
    , [n, e, t]),
    r
}
function GD({page: n, matches: e, ...t}) {
    let r = oo()
      , {manifest: s, routeModules: o} = LM()
      , {basename: u} = UM()
      , {loaderData: d, matches: f} = FD()
      , h = $.useMemo( () => Zb(n, e, f, s, r, "data"), [n, e, f, s, r])
      , m = $.useMemo( () => Zb(n, e, f, s, r, "assets"), [n, e, f, s, r])
      , g = $.useMemo( () => {
        if (n === r.pathname + r.search + r.hash)
            return [];
        let E = new Set
          , M = !1;
        if (e.forEach(y => {
            var D;
            let T = s.routes[y.route.id];
            !T || !T.hasLoader || (!h.some(C => C.route.id === y.route.id) && y.route.id in d && ((D = o[y.route.id]) != null && D.shouldRevalidate) || T.hasClientLoader ? M = !0 : E.add(y.route.id))
        }
        ),
        E.size === 0)
            return [];
        let b = kD(n, u);
        return M && E.size > 0 && b.searchParams.set("_routes", e.filter(y => E.has(y.route.id)).map(y => y.route.id).join(",")),
        [b.pathname + b.search]
    }
    , [u, d, r, s, h, e, n, o])
      , _ = $.useMemo( () => ND(m, s), [m, s])
      , x = HD(m);
    return $.createElement($.Fragment, null, g.map(E => $.createElement("link", {
        key: E,
        rel: "prefetch",
        as: "fetch",
        href: E,
        ...t
    })), _.map(E => $.createElement("link", {
        key: E,
        rel: "modulepreload",
        href: E,
        ...t
    })), x.map( ({key: E, link: M}) => $.createElement("link", {
        key: E,
        ...M
    })))
}
function jD(...n) {
    return e => {
        n.forEach(t => {
            typeof t == "function" ? t(e) : t != null && (t.current = e)
        }
        )
    }
}
var NM = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
try {
    NM && (window.__reactRouterVersion = "7.5.1")
} catch {}
function WD(n, e) {
    return L2({
        basename: e == null ? void 0 : e.basename,
        unstable_getContext: e == null ? void 0 : e.unstable_getContext,
        future: e == null ? void 0 : e.future,
        history: JC({
            window: e == null ? void 0 : e.window
        }),
        hydrationData: XD(),
        routes: n,
        mapRouteProperties: pD,
        hydrationRouteProperties: mD,
        dataStrategy: e == null ? void 0 : e.dataStrategy,
        patchRoutesOnNavigation: e == null ? void 0 : e.patchRoutesOnNavigation,
        window: e == null ? void 0 : e.window
    }).initialize()
}
function XD() {
    let n = window == null ? void 0 : window.__staticRouterHydrationData;
    return n && n.errors && (n = {
        ...n,
        errors: qD(n.errors)
    }),
    n
}
function qD(n) {
    if (!n)
        return null;
    let e = Object.entries(n)
      , t = {};
    for (let[r,s] of e)
        if (s && s.__type === "RouteErrorResponse")
            t[r] = new Ef(s.status,s.statusText,s.data,s.internal === !0);
        else if (s && s.__type === "Error") {
            if (s.__subType) {
                let o = window[s.__subType];
                if (typeof o == "function")
                    try {
                        let u = new o(s.message);
                        u.stack = "",
                        t[r] = u
                    } catch {}
            }
            if (t[r] == null) {
                let o = new Error(s.message);
                o.stack = "",
                t[r] = o
            }
        } else
            t[r] = s;
    return t
}
var OM = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i
  , Wc = $.forwardRef(function({onClick: e, discover: t="render", prefetch: r="none", relative: s, reloadDocument: o, replace: u, state: d, target: f, to: h, preventScrollReset: m, viewTransition: g, ..._}, x) {
    let {basename: E} = $.useContext(Fr), M = typeof h == "string" && OM.test(h), b, y = !1;
    if (typeof h == "string" && M && (b = h,
    NM))
        try {
            let U = new URL(window.location.href)
              , R = h.startsWith("//") ? new URL(U.protocol + h) : new URL(h)
              , V = or(R.pathname, E);
            R.origin === U.origin && V != null ? h = V + R.search + R.hash : y = !0
        } catch {
            Wn(!1, `<Link to="${h}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`)
        }
    let T = Q2(h, {
        relative: s
    })
      , [D,C,P] = BD(r, _)
      , A = KD(h, {
        replace: u,
        state: d,
        target: f,
        preventScrollReset: m,
        relative: s,
        viewTransition: g
    });
    function F(U) {
        e && e(U),
        U.defaultPrevented || A(U)
    }
    let z = $.createElement("a", {
        ..._,
        ...P,
        href: b || T,
        onClick: y || o ? e : F,
        ref: jD(x, C),
        target: f,
        "data-discover": !M && t === "render" ? "true" : void 0
    });
    return D && !M ? $.createElement($.Fragment, null, z, $.createElement(VD, {
        page: T
    })) : z
});
Wc.displayName = "Link";
var YD = $.forwardRef(function({"aria-current": e="page", caseSensitive: t=!1, className: r="", end: s=!1, style: o, to: u, viewTransition: d, children: f, ...h}, m) {
    let g = fu(u, {
        relative: h.relative
    })
      , _ = oo()
      , x = $.useContext(uu)
      , {navigator: E, basename: M} = $.useContext(Fr)
      , b = x != null && nU(g) && d === !0
      , y = E.encodeLocation ? E.encodeLocation(g).pathname : g.pathname
      , T = _.pathname
      , D = x && x.navigation && x.navigation.location ? x.navigation.location.pathname : null;
    t || (T = T.toLowerCase(),
    D = D ? D.toLowerCase() : null,
    y = y.toLowerCase()),
    D && M && (D = or(D, M) || D);
    const C = y !== "/" && y.endsWith("/") ? y.length - 1 : y.length;
    let P = T === y || !s && T.startsWith(y) && T.charAt(C) === "/", A = D != null && (D === y || !s && D.startsWith(y) && D.charAt(y.length) === "/"), F = {
        isActive: P,
        isPending: A,
        isTransitioning: b
    }, z = P ? e : void 0, U;
    typeof r == "function" ? U = r(F) : U = [r, P ? "active" : null, A ? "pending" : null, b ? "transitioning" : null].filter(Boolean).join(" ");
    let R = typeof o == "function" ? o(F) : o;
    return $.createElement(Wc, {
        ...h,
        "aria-current": z,
        className: U,
        ref: m,
        style: R,
        to: u,
        viewTransition: d
    }, typeof f == "function" ? f(F) : f)
});
YD.displayName = "NavLink";
var ZD = $.forwardRef( ({discover: n="render", fetcherKey: e, navigate: t, reloadDocument: r, replace: s, state: o, method: u=uf, action: d, onSubmit: f, relative: h, preventScrollReset: m, viewTransition: g, ..._}, x) => {
    let E = eU()
      , M = tU(d, {
        relative: h
    })
      , b = u.toLowerCase() === "get" ? "get" : "post"
      , y = typeof d == "string" && OM.test(d)
      , T = D => {
        if (f && f(D),
        D.defaultPrevented)
            return;
        D.preventDefault();
        let C = D.nativeEvent.submitter
          , P = (C == null ? void 0 : C.getAttribute("formmethod")) || u;
        E(C || D.currentTarget, {
            fetcherKey: e,
            method: P,
            navigate: t,
            replace: s,
            state: o,
            relative: h,
            preventScrollReset: m,
            viewTransition: g
        })
    }
    ;
    return $.createElement("form", {
        ref: x,
        method: b,
        action: M,
        onSubmit: r ? f : T,
        ..._,
        "data-discover": !y && n === "render" ? "true" : void 0
    })
}
);
ZD.displayName = "Form";
function $D(n) {
    return `${n} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`
}
function PM(n) {
    let e = $.useContext(so);
    return en(e, $D(n)),
    e
}
function KD(n, {target: e, replace: t, state: r, preventScrollReset: s, relative: o, viewTransition: u}={}) {
    let d = Ml()
      , f = oo()
      , h = fu(n, {
        relative: o
    });
    return $.useCallback(m => {
        if (TD(m, e)) {
            m.preventDefault();
            let g = t !== void 0 ? t : vs(f) === vs(h);
            d(n, {
                replace: g,
                state: r,
                preventScrollReset: s,
                relative: o,
                viewTransition: u
            })
        }
    }
    , [f, d, h, t, r, e, n, s, o, u])
}
var QD = 0
  , JD = () => `__${String(++QD)}__`;
function eU() {
    let {router: n} = PM("useSubmit")
      , {basename: e} = $.useContext(Fr)
      , t = dD();
    return $.useCallback(async (r, s={}) => {
        let {action: o, method: u, encType: d, formData: f, body: h} = CD(r, e);
        if (s.navigate === !1) {
            let m = s.fetcherKey || JD();
            await n.fetch(m, t, s.action || o, {
                preventScrollReset: s.preventScrollReset,
                formData: f,
                body: h,
                formMethod: s.method || u,
                formEncType: s.encType || d,
                flushSync: s.flushSync
            })
        } else
            await n.navigate(s.action || o, {
                preventScrollReset: s.preventScrollReset,
                formData: f,
                body: h,
                formMethod: s.method || u,
                formEncType: s.encType || d,
                replace: s.replace,
                state: s.state,
                fromRouteId: t,
                flushSync: s.flushSync,
                viewTransition: s.viewTransition
            })
    }
    , [n, e, t])
}
function tU(n, {relative: e}={}) {
    let {basename: t} = $.useContext(Fr)
      , r = $.useContext(Br);
    en(r, "useFormAction must be used inside a RouteContext");
    let[s] = r.matches.slice(-1)
      , o = {
        ...fu(n || ".", {
            relative: e
        })
    }
      , u = oo();
    if (n == null) {
        o.search = u.search;
        let d = new URLSearchParams(o.search)
          , f = d.getAll("index");
        if (f.some(m => m === "")) {
            d.delete("index"),
            f.filter(g => g).forEach(g => d.append("index", g));
            let m = d.toString();
            o.search = m ? `?${m}` : ""
        }
    }
    return (!n || n === ".") && s.route.index && (o.search = o.search ? o.search.replace(/^\?/, "?index&") : "?index"),
    t !== "/" && (o.pathname = o.pathname === "/" ? t : Or([t, o.pathname])),
    vs(o)
}
function nU(n, e={}) {
    let t = $.useContext(Kv);
    en(t != null, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");
    let {basename: r} = PM("useViewTransitionState")
      , s = fu(n, {
        relative: e.relative
    });
    if (!t.isTransitioning)
        return !1;
    let o = or(t.currentLocation.pathname, r) || t.currentLocation.pathname
      , u = or(t.nextLocation.pathname, r) || t.nextLocation.pathname;
    return Sf(s.pathname, u) != null || Sf(s.pathname, o) != null
}
new TextEncoder;
[...zD];
const iU = () => Z.jsxs("div", {
    className: "fixed z-1 min-h-screen overflow-hidden w-full",
    children: [Z.jsx("div", {
        children: Z.jsx("img", {
            src: "/plane.gif",
            className: "absolute left-[60%] top-[10vh] w-[18vw] max-w-[140px] min-w-[70px] animate-bounce rotate-22 md:w-[15vw] md:max-w-[160px]",
            alt: "Spaceship"
        })
    }), Z.jsx("div", {
        children: Z.jsx("img", {
            src: "/asteroid_1.gif",
            className: "absolute right-[15%] top-[25vh] w-[12vw] max-w-[90px] min-w-[40px] animate-bounce rotate-45 md:w-[10vw] md:max-w-[100px]",
            alt: "Asteroid 1"
        })
    }), Z.jsx("div", {
        children: Z.jsx("img", {
            src: "/asteroid_2.gif",
            className: "absolute left-[15%] bottom-[20vh] w-[12vw] max-w-[90px] min-w-[40px] animate-bounce rotate-40 md:w-[10vw] md:max-w-[100px]",
            alt: "Asteroid 2"
        })
    }), Z.jsx("div", {
        children: Z.jsx("img", {
            src: "/alien_ship.gif",
            className: "absolute right-[10%] bottom-[15vh] w-[15vw] max-w-[120px] min-w-[60px] animate-pulse md:w-[12vw] md:max-w-[130px]",
            alt: "Alien Ship"
        })
    }), Z.jsx("div", {
        children: Z.jsx("img", {
            src: "/mars.png",
            className: "absolute left-[20%] top-[15vh] w-[10vw] max-w-[80px] min-w-[40px] animate-spin-very-slow opacity-70 md:w-[8vw] md:max-w-[90px]",
            alt: "Mars"
        })
    }), Z.jsx("div", {
        children: Z.jsx("img", {
            src: "/earth.png",
            className: "absolute right-[20%] bottom-[25vh] w-[14vw] max-w-[110px] min-w-[50px] animate-spin-very-slow opacity-80 md:w-[12vw] md:max-w-[120px]",
            alt: "Earth"
        })
    }), Z.jsx("style", {
        children: `
        @keyframes glow {
          0%, 100% { text-shadow: 0 0 10px rgba(255, 255, 255, 0.8); }
          50% { text-shadow: 0 0 20px rgba(255, 255, 255, 1); }
        }
        @keyframes spin-very-slow {
          from { transform: rotate(0deg); }
          to { transform: rotate(360deg); }
        }
        @keyframes bounce {
          0%, 100% {
            transform: translateY(-10%);
            animation-timing-function: cubic-bezier(0.8, 0, 1, 1);
          }
          50% {
            transform: none;
            animation-timing-function: cubic-bezier(0, 0, 0.2, 1);
          }
        }
        @keyframes spin-slow {
          from { transform: rotate(0deg); }
          to { transform: rotate(360deg); }
        }
        @keyframes spin-fast {
          from { transform: rotate(0deg); }
          to { transform: rotate(-360deg); }
        }
        .animate-spin-very-slow { animation: spin-very-slow 30s linear infinite; }
        .animate-glow { animation: glow 2s ease-in-out infinite; }
        .animate-bounce {animation: bounce 2s ease-in-out infinite; }
        .animate-spin-slow { animation: spin-slow 10s linear infinite; }
        .animate-spin-fast { animation: spin-fast 8s linear infinite; }
      `
    })]
});
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const i_ = "175"
  , rU = 0
  , $b = 1
  , aU = 2
  , IM = 1
  , sU = 2
  , ua = 3
  , _s = 0
  , Ni = 1
  , _a = 2
  , ms = 0
  , ul = 1
  , Kb = 2
  , Qb = 3
  , Jb = 4
  , oU = 5
  , Ys = 100
  , lU = 101
  , cU = 102
  , uU = 103
  , dU = 104
  , fU = 200
  , hU = 201
  , pU = 202
  , mU = 203
  , zg = 204
  , kg = 205
  , gU = 206
  , vU = 207
  , _U = 208
  , yU = 209
  , xU = 210
  , bU = 211
  , SU = 212
  , EU = 213
  , MU = 214
  , Fg = 0
  , Bg = 1
  , Vg = 2
  , pl = 3
  , Hg = 4
  , Gg = 5
  , jg = 6
  , Wg = 7
  , zM = 0
  , wU = 1
  , TU = 2
  , gs = 0
  , AU = 1
  , RU = 2
  , CU = 3
  , DU = 4
  , UU = 5
  , LU = 6
  , NU = 7
  , kM = 300
  , ml = 301
  , gl = 302
  , Xg = 303
  , qg = 304
  , nh = 306
  , Yg = 1e3
  , Ks = 1001
  , Zg = 1002
  , xr = 1003
  , OU = 1004
  , Od = 1005
  , Ur = 1006
  , zm = 1007
  , Qs = 1008
  , Ta = 1009
  , FM = 1010
  , BM = 1011
  , Qc = 1012
  , r_ = 1013
  , no = 1014
  , ya = 1015
  , hu = 1016
  , a_ = 1017
  , s_ = 1018
  , Jc = 1020
  , VM = 35902
  , HM = 1021
  , GM = 1022
  , yr = 1023
  , jM = 1024
  , WM = 1025
  , eu = 1026
  , tu = 1027
  , XM = 1028
  , o_ = 1029
  , qM = 1030
  , l_ = 1031
  , c_ = 1033
  , ff = 33776
  , hf = 33777
  , pf = 33778
  , mf = 33779
  , $g = 35840
  , Kg = 35841
  , Qg = 35842
  , Jg = 35843
  , ev = 36196
  , tv = 37492
  , nv = 37496
  , iv = 37808
  , rv = 37809
  , av = 37810
  , sv = 37811
  , ov = 37812
  , lv = 37813
  , cv = 37814
  , uv = 37815
  , dv = 37816
  , fv = 37817
  , hv = 37818
  , pv = 37819
  , mv = 37820
  , gv = 37821
  , gf = 36492
  , vv = 36494
  , _v = 36495
  , YM = 36283
  , yv = 36284
  , xv = 36285
  , bv = 36286
  , PU = 3200
  , IU = 3201
  , zU = 0
  , kU = 1
  , fs = ""
  , Xi = "srgb"
  , vl = "srgb-linear"
  , wf = "linear"
  , Sn = "srgb"
  , Vo = 7680
  , eS = 519
  , FU = 512
  , BU = 513
  , VU = 514
  , ZM = 515
  , HU = 516
  , GU = 517
  , jU = 518
  , WU = 519
  , tS = 35044
  , nS = "300 es"
  , xa = 2e3
  , Tf = 2001;
class wl {
    addEventListener(e, t) {
        this._listeners === void 0 && (this._listeners = {});
        const r = this._listeners;
        r[e] === void 0 && (r[e] = []),
        r[e].indexOf(t) === -1 && r[e].push(t)
    }
    hasEventListener(e, t) {
        const r = this._listeners;
        return r === void 0 ? !1 : r[e] !== void 0 && r[e].indexOf(t) !== -1
    }
    removeEventListener(e, t) {
        const r = this._listeners;
        if (r === void 0)
            return;
        const s = r[e];
        if (s !== void 0) {
            const o = s.indexOf(t);
            o !== -1 && s.splice(o, 1)
        }
    }
    dispatchEvent(e) {
        const t = this._listeners;
        if (t === void 0)
            return;
        const r = t[e.type];
        if (r !== void 0) {
            e.target = this;
            const s = r.slice(0);
            for (let o = 0, u = s.length; o < u; o++)
                s[o].call(this, e);
            e.target = null
        }
    }
}
const vi = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"]
  , km = Math.PI / 180
  , Sv = 180 / Math.PI;
function pu() {
    const n = Math.random() * 4294967295 | 0
      , e = Math.random() * 4294967295 | 0
      , t = Math.random() * 4294967295 | 0
      , r = Math.random() * 4294967295 | 0;
    return (vi[n & 255] + vi[n >> 8 & 255] + vi[n >> 16 & 255] + vi[n >> 24 & 255] + "-" + vi[e & 255] + vi[e >> 8 & 255] + "-" + vi[e >> 16 & 15 | 64] + vi[e >> 24 & 255] + "-" + vi[t & 63 | 128] + vi[t >> 8 & 255] + "-" + vi[t >> 16 & 255] + vi[t >> 24 & 255] + vi[r & 255] + vi[r >> 8 & 255] + vi[r >> 16 & 255] + vi[r >> 24 & 255]).toLowerCase()
}
function sn(n, e, t) {
    return Math.max(e, Math.min(t, n))
}
function XU(n, e) {
    return (n % e + e) % e
}
function Fm(n, e, t) {
    return (1 - t) * n + t * e
}
function Rc(n, e) {
    switch (e.constructor) {
    case Float32Array:
        return n;
    case Uint32Array:
        return n / 4294967295;
    case Uint16Array:
        return n / 65535;
    case Uint8Array:
        return n / 255;
    case Int32Array:
        return Math.max(n / 2147483647, -1);
    case Int16Array:
        return Math.max(n / 32767, -1);
    case Int8Array:
        return Math.max(n / 127, -1);
    default:
        throw new Error("Invalid component type.")
    }
}
function Ui(n, e) {
    switch (e.constructor) {
    case Float32Array:
        return n;
    case Uint32Array:
        return Math.round(n * 4294967295);
    case Uint16Array:
        return Math.round(n * 65535);
    case Uint8Array:
        return Math.round(n * 255);
    case Int32Array:
        return Math.round(n * 2147483647);
    case Int16Array:
        return Math.round(n * 32767);
    case Int8Array:
        return Math.round(n * 127);
    default:
        throw new Error("Invalid component type.")
    }
}
class _n {
    constructor(e=0, t=0) {
        _n.prototype.isVector2 = !0,
        this.x = e,
        this.y = t
    }
    get width() {
        return this.x
    }
    set width(e) {
        this.x = e
    }
    get height() {
        return this.y
    }
    set height(e) {
        this.y = e
    }
    set(e, t) {
        return this.x = e,
        this.y = t,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    applyMatrix3(e) {
        const t = this.x
          , r = this.y
          , s = e.elements;
        return this.x = s[0] * t + s[3] * r + s[6],
        this.y = s[1] * t + s[4] * r + s[7],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this
    }
    clamp(e, t) {
        return this.x = sn(this.x, e.x, t.x),
        this.y = sn(this.y, e.y, t.y),
        this
    }
    clampScalar(e, t) {
        return this.x = sn(this.x, e, t),
        this.y = sn(this.y, e, t),
        this
    }
    clampLength(e, t) {
        const r = this.length();
        return this.divideScalar(r || 1).multiplyScalar(sn(r, e, t))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y
    }
    cross(e) {
        return this.x * e.y - this.y * e.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const r = this.dot(e) / t;
        return Math.acos(sn(r, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , r = this.y - e.y;
        return t * t + r * r
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this
    }
    lerpVectors(e, t, r) {
        return this.x = e.x + (t.x - e.x) * r,
        this.y = e.y + (t.y - e.y) * r,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this
    }
    rotateAround(e, t) {
        const r = Math.cos(t)
          , s = Math.sin(t)
          , o = this.x - e.x
          , u = this.y - e.y;
        return this.x = o * r - u * s + e.x,
        this.y = o * s + u * r + e.y,
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y
    }
}
class Vt {
    constructor(e, t, r, s, o, u, d, f, h) {
        Vt.prototype.isMatrix3 = !0,
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        e !== void 0 && this.set(e, t, r, s, o, u, d, f, h)
    }
    set(e, t, r, s, o, u, d, f, h) {
        const m = this.elements;
        return m[0] = e,
        m[1] = s,
        m[2] = d,
        m[3] = t,
        m[4] = o,
        m[5] = f,
        m[6] = r,
        m[7] = u,
        m[8] = h,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
        this
    }
    copy(e) {
        const t = this.elements
          , r = e.elements;
        return t[0] = r[0],
        t[1] = r[1],
        t[2] = r[2],
        t[3] = r[3],
        t[4] = r[4],
        t[5] = r[5],
        t[6] = r[6],
        t[7] = r[7],
        t[8] = r[8],
        this
    }
    extractBasis(e, t, r) {
        return e.setFromMatrix3Column(this, 0),
        t.setFromMatrix3Column(this, 1),
        r.setFromMatrix3Column(this, 2),
        this
    }
    setFromMatrix4(e) {
        const t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const r = e.elements
          , s = t.elements
          , o = this.elements
          , u = r[0]
          , d = r[3]
          , f = r[6]
          , h = r[1]
          , m = r[4]
          , g = r[7]
          , _ = r[2]
          , x = r[5]
          , E = r[8]
          , M = s[0]
          , b = s[3]
          , y = s[6]
          , T = s[1]
          , D = s[4]
          , C = s[7]
          , P = s[2]
          , A = s[5]
          , F = s[8];
        return o[0] = u * M + d * T + f * P,
        o[3] = u * b + d * D + f * A,
        o[6] = u * y + d * C + f * F,
        o[1] = h * M + m * T + g * P,
        o[4] = h * b + m * D + g * A,
        o[7] = h * y + m * C + g * F,
        o[2] = _ * M + x * T + E * P,
        o[5] = _ * b + x * D + E * A,
        o[8] = _ * y + x * C + E * F,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[3] *= e,
        t[6] *= e,
        t[1] *= e,
        t[4] *= e,
        t[7] *= e,
        t[2] *= e,
        t[5] *= e,
        t[8] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , r = e[1]
          , s = e[2]
          , o = e[3]
          , u = e[4]
          , d = e[5]
          , f = e[6]
          , h = e[7]
          , m = e[8];
        return t * u * m - t * d * h - r * o * m + r * d * f + s * o * h - s * u * f
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , r = e[1]
          , s = e[2]
          , o = e[3]
          , u = e[4]
          , d = e[5]
          , f = e[6]
          , h = e[7]
          , m = e[8]
          , g = m * u - d * h
          , _ = d * f - m * o
          , x = h * o - u * f
          , E = t * g + r * _ + s * x;
        if (E === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const M = 1 / E;
        return e[0] = g * M,
        e[1] = (s * h - m * r) * M,
        e[2] = (d * r - s * u) * M,
        e[3] = _ * M,
        e[4] = (m * t - s * f) * M,
        e[5] = (s * o - d * t) * M,
        e[6] = x * M,
        e[7] = (r * f - h * t) * M,
        e[8] = (u * t - r * o) * M,
        this
    }
    transpose() {
        let e;
        const t = this.elements;
        return e = t[1],
        t[1] = t[3],
        t[3] = e,
        e = t[2],
        t[2] = t[6],
        t[6] = e,
        e = t[5],
        t[5] = t[7],
        t[7] = e,
        this
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose()
    }
    transposeIntoArray(e) {
        const t = this.elements;
        return e[0] = t[0],
        e[1] = t[3],
        e[2] = t[6],
        e[3] = t[1],
        e[4] = t[4],
        e[5] = t[7],
        e[6] = t[2],
        e[7] = t[5],
        e[8] = t[8],
        this
    }
    setUvTransform(e, t, r, s, o, u, d) {
        const f = Math.cos(o)
          , h = Math.sin(o);
        return this.set(r * f, r * h, -r * (f * u + h * d) + u + e, -s * h, s * f, -s * (-h * u + f * d) + d + t, 0, 0, 1),
        this
    }
    scale(e, t) {
        return this.premultiply(Bm.makeScale(e, t)),
        this
    }
    rotate(e) {
        return this.premultiply(Bm.makeRotation(-e)),
        this
    }
    translate(e, t) {
        return this.premultiply(Bm.makeTranslation(e, t)),
        this
    }
    makeTranslation(e, t) {
        return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
        this
    }
    makeRotation(e) {
        const t = Math.cos(e)
          , r = Math.sin(e);
        return this.set(t, -r, 0, r, t, 0, 0, 0, 1),
        this
    }
    makeScale(e, t) {
        return this.set(e, 0, 0, 0, t, 0, 0, 0, 1),
        this
    }
    equals(e) {
        const t = this.elements
          , r = e.elements;
        for (let s = 0; s < 9; s++)
            if (t[s] !== r[s])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let r = 0; r < 9; r++)
            this.elements[r] = e[r + t];
        return this
    }
    toArray(e=[], t=0) {
        const r = this.elements;
        return e[t] = r[0],
        e[t + 1] = r[1],
        e[t + 2] = r[2],
        e[t + 3] = r[3],
        e[t + 4] = r[4],
        e[t + 5] = r[5],
        e[t + 6] = r[6],
        e[t + 7] = r[7],
        e[t + 8] = r[8],
        e
    }
    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}
const Bm = new Vt;
function $M(n) {
    for (let e = n.length - 1; e >= 0; --e)
        if (n[e] >= 65535)
            return !0;
    return !1
}
function nu(n) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", n)
}
function qU() {
    const n = nu("canvas");
    return n.style.display = "block",
    n
}
const iS = {};
function vf(n) {
    n in iS || (iS[n] = !0,
    console.warn(n))
}
function YU(n, e, t) {
    return new Promise(function(r, s) {
        function o() {
            switch (n.clientWaitSync(e, n.SYNC_FLUSH_COMMANDS_BIT, 0)) {
            case n.WAIT_FAILED:
                s();
                break;
            case n.TIMEOUT_EXPIRED:
                setTimeout(o, t);
                break;
            default:
                r()
            }
        }
        setTimeout(o, t)
    }
    )
}
function ZU(n) {
    const e = n.elements;
    e[2] = .5 * e[2] + .5 * e[3],
    e[6] = .5 * e[6] + .5 * e[7],
    e[10] = .5 * e[10] + .5 * e[11],
    e[14] = .5 * e[14] + .5 * e[15]
}
function $U(n) {
    const e = n.elements;
    e[11] === -1 ? (e[10] = -e[10] - 1,
    e[14] = -e[14]) : (e[10] = -e[10],
    e[14] = -e[14] + 1)
}
const rS = new Vt().set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322)
  , aS = new Vt().set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715);
function KU() {
    const n = {
        enabled: !0,
        workingColorSpace: vl,
        spaces: {},
        convert: function(s, o, u) {
            return this.enabled === !1 || o === u || !o || !u || (this.spaces[o].transfer === Sn && (s.r = Ea(s.r),
            s.g = Ea(s.g),
            s.b = Ea(s.b)),
            this.spaces[o].primaries !== this.spaces[u].primaries && (s.applyMatrix3(this.spaces[o].toXYZ),
            s.applyMatrix3(this.spaces[u].fromXYZ)),
            this.spaces[u].transfer === Sn && (s.r = dl(s.r),
            s.g = dl(s.g),
            s.b = dl(s.b))),
            s
        },
        fromWorkingColorSpace: function(s, o) {
            return this.convert(s, this.workingColorSpace, o)
        },
        toWorkingColorSpace: function(s, o) {
            return this.convert(s, o, this.workingColorSpace)
        },
        getPrimaries: function(s) {
            return this.spaces[s].primaries
        },
        getTransfer: function(s) {
            return s === fs ? wf : this.spaces[s].transfer
        },
        getLuminanceCoefficients: function(s, o=this.workingColorSpace) {
            return s.fromArray(this.spaces[o].luminanceCoefficients)
        },
        define: function(s) {
            Object.assign(this.spaces, s)
        },
        _getMatrix: function(s, o, u) {
            return s.copy(this.spaces[o].toXYZ).multiply(this.spaces[u].fromXYZ)
        },
        _getDrawingBufferColorSpace: function(s) {
            return this.spaces[s].outputColorSpaceConfig.drawingBufferColorSpace
        },
        _getUnpackColorSpace: function(s=this.workingColorSpace) {
            return this.spaces[s].workingColorSpaceConfig.unpackColorSpace
        }
    }
      , e = [.64, .33, .3, .6, .15, .06]
      , t = [.2126, .7152, .0722]
      , r = [.3127, .329];
    return n.define({
        [vl]: {
            primaries: e,
            whitePoint: r,
            transfer: wf,
            toXYZ: rS,
            fromXYZ: aS,
            luminanceCoefficients: t,
            workingColorSpaceConfig: {
                unpackColorSpace: Xi
            },
            outputColorSpaceConfig: {
                drawingBufferColorSpace: Xi
            }
        },
        [Xi]: {
            primaries: e,
            whitePoint: r,
            transfer: Sn,
            toXYZ: rS,
            fromXYZ: aS,
            luminanceCoefficients: t,
            outputColorSpaceConfig: {
                drawingBufferColorSpace: Xi
            }
        }
    }),
    n
}
const fn = KU();
function Ea(n) {
    return n < .04045 ? n * .0773993808 : Math.pow(n * .9478672986 + .0521327014, 2.4)
}
function dl(n) {
    return n < .0031308 ? n * 12.92 : 1.055 * Math.pow(n, .41666) - .055
}
let Ho;
class QU {
    static getDataURL(e, t="image/png") {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
            return e.src;
        let r;
        if (e instanceof HTMLCanvasElement)
            r = e;
        else {
            Ho === void 0 && (Ho = nu("canvas")),
            Ho.width = e.width,
            Ho.height = e.height;
            const s = Ho.getContext("2d");
            e instanceof ImageData ? s.putImageData(e, 0, 0) : s.drawImage(e, 0, 0, e.width, e.height),
            r = Ho
        }
        return r.toDataURL(t)
    }
    static sRGBToLinear(e) {
        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const t = nu("canvas");
            t.width = e.width,
            t.height = e.height;
            const r = t.getContext("2d");
            r.drawImage(e, 0, 0, e.width, e.height);
            const s = r.getImageData(0, 0, e.width, e.height)
              , o = s.data;
            for (let u = 0; u < o.length; u++)
                o[u] = Ea(o[u] / 255) * 255;
            return r.putImageData(s, 0, 0),
            t
        } else if (e.data) {
            const t = e.data.slice(0);
            for (let r = 0; r < t.length; r++)
                t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[r] = Math.floor(Ea(t[r] / 255) * 255) : t[r] = Ea(t[r]);
            return {
                data: t,
                width: e.width,
                height: e.height
            }
        } else
            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
            e
    }
}
let JU = 0;
class u_ {
    constructor(e=null) {
        this.isSource = !0,
        Object.defineProperty(this, "id", {
            value: JU++
        }),
        this.uuid = pu(),
        this.data = e,
        this.dataReady = !0,
        this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.images[this.uuid] !== void 0)
            return e.images[this.uuid];
        const r = {
            uuid: this.uuid,
            url: ""
        }
          , s = this.data;
        if (s !== null) {
            let o;
            if (Array.isArray(s)) {
                o = [];
                for (let u = 0, d = s.length; u < d; u++)
                    s[u].isDataTexture ? o.push(Vm(s[u].image)) : o.push(Vm(s[u]))
            } else
                o = Vm(s);
            r.url = o
        }
        return t || (e.images[this.uuid] = r),
        r
    }
}
function Vm(n) {
    return typeof HTMLImageElement < "u" && n instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && n instanceof ImageBitmap ? QU.getDataURL(n) : n.data ? {
        data: Array.from(n.data),
        width: n.width,
        height: n.height,
        type: n.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."),
    {})
}
let eL = 0;
class wi extends wl {
    constructor(e=wi.DEFAULT_IMAGE, t=wi.DEFAULT_MAPPING, r=Ks, s=Ks, o=Ur, u=Qs, d=yr, f=Ta, h=wi.DEFAULT_ANISOTROPY, m=fs) {
        super(),
        this.isTexture = !0,
        Object.defineProperty(this, "id", {
            value: eL++
        }),
        this.uuid = pu(),
        this.name = "",
        this.source = new u_(e),
        this.mipmaps = [],
        this.mapping = t,
        this.channel = 0,
        this.wrapS = r,
        this.wrapT = s,
        this.magFilter = o,
        this.minFilter = u,
        this.anisotropy = h,
        this.format = d,
        this.internalFormat = null,
        this.type = f,
        this.offset = new _n(0,0),
        this.repeat = new _n(1,1),
        this.center = new _n(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new Vt,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.colorSpace = m,
        this.userData = {},
        this.version = 0,
        this.onUpdate = null,
        this.renderTarget = null,
        this.isRenderTargetTexture = !1,
        this.pmremVersion = 0
    }
    get image() {
        return this.source.data
    }
    set image(e=null) {
        this.source.data = e
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.name = e.name,
        this.source = e.source,
        this.mipmaps = e.mipmaps.slice(0),
        this.mapping = e.mapping,
        this.channel = e.channel,
        this.wrapS = e.wrapS,
        this.wrapT = e.wrapT,
        this.magFilter = e.magFilter,
        this.minFilter = e.minFilter,
        this.anisotropy = e.anisotropy,
        this.format = e.format,
        this.internalFormat = e.internalFormat,
        this.type = e.type,
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.center.copy(e.center),
        this.rotation = e.rotation,
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrix.copy(e.matrix),
        this.generateMipmaps = e.generateMipmaps,
        this.premultiplyAlpha = e.premultiplyAlpha,
        this.flipY = e.flipY,
        this.unpackAlignment = e.unpackAlignment,
        this.colorSpace = e.colorSpace,
        this.renderTarget = e.renderTarget,
        this.isRenderTargetTexture = e.isRenderTargetTexture,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this.needsUpdate = !0,
        this
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.textures[this.uuid] !== void 0)
            return e.textures[this.uuid];
        const r = {
            metadata: {
                version: 4.6,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (r.userData = this.userData),
        t || (e.textures[this.uuid] = r),
        r
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(e) {
        if (this.mapping !== kM)
            return e;
        if (e.applyMatrix3(this.matrix),
        e.x < 0 || e.x > 1)
            switch (this.wrapS) {
            case Yg:
                e.x = e.x - Math.floor(e.x);
                break;
            case Ks:
                e.x = e.x < 0 ? 0 : 1;
                break;
            case Zg:
                Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                break
            }
        if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
            case Yg:
                e.y = e.y - Math.floor(e.y);
                break;
            case Ks:
                e.y = e.y < 0 ? 0 : 1;
                break;
            case Zg:
                Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                break
            }
        return this.flipY && (e.y = 1 - e.y),
        e
    }
    set needsUpdate(e) {
        e === !0 && (this.version++,
        this.source.needsUpdate = !0)
    }
    set needsPMREMUpdate(e) {
        e === !0 && this.pmremVersion++
    }
}
wi.DEFAULT_IMAGE = null;
wi.DEFAULT_MAPPING = kM;
wi.DEFAULT_ANISOTROPY = 1;
class zn {
    constructor(e=0, t=0, r=0, s=1) {
        zn.prototype.isVector4 = !0,
        this.x = e,
        this.y = t,
        this.z = r,
        this.w = s
    }
    get width() {
        return this.z
    }
    set width(e) {
        this.z = e
    }
    get height() {
        return this.w
    }
    set height(e) {
        this.w = e
    }
    set(e, t, r, s) {
        return this.x = e,
        this.y = t,
        this.z = r,
        this.w = s,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this.w = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setW(e) {
        return this.w = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        case 3:
            this.w = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z,this.w)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this.w = e.w !== void 0 ? e.w : 1,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this.w += e.w,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this.w += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this.w = e.w + t.w,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this.w += e.w * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this.w -= e.w,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this.w -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this.w = e.w - t.w,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this.w *= e.w,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this.w *= e,
        this
    }
    applyMatrix4(e) {
        const t = this.x
          , r = this.y
          , s = this.z
          , o = this.w
          , u = e.elements;
        return this.x = u[0] * t + u[4] * r + u[8] * s + u[12] * o,
        this.y = u[1] * t + u[5] * r + u[9] * s + u[13] * o,
        this.z = u[2] * t + u[6] * r + u[10] * s + u[14] * o,
        this.w = u[3] * t + u[7] * r + u[11] * s + u[15] * o,
        this
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this.w /= e.w,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return t < 1e-4 ? (this.x = 1,
        this.y = 0,
        this.z = 0) : (this.x = e.x / t,
        this.y = e.y / t,
        this.z = e.z / t),
        this
    }
    setAxisAngleFromRotationMatrix(e) {
        let t, r, s, o;
        const f = e.elements
          , h = f[0]
          , m = f[4]
          , g = f[8]
          , _ = f[1]
          , x = f[5]
          , E = f[9]
          , M = f[2]
          , b = f[6]
          , y = f[10];
        if (Math.abs(m - _) < .01 && Math.abs(g - M) < .01 && Math.abs(E - b) < .01) {
            if (Math.abs(m + _) < .1 && Math.abs(g + M) < .1 && Math.abs(E + b) < .1 && Math.abs(h + x + y - 3) < .1)
                return this.set(1, 0, 0, 0),
                this;
            t = Math.PI;
            const D = (h + 1) / 2
              , C = (x + 1) / 2
              , P = (y + 1) / 2
              , A = (m + _) / 4
              , F = (g + M) / 4
              , z = (E + b) / 4;
            return D > C && D > P ? D < .01 ? (r = 0,
            s = .707106781,
            o = .707106781) : (r = Math.sqrt(D),
            s = A / r,
            o = F / r) : C > P ? C < .01 ? (r = .707106781,
            s = 0,
            o = .707106781) : (s = Math.sqrt(C),
            r = A / s,
            o = z / s) : P < .01 ? (r = .707106781,
            s = .707106781,
            o = 0) : (o = Math.sqrt(P),
            r = F / o,
            s = z / o),
            this.set(r, s, o, t),
            this
        }
        let T = Math.sqrt((b - E) * (b - E) + (g - M) * (g - M) + (_ - m) * (_ - m));
        return Math.abs(T) < .001 && (T = 1),
        this.x = (b - E) / T,
        this.y = (g - M) / T,
        this.z = (_ - m) / T,
        this.w = Math.acos((h + x + y - 1) / 2),
        this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12],
        this.y = t[13],
        this.z = t[14],
        this.w = t[15],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this.w = Math.min(this.w, e.w),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this.w = Math.max(this.w, e.w),
        this
    }
    clamp(e, t) {
        return this.x = sn(this.x, e.x, t.x),
        this.y = sn(this.y, e.y, t.y),
        this.z = sn(this.z, e.z, t.z),
        this.w = sn(this.w, e.w, t.w),
        this
    }
    clampScalar(e, t) {
        return this.x = sn(this.x, e, t),
        this.y = sn(this.y, e, t),
        this.z = sn(this.z, e, t),
        this.w = sn(this.w, e, t),
        this
    }
    clampLength(e, t) {
        const r = this.length();
        return this.divideScalar(r || 1).multiplyScalar(sn(r, e, t))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this.w = Math.floor(this.w),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this.w = Math.ceil(this.w),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this.w = Math.round(this.w),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this.w = Math.trunc(this.w),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this.w = -this.w,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this.w += (e.w - this.w) * t,
        this
    }
    lerpVectors(e, t, r) {
        return this.x = e.x + (t.x - e.x) * r,
        this.y = e.y + (t.y - e.y) * r,
        this.z = e.z + (t.z - e.z) * r,
        this.w = e.w + (t.w - e.w) * r,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this.w = e[t + 3],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e[t + 3] = this.w,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this.w = e.getW(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this.w = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z,
        yield this.w
    }
}
class tL extends wl {
    constructor(e=1, t=1, r={}) {
        super(),
        this.isRenderTarget = !0,
        this.width = e,
        this.height = t,
        this.depth = 1,
        this.scissor = new zn(0,0,e,t),
        this.scissorTest = !1,
        this.viewport = new zn(0,0,e,t);
        const s = {
            width: e,
            height: t,
            depth: 1
        };
        r = Object.assign({
            generateMipmaps: !1,
            internalFormat: null,
            minFilter: Ur,
            depthBuffer: !0,
            stencilBuffer: !1,
            resolveDepthBuffer: !0,
            resolveStencilBuffer: !0,
            depthTexture: null,
            samples: 0,
            count: 1
        }, r);
        const o = new wi(s,r.mapping,r.wrapS,r.wrapT,r.magFilter,r.minFilter,r.format,r.type,r.anisotropy,r.colorSpace);
        o.flipY = !1,
        o.generateMipmaps = r.generateMipmaps,
        o.internalFormat = r.internalFormat,
        this.textures = [];
        const u = r.count;
        for (let d = 0; d < u; d++)
            this.textures[d] = o.clone(),
            this.textures[d].isRenderTargetTexture = !0,
            this.textures[d].renderTarget = this;
        this.depthBuffer = r.depthBuffer,
        this.stencilBuffer = r.stencilBuffer,
        this.resolveDepthBuffer = r.resolveDepthBuffer,
        this.resolveStencilBuffer = r.resolveStencilBuffer,
        this._depthTexture = r.depthTexture,
        this.samples = r.samples
    }
    get texture() {
        return this.textures[0]
    }
    set texture(e) {
        this.textures[0] = e
    }
    set depthTexture(e) {
        this._depthTexture !== null && (this._depthTexture.renderTarget = null),
        e !== null && (e.renderTarget = this),
        this._depthTexture = e
    }
    get depthTexture() {
        return this._depthTexture
    }
    setSize(e, t, r=1) {
        if (this.width !== e || this.height !== t || this.depth !== r) {
            this.width = e,
            this.height = t,
            this.depth = r;
            for (let s = 0, o = this.textures.length; s < o; s++)
                this.textures[s].image.width = e,
                this.textures[s].image.height = t,
                this.textures[s].image.depth = r;
            this.dispose()
        }
        this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.scissor.copy(e.scissor),
        this.scissorTest = e.scissorTest,
        this.viewport.copy(e.viewport),
        this.textures.length = 0;
        for (let t = 0, r = e.textures.length; t < r; t++) {
            this.textures[t] = e.textures[t].clone(),
            this.textures[t].isRenderTargetTexture = !0,
            this.textures[t].renderTarget = this;
            const s = Object.assign({}, e.textures[t].image);
            this.textures[t].source = new u_(s)
        }
        return this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        this.resolveDepthBuffer = e.resolveDepthBuffer,
        this.resolveStencilBuffer = e.resolveStencilBuffer,
        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
        this.samples = e.samples,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class io extends tL {
    constructor(e=1, t=1, r={}) {
        super(e, t, r),
        this.isWebGLRenderTarget = !0
    }
}
class KM extends wi {
    constructor(e=null, t=1, r=1, s=1) {
        super(null),
        this.isDataArrayTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: r,
            depth: s
        },
        this.magFilter = xr,
        this.minFilter = xr,
        this.wrapR = Ks,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1,
        this.layerUpdates = new Set
    }
    addLayerUpdate(e) {
        this.layerUpdates.add(e)
    }
    clearLayerUpdates() {
        this.layerUpdates.clear()
    }
}
class nL extends wi {
    constructor(e=null, t=1, r=1, s=1) {
        super(null),
        this.isData3DTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: r,
            depth: s
        },
        this.magFilter = xr,
        this.minFilter = xr,
        this.wrapR = Ks,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class mu {
    constructor(e=0, t=0, r=0, s=1) {
        this.isQuaternion = !0,
        this._x = e,
        this._y = t,
        this._z = r,
        this._w = s
    }
    static slerpFlat(e, t, r, s, o, u, d) {
        let f = r[s + 0]
          , h = r[s + 1]
          , m = r[s + 2]
          , g = r[s + 3];
        const _ = o[u + 0]
          , x = o[u + 1]
          , E = o[u + 2]
          , M = o[u + 3];
        if (d === 0) {
            e[t + 0] = f,
            e[t + 1] = h,
            e[t + 2] = m,
            e[t + 3] = g;
            return
        }
        if (d === 1) {
            e[t + 0] = _,
            e[t + 1] = x,
            e[t + 2] = E,
            e[t + 3] = M;
            return
        }
        if (g !== M || f !== _ || h !== x || m !== E) {
            let b = 1 - d;
            const y = f * _ + h * x + m * E + g * M
              , T = y >= 0 ? 1 : -1
              , D = 1 - y * y;
            if (D > Number.EPSILON) {
                const P = Math.sqrt(D)
                  , A = Math.atan2(P, y * T);
                b = Math.sin(b * A) / P,
                d = Math.sin(d * A) / P
            }
            const C = d * T;
            if (f = f * b + _ * C,
            h = h * b + x * C,
            m = m * b + E * C,
            g = g * b + M * C,
            b === 1 - d) {
                const P = 1 / Math.sqrt(f * f + h * h + m * m + g * g);
                f *= P,
                h *= P,
                m *= P,
                g *= P
            }
        }
        e[t] = f,
        e[t + 1] = h,
        e[t + 2] = m,
        e[t + 3] = g
    }
    static multiplyQuaternionsFlat(e, t, r, s, o, u) {
        const d = r[s]
          , f = r[s + 1]
          , h = r[s + 2]
          , m = r[s + 3]
          , g = o[u]
          , _ = o[u + 1]
          , x = o[u + 2]
          , E = o[u + 3];
        return e[t] = d * E + m * g + f * x - h * _,
        e[t + 1] = f * E + m * _ + h * g - d * x,
        e[t + 2] = h * E + m * x + d * _ - f * g,
        e[t + 3] = m * E - d * g - f * _ - h * x,
        e
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(e) {
        this._w = e,
        this._onChangeCallback()
    }
    set(e, t, r, s) {
        return this._x = e,
        this._y = t,
        this._z = r,
        this._w = s,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._w)
    }
    copy(e) {
        return this._x = e.x,
        this._y = e.y,
        this._z = e.z,
        this._w = e.w,
        this._onChangeCallback(),
        this
    }
    setFromEuler(e, t=!0) {
        const r = e._x
          , s = e._y
          , o = e._z
          , u = e._order
          , d = Math.cos
          , f = Math.sin
          , h = d(r / 2)
          , m = d(s / 2)
          , g = d(o / 2)
          , _ = f(r / 2)
          , x = f(s / 2)
          , E = f(o / 2);
        switch (u) {
        case "XYZ":
            this._x = _ * m * g + h * x * E,
            this._y = h * x * g - _ * m * E,
            this._z = h * m * E + _ * x * g,
            this._w = h * m * g - _ * x * E;
            break;
        case "YXZ":
            this._x = _ * m * g + h * x * E,
            this._y = h * x * g - _ * m * E,
            this._z = h * m * E - _ * x * g,
            this._w = h * m * g + _ * x * E;
            break;
        case "ZXY":
            this._x = _ * m * g - h * x * E,
            this._y = h * x * g + _ * m * E,
            this._z = h * m * E + _ * x * g,
            this._w = h * m * g - _ * x * E;
            break;
        case "ZYX":
            this._x = _ * m * g - h * x * E,
            this._y = h * x * g + _ * m * E,
            this._z = h * m * E - _ * x * g,
            this._w = h * m * g + _ * x * E;
            break;
        case "YZX":
            this._x = _ * m * g + h * x * E,
            this._y = h * x * g + _ * m * E,
            this._z = h * m * E - _ * x * g,
            this._w = h * m * g - _ * x * E;
            break;
        case "XZY":
            this._x = _ * m * g - h * x * E,
            this._y = h * x * g - _ * m * E,
            this._z = h * m * E + _ * x * g,
            this._w = h * m * g + _ * x * E;
            break;
        default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + u)
        }
        return t === !0 && this._onChangeCallback(),
        this
    }
    setFromAxisAngle(e, t) {
        const r = t / 2
          , s = Math.sin(r);
        return this._x = e.x * s,
        this._y = e.y * s,
        this._z = e.z * s,
        this._w = Math.cos(r),
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e) {
        const t = e.elements
          , r = t[0]
          , s = t[4]
          , o = t[8]
          , u = t[1]
          , d = t[5]
          , f = t[9]
          , h = t[2]
          , m = t[6]
          , g = t[10]
          , _ = r + d + g;
        if (_ > 0) {
            const x = .5 / Math.sqrt(_ + 1);
            this._w = .25 / x,
            this._x = (m - f) * x,
            this._y = (o - h) * x,
            this._z = (u - s) * x
        } else if (r > d && r > g) {
            const x = 2 * Math.sqrt(1 + r - d - g);
            this._w = (m - f) / x,
            this._x = .25 * x,
            this._y = (s + u) / x,
            this._z = (o + h) / x
        } else if (d > g) {
            const x = 2 * Math.sqrt(1 + d - r - g);
            this._w = (o - h) / x,
            this._x = (s + u) / x,
            this._y = .25 * x,
            this._z = (f + m) / x
        } else {
            const x = 2 * Math.sqrt(1 + g - r - d);
            this._w = (u - s) / x,
            this._x = (o + h) / x,
            this._y = (f + m) / x,
            this._z = .25 * x
        }
        return this._onChangeCallback(),
        this
    }
    setFromUnitVectors(e, t) {
        let r = e.dot(t) + 1;
        return r < Number.EPSILON ? (r = 0,
        Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
        this._y = e.x,
        this._z = 0,
        this._w = r) : (this._x = 0,
        this._y = -e.z,
        this._z = e.y,
        this._w = r)) : (this._x = e.y * t.z - e.z * t.y,
        this._y = e.z * t.x - e.x * t.z,
        this._z = e.x * t.y - e.y * t.x,
        this._w = r),
        this.normalize()
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(sn(this.dot(e), -1, 1)))
    }
    rotateTowards(e, t) {
        const r = this.angleTo(e);
        if (r === 0)
            return this;
        const s = Math.min(1, t / r);
        return this.slerp(e, s),
        this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1,
        this._y *= -1,
        this._z *= -1,
        this._onChangeCallback(),
        this
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let e = this.length();
        return e === 0 ? (this._x = 0,
        this._y = 0,
        this._z = 0,
        this._w = 1) : (e = 1 / e,
        this._x = this._x * e,
        this._y = this._y * e,
        this._z = this._z * e,
        this._w = this._w * e),
        this._onChangeCallback(),
        this
    }
    multiply(e) {
        return this.multiplyQuaternions(this, e)
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this)
    }
    multiplyQuaternions(e, t) {
        const r = e._x
          , s = e._y
          , o = e._z
          , u = e._w
          , d = t._x
          , f = t._y
          , h = t._z
          , m = t._w;
        return this._x = r * m + u * d + s * h - o * f,
        this._y = s * m + u * f + o * d - r * h,
        this._z = o * m + u * h + r * f - s * d,
        this._w = u * m - r * d - s * f - o * h,
        this._onChangeCallback(),
        this
    }
    slerp(e, t) {
        if (t === 0)
            return this;
        if (t === 1)
            return this.copy(e);
        const r = this._x
          , s = this._y
          , o = this._z
          , u = this._w;
        let d = u * e._w + r * e._x + s * e._y + o * e._z;
        if (d < 0 ? (this._w = -e._w,
        this._x = -e._x,
        this._y = -e._y,
        this._z = -e._z,
        d = -d) : this.copy(e),
        d >= 1)
            return this._w = u,
            this._x = r,
            this._y = s,
            this._z = o,
            this;
        const f = 1 - d * d;
        if (f <= Number.EPSILON) {
            const x = 1 - t;
            return this._w = x * u + t * this._w,
            this._x = x * r + t * this._x,
            this._y = x * s + t * this._y,
            this._z = x * o + t * this._z,
            this.normalize(),
            this
        }
        const h = Math.sqrt(f)
          , m = Math.atan2(h, d)
          , g = Math.sin((1 - t) * m) / h
          , _ = Math.sin(t * m) / h;
        return this._w = u * g + this._w * _,
        this._x = r * g + this._x * _,
        this._y = s * g + this._y * _,
        this._z = o * g + this._z * _,
        this._onChangeCallback(),
        this
    }
    slerpQuaternions(e, t, r) {
        return this.copy(e).slerp(t, r)
    }
    random() {
        const e = 2 * Math.PI * Math.random()
          , t = 2 * Math.PI * Math.random()
          , r = Math.random()
          , s = Math.sqrt(1 - r)
          , o = Math.sqrt(r);
        return this.set(s * Math.sin(e), s * Math.cos(e), o * Math.sin(t), o * Math.cos(t))
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    }
    fromArray(e, t=0) {
        return this._x = e[t],
        this._y = e[t + 1],
        this._z = e[t + 2],
        this._w = e[t + 3],
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._w,
        e
    }
    fromBufferAttribute(e, t) {
        return this._x = e.getX(t),
        this._y = e.getY(t),
        this._z = e.getZ(t),
        this._w = e.getW(t),
        this._onChangeCallback(),
        this
    }
    toJSON() {
        return this.toArray()
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._w
    }
}
class Ee {
    constructor(e=0, t=0, r=0) {
        Ee.prototype.isVector3 = !0,
        this.x = e,
        this.y = t,
        this.z = r
    }
    set(e, t, r) {
        return r === void 0 && (r = this.z),
        this.x = e,
        this.y = t,
        this.z = r,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this
    }
    multiplyVectors(e, t) {
        return this.x = e.x * t.x,
        this.y = e.y * t.y,
        this.z = e.z * t.z,
        this
    }
    applyEuler(e) {
        return this.applyQuaternion(sS.setFromEuler(e))
    }
    applyAxisAngle(e, t) {
        return this.applyQuaternion(sS.setFromAxisAngle(e, t))
    }
    applyMatrix3(e) {
        const t = this.x
          , r = this.y
          , s = this.z
          , o = e.elements;
        return this.x = o[0] * t + o[3] * r + o[6] * s,
        this.y = o[1] * t + o[4] * r + o[7] * s,
        this.z = o[2] * t + o[5] * r + o[8] * s,
        this
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize()
    }
    applyMatrix4(e) {
        const t = this.x
          , r = this.y
          , s = this.z
          , o = e.elements
          , u = 1 / (o[3] * t + o[7] * r + o[11] * s + o[15]);
        return this.x = (o[0] * t + o[4] * r + o[8] * s + o[12]) * u,
        this.y = (o[1] * t + o[5] * r + o[9] * s + o[13]) * u,
        this.z = (o[2] * t + o[6] * r + o[10] * s + o[14]) * u,
        this
    }
    applyQuaternion(e) {
        const t = this.x
          , r = this.y
          , s = this.z
          , o = e.x
          , u = e.y
          , d = e.z
          , f = e.w
          , h = 2 * (u * s - d * r)
          , m = 2 * (d * t - o * s)
          , g = 2 * (o * r - u * t);
        return this.x = t + f * h + u * g - d * m,
        this.y = r + f * m + d * h - o * g,
        this.z = s + f * g + o * m - u * h,
        this
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
    }
    transformDirection(e) {
        const t = this.x
          , r = this.y
          , s = this.z
          , o = e.elements;
        return this.x = o[0] * t + o[4] * r + o[8] * s,
        this.y = o[1] * t + o[5] * r + o[9] * s,
        this.z = o[2] * t + o[6] * r + o[10] * s,
        this.normalize()
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this
    }
    clamp(e, t) {
        return this.x = sn(this.x, e.x, t.x),
        this.y = sn(this.y, e.y, t.y),
        this.z = sn(this.z, e.z, t.z),
        this
    }
    clampScalar(e, t) {
        return this.x = sn(this.x, e, t),
        this.y = sn(this.y, e, t),
        this.z = sn(this.z, e, t),
        this
    }
    clampLength(e, t) {
        const r = this.length();
        return this.divideScalar(r || 1).multiplyScalar(sn(r, e, t))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this
    }
    lerpVectors(e, t, r) {
        return this.x = e.x + (t.x - e.x) * r,
        this.y = e.y + (t.y - e.y) * r,
        this.z = e.z + (t.z - e.z) * r,
        this
    }
    cross(e) {
        return this.crossVectors(this, e)
    }
    crossVectors(e, t) {
        const r = e.x
          , s = e.y
          , o = e.z
          , u = t.x
          , d = t.y
          , f = t.z;
        return this.x = s * f - o * d,
        this.y = o * u - r * f,
        this.z = r * d - s * u,
        this
    }
    projectOnVector(e) {
        const t = e.lengthSq();
        if (t === 0)
            return this.set(0, 0, 0);
        const r = e.dot(this) / t;
        return this.copy(e).multiplyScalar(r)
    }
    projectOnPlane(e) {
        return Hm.copy(this).projectOnVector(e),
        this.sub(Hm)
    }
    reflect(e) {
        return this.sub(Hm.copy(e).multiplyScalar(2 * this.dot(e)))
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const r = this.dot(e) / t;
        return Math.acos(sn(r, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , r = this.y - e.y
          , s = this.z - e.z;
        return t * t + r * r + s * s
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
    }
    setFromSphericalCoords(e, t, r) {
        const s = Math.sin(t) * e;
        return this.x = s * Math.sin(r),
        this.y = Math.cos(t) * e,
        this.z = s * Math.cos(r),
        this
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
    }
    setFromCylindricalCoords(e, t, r) {
        return this.x = e * Math.sin(t),
        this.y = r,
        this.z = e * Math.cos(t),
        this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12],
        this.y = t[13],
        this.z = t[14],
        this
    }
    setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length()
          , r = this.setFromMatrixColumn(e, 1).length()
          , s = this.setFromMatrixColumn(e, 2).length();
        return this.x = t,
        this.y = r,
        this.z = s,
        this
    }
    setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, t * 4)
    }
    setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, t * 3)
    }
    setFromEuler(e) {
        return this.x = e._x,
        this.y = e._y,
        this.z = e._z,
        this
    }
    setFromColor(e) {
        return this.x = e.r,
        this.y = e.g,
        this.z = e.b,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this
    }
    randomDirection() {
        const e = Math.random() * Math.PI * 2
          , t = Math.random() * 2 - 1
          , r = Math.sqrt(1 - t * t);
        return this.x = r * Math.cos(e),
        this.y = t,
        this.z = r * Math.sin(e),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z
    }
}
const Hm = new Ee
  , sS = new mu;
class gu {
    constructor(e=new Ee(1 / 0,1 / 0,1 / 0), t=new Ee(-1 / 0,-1 / 0,-1 / 0)) {
        this.isBox3 = !0,
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromArray(e) {
        this.makeEmpty();
        for (let t = 0, r = e.length; t < r; t += 3)
            this.expandByPoint(fr.fromArray(e, t));
        return this
    }
    setFromBufferAttribute(e) {
        this.makeEmpty();
        for (let t = 0, r = e.count; t < r; t++)
            this.expandByPoint(fr.fromBufferAttribute(e, t));
        return this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, r = e.length; t < r; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const r = fr.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(r),
        this.max.copy(e).add(r),
        this
    }
    setFromObject(e, t=!1) {
        return this.makeEmpty(),
        this.expandByObject(e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0,
        this.max.x = this.max.y = this.max.z = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    expandByObject(e, t=!1) {
        e.updateWorldMatrix(!1, !1);
        const r = e.geometry;
        if (r !== void 0) {
            const o = r.getAttribute("position");
            if (t === !0 && o !== void 0 && e.isInstancedMesh !== !0)
                for (let u = 0, d = o.count; u < d; u++)
                    e.isMesh === !0 ? e.getVertexPosition(u, fr) : fr.fromBufferAttribute(o, u),
                    fr.applyMatrix4(e.matrixWorld),
                    this.expandByPoint(fr);
            else
                e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(),
                Pd.copy(e.boundingBox)) : (r.boundingBox === null && r.computeBoundingBox(),
                Pd.copy(r.boundingBox)),
                Pd.applyMatrix4(e.matrixWorld),
                this.union(Pd)
        }
        const s = e.children;
        for (let o = 0, u = s.length; o < u; o++)
            this.expandByObject(s[o], t);
        return this
    }
    containsPoint(e) {
        return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(e) {
        return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, fr),
        fr.distanceToSquared(e.center) <= e.radius * e.radius
    }
    intersectsPlane(e) {
        let t, r;
        return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
        r = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
        r = e.normal.x * this.min.x),
        e.normal.y > 0 ? (t += e.normal.y * this.min.y,
        r += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
        r += e.normal.y * this.min.y),
        e.normal.z > 0 ? (t += e.normal.z * this.min.z,
        r += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
        r += e.normal.z * this.min.z),
        t <= -e.constant && r >= -e.constant
    }
    intersectsTriangle(e) {
        if (this.isEmpty())
            return !1;
        this.getCenter(Cc),
        Id.subVectors(this.max, Cc),
        Go.subVectors(e.a, Cc),
        jo.subVectors(e.b, Cc),
        Wo.subVectors(e.c, Cc),
        Ja.subVectors(jo, Go),
        es.subVectors(Wo, jo),
        ks.subVectors(Go, Wo);
        let t = [0, -Ja.z, Ja.y, 0, -es.z, es.y, 0, -ks.z, ks.y, Ja.z, 0, -Ja.x, es.z, 0, -es.x, ks.z, 0, -ks.x, -Ja.y, Ja.x, 0, -es.y, es.x, 0, -ks.y, ks.x, 0];
        return !Gm(t, Go, jo, Wo, Id) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        !Gm(t, Go, jo, Wo, Id)) ? !1 : (zd.crossVectors(Ja, es),
        t = [zd.x, zd.y, zd.z],
        Gm(t, Go, jo, Wo, Id))
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return this.clampPoint(e, fr).distanceTo(e)
    }
    getBoundingSphere(e) {
        return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center),
        e.radius = this.getSize(fr).length() * .5),
        e
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    applyMatrix4(e) {
        return this.isEmpty() ? this : (ia[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        ia[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        ia[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        ia[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        ia[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        ia[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        ia[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        ia[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(ia),
        this)
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const ia = [new Ee, new Ee, new Ee, new Ee, new Ee, new Ee, new Ee, new Ee]
  , fr = new Ee
  , Pd = new gu
  , Go = new Ee
  , jo = new Ee
  , Wo = new Ee
  , Ja = new Ee
  , es = new Ee
  , ks = new Ee
  , Cc = new Ee
  , Id = new Ee
  , zd = new Ee
  , Fs = new Ee;
function Gm(n, e, t, r, s) {
    for (let o = 0, u = n.length - 3; o <= u; o += 3) {
        Fs.fromArray(n, o);
        const d = s.x * Math.abs(Fs.x) + s.y * Math.abs(Fs.y) + s.z * Math.abs(Fs.z)
          , f = e.dot(Fs)
          , h = t.dot(Fs)
          , m = r.dot(Fs);
        if (Math.max(-Math.max(f, h, m), Math.min(f, h, m)) > d)
            return !1
    }
    return !0
}
const iL = new gu
  , Dc = new Ee
  , jm = new Ee;
class ih {
    constructor(e=new Ee, t=-1) {
        this.isSphere = !0,
        this.center = e,
        this.radius = t
    }
    set(e, t) {
        return this.center.copy(e),
        this.radius = t,
        this
    }
    setFromPoints(e, t) {
        const r = this.center;
        t !== void 0 ? r.copy(t) : iL.setFromPoints(e).getCenter(r);
        let s = 0;
        for (let o = 0, u = e.length; o < u; o++)
            s = Math.max(s, r.distanceToSquared(e[o]));
        return this.radius = Math.sqrt(s),
        this
    }
    copy(e) {
        return this.center.copy(e.center),
        this.radius = e.radius,
        this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0),
        this.radius = -1,
        this
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius
    }
    intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t
    }
    intersectsBox(e) {
        return e.intersectsSphere(this)
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(e, t) {
        const r = this.center.distanceToSquared(e);
        return t.copy(e),
        r > this.radius * this.radius && (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
        t
    }
    getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(),
        e) : (e.set(this.center, this.center),
        e.expandByScalar(this.radius),
        e)
    }
    applyMatrix4(e) {
        return this.center.applyMatrix4(e),
        this.radius = this.radius * e.getMaxScaleOnAxis(),
        this
    }
    translate(e) {
        return this.center.add(e),
        this
    }
    expandByPoint(e) {
        if (this.isEmpty())
            return this.center.copy(e),
            this.radius = 0,
            this;
        Dc.subVectors(e, this.center);
        const t = Dc.lengthSq();
        if (t > this.radius * this.radius) {
            const r = Math.sqrt(t)
              , s = (r - this.radius) * .5;
            this.center.addScaledVector(Dc, s / r),
            this.radius += s
        }
        return this
    }
    union(e) {
        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
        this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (jm.subVectors(e.center, this.center).setLength(e.radius),
        this.expandByPoint(Dc.copy(e.center).add(jm)),
        this.expandByPoint(Dc.copy(e.center).sub(jm))),
        this)
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const ra = new Ee
  , Wm = new Ee
  , kd = new Ee
  , ts = new Ee
  , Xm = new Ee
  , Fd = new Ee
  , qm = new Ee;
class QM {
    constructor(e=new Ee, t=new Ee(0,0,-1)) {
        this.origin = e,
        this.direction = t
    }
    set(e, t) {
        return this.origin.copy(e),
        this.direction.copy(t),
        this
    }
    copy(e) {
        return this.origin.copy(e.origin),
        this.direction.copy(e.direction),
        this
    }
    at(e, t) {
        return t.copy(this.origin).addScaledVector(this.direction, e)
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(),
        this
    }
    recast(e) {
        return this.origin.copy(this.at(e, ra)),
        this
    }
    closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const r = t.dot(this.direction);
        return r < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, r)
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e))
    }
    distanceSqToPoint(e) {
        const t = ra.subVectors(e, this.origin).dot(this.direction);
        return t < 0 ? this.origin.distanceToSquared(e) : (ra.copy(this.origin).addScaledVector(this.direction, t),
        ra.distanceToSquared(e))
    }
    distanceSqToSegment(e, t, r, s) {
        Wm.copy(e).add(t).multiplyScalar(.5),
        kd.copy(t).sub(e).normalize(),
        ts.copy(this.origin).sub(Wm);
        const o = e.distanceTo(t) * .5
          , u = -this.direction.dot(kd)
          , d = ts.dot(this.direction)
          , f = -ts.dot(kd)
          , h = ts.lengthSq()
          , m = Math.abs(1 - u * u);
        let g, _, x, E;
        if (m > 0)
            if (g = u * f - d,
            _ = u * d - f,
            E = o * m,
            g >= 0)
                if (_ >= -E)
                    if (_ <= E) {
                        const M = 1 / m;
                        g *= M,
                        _ *= M,
                        x = g * (g + u * _ + 2 * d) + _ * (u * g + _ + 2 * f) + h
                    } else
                        _ = o,
                        g = Math.max(0, -(u * _ + d)),
                        x = -g * g + _ * (_ + 2 * f) + h;
                else
                    _ = -o,
                    g = Math.max(0, -(u * _ + d)),
                    x = -g * g + _ * (_ + 2 * f) + h;
            else
                _ <= -E ? (g = Math.max(0, -(-u * o + d)),
                _ = g > 0 ? -o : Math.min(Math.max(-o, -f), o),
                x = -g * g + _ * (_ + 2 * f) + h) : _ <= E ? (g = 0,
                _ = Math.min(Math.max(-o, -f), o),
                x = _ * (_ + 2 * f) + h) : (g = Math.max(0, -(u * o + d)),
                _ = g > 0 ? o : Math.min(Math.max(-o, -f), o),
                x = -g * g + _ * (_ + 2 * f) + h);
        else
            _ = u > 0 ? -o : o,
            g = Math.max(0, -(u * _ + d)),
            x = -g * g + _ * (_ + 2 * f) + h;
        return r && r.copy(this.origin).addScaledVector(this.direction, g),
        s && s.copy(Wm).addScaledVector(kd, _),
        x
    }
    intersectSphere(e, t) {
        ra.subVectors(e.center, this.origin);
        const r = ra.dot(this.direction)
          , s = ra.dot(ra) - r * r
          , o = e.radius * e.radius;
        if (s > o)
            return null;
        const u = Math.sqrt(o - s)
          , d = r - u
          , f = r + u;
        return f < 0 ? null : d < 0 ? this.at(f, t) : this.at(d, t)
    }
    intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius
    }
    distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (t === 0)
            return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        const r = -(this.origin.dot(e.normal) + e.constant) / t;
        return r >= 0 ? r : null
    }
    intersectPlane(e, t) {
        const r = this.distanceToPlane(e);
        return r === null ? null : this.at(r, t)
    }
    intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        return t === 0 || e.normal.dot(this.direction) * t < 0
    }
    intersectBox(e, t) {
        let r, s, o, u, d, f;
        const h = 1 / this.direction.x
          , m = 1 / this.direction.y
          , g = 1 / this.direction.z
          , _ = this.origin;
        return h >= 0 ? (r = (e.min.x - _.x) * h,
        s = (e.max.x - _.x) * h) : (r = (e.max.x - _.x) * h,
        s = (e.min.x - _.x) * h),
        m >= 0 ? (o = (e.min.y - _.y) * m,
        u = (e.max.y - _.y) * m) : (o = (e.max.y - _.y) * m,
        u = (e.min.y - _.y) * m),
        r > u || o > s || ((o > r || isNaN(r)) && (r = o),
        (u < s || isNaN(s)) && (s = u),
        g >= 0 ? (d = (e.min.z - _.z) * g,
        f = (e.max.z - _.z) * g) : (d = (e.max.z - _.z) * g,
        f = (e.min.z - _.z) * g),
        r > f || d > s) || ((d > r || r !== r) && (r = d),
        (f < s || s !== s) && (s = f),
        s < 0) ? null : this.at(r >= 0 ? r : s, t)
    }
    intersectsBox(e) {
        return this.intersectBox(e, ra) !== null
    }
    intersectTriangle(e, t, r, s, o) {
        Xm.subVectors(t, e),
        Fd.subVectors(r, e),
        qm.crossVectors(Xm, Fd);
        let u = this.direction.dot(qm), d;
        if (u > 0) {
            if (s)
                return null;
            d = 1
        } else if (u < 0)
            d = -1,
            u = -u;
        else
            return null;
        ts.subVectors(this.origin, e);
        const f = d * this.direction.dot(Fd.crossVectors(ts, Fd));
        if (f < 0)
            return null;
        const h = d * this.direction.dot(Xm.cross(ts));
        if (h < 0 || f + h > u)
            return null;
        const m = -d * ts.dot(qm);
        return m < 0 ? null : this.at(m / u, o)
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e),
        this.direction.transformDirection(e),
        this
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class Ln {
    constructor(e, t, r, s, o, u, d, f, h, m, g, _, x, E, M, b) {
        Ln.prototype.isMatrix4 = !0,
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        e !== void 0 && this.set(e, t, r, s, o, u, d, f, h, m, g, _, x, E, M, b)
    }
    set(e, t, r, s, o, u, d, f, h, m, g, _, x, E, M, b) {
        const y = this.elements;
        return y[0] = e,
        y[4] = t,
        y[8] = r,
        y[12] = s,
        y[1] = o,
        y[5] = u,
        y[9] = d,
        y[13] = f,
        y[2] = h,
        y[6] = m,
        y[10] = g,
        y[14] = _,
        y[3] = x,
        y[7] = E,
        y[11] = M,
        y[15] = b,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    clone() {
        return new Ln().fromArray(this.elements)
    }
    copy(e) {
        const t = this.elements
          , r = e.elements;
        return t[0] = r[0],
        t[1] = r[1],
        t[2] = r[2],
        t[3] = r[3],
        t[4] = r[4],
        t[5] = r[5],
        t[6] = r[6],
        t[7] = r[7],
        t[8] = r[8],
        t[9] = r[9],
        t[10] = r[10],
        t[11] = r[11],
        t[12] = r[12],
        t[13] = r[13],
        t[14] = r[14],
        t[15] = r[15],
        this
    }
    copyPosition(e) {
        const t = this.elements
          , r = e.elements;
        return t[12] = r[12],
        t[13] = r[13],
        t[14] = r[14],
        this
    }
    setFromMatrix3(e) {
        const t = e.elements;
        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
        this
    }
    extractBasis(e, t, r) {
        return e.setFromMatrixColumn(this, 0),
        t.setFromMatrixColumn(this, 1),
        r.setFromMatrixColumn(this, 2),
        this
    }
    makeBasis(e, t, r) {
        return this.set(e.x, t.x, r.x, 0, e.y, t.y, r.y, 0, e.z, t.z, r.z, 0, 0, 0, 0, 1),
        this
    }
    extractRotation(e) {
        const t = this.elements
          , r = e.elements
          , s = 1 / Xo.setFromMatrixColumn(e, 0).length()
          , o = 1 / Xo.setFromMatrixColumn(e, 1).length()
          , u = 1 / Xo.setFromMatrixColumn(e, 2).length();
        return t[0] = r[0] * s,
        t[1] = r[1] * s,
        t[2] = r[2] * s,
        t[3] = 0,
        t[4] = r[4] * o,
        t[5] = r[5] * o,
        t[6] = r[6] * o,
        t[7] = 0,
        t[8] = r[8] * u,
        t[9] = r[9] * u,
        t[10] = r[10] * u,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromEuler(e) {
        const t = this.elements
          , r = e.x
          , s = e.y
          , o = e.z
          , u = Math.cos(r)
          , d = Math.sin(r)
          , f = Math.cos(s)
          , h = Math.sin(s)
          , m = Math.cos(o)
          , g = Math.sin(o);
        if (e.order === "XYZ") {
            const _ = u * m
              , x = u * g
              , E = d * m
              , M = d * g;
            t[0] = f * m,
            t[4] = -f * g,
            t[8] = h,
            t[1] = x + E * h,
            t[5] = _ - M * h,
            t[9] = -d * f,
            t[2] = M - _ * h,
            t[6] = E + x * h,
            t[10] = u * f
        } else if (e.order === "YXZ") {
            const _ = f * m
              , x = f * g
              , E = h * m
              , M = h * g;
            t[0] = _ + M * d,
            t[4] = E * d - x,
            t[8] = u * h,
            t[1] = u * g,
            t[5] = u * m,
            t[9] = -d,
            t[2] = x * d - E,
            t[6] = M + _ * d,
            t[10] = u * f
        } else if (e.order === "ZXY") {
            const _ = f * m
              , x = f * g
              , E = h * m
              , M = h * g;
            t[0] = _ - M * d,
            t[4] = -u * g,
            t[8] = E + x * d,
            t[1] = x + E * d,
            t[5] = u * m,
            t[9] = M - _ * d,
            t[2] = -u * h,
            t[6] = d,
            t[10] = u * f
        } else if (e.order === "ZYX") {
            const _ = u * m
              , x = u * g
              , E = d * m
              , M = d * g;
            t[0] = f * m,
            t[4] = E * h - x,
            t[8] = _ * h + M,
            t[1] = f * g,
            t[5] = M * h + _,
            t[9] = x * h - E,
            t[2] = -h,
            t[6] = d * f,
            t[10] = u * f
        } else if (e.order === "YZX") {
            const _ = u * f
              , x = u * h
              , E = d * f
              , M = d * h;
            t[0] = f * m,
            t[4] = M - _ * g,
            t[8] = E * g + x,
            t[1] = g,
            t[5] = u * m,
            t[9] = -d * m,
            t[2] = -h * m,
            t[6] = x * g + E,
            t[10] = _ - M * g
        } else if (e.order === "XZY") {
            const _ = u * f
              , x = u * h
              , E = d * f
              , M = d * h;
            t[0] = f * m,
            t[4] = -g,
            t[8] = h * m,
            t[1] = _ * g + M,
            t[5] = u * m,
            t[9] = x * g - E,
            t[2] = E * g - x,
            t[6] = d * m,
            t[10] = M * g + _
        }
        return t[3] = 0,
        t[7] = 0,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromQuaternion(e) {
        return this.compose(rL, e, aL)
    }
    lookAt(e, t, r) {
        const s = this.elements;
        return Hi.subVectors(e, t),
        Hi.lengthSq() === 0 && (Hi.z = 1),
        Hi.normalize(),
        ns.crossVectors(r, Hi),
        ns.lengthSq() === 0 && (Math.abs(r.z) === 1 ? Hi.x += 1e-4 : Hi.z += 1e-4,
        Hi.normalize(),
        ns.crossVectors(r, Hi)),
        ns.normalize(),
        Bd.crossVectors(Hi, ns),
        s[0] = ns.x,
        s[4] = Bd.x,
        s[8] = Hi.x,
        s[1] = ns.y,
        s[5] = Bd.y,
        s[9] = Hi.y,
        s[2] = ns.z,
        s[6] = Bd.z,
        s[10] = Hi.z,
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const r = e.elements
          , s = t.elements
          , o = this.elements
          , u = r[0]
          , d = r[4]
          , f = r[8]
          , h = r[12]
          , m = r[1]
          , g = r[5]
          , _ = r[9]
          , x = r[13]
          , E = r[2]
          , M = r[6]
          , b = r[10]
          , y = r[14]
          , T = r[3]
          , D = r[7]
          , C = r[11]
          , P = r[15]
          , A = s[0]
          , F = s[4]
          , z = s[8]
          , U = s[12]
          , R = s[1]
          , V = s[5]
          , Q = s[9]
          , X = s[13]
          , oe = s[2]
          , le = s[6]
          , O = s[10]
          , W = s[14]
          , H = s[3]
          , Me = s[7]
          , k = s[11]
          , ee = s[15];
        return o[0] = u * A + d * R + f * oe + h * H,
        o[4] = u * F + d * V + f * le + h * Me,
        o[8] = u * z + d * Q + f * O + h * k,
        o[12] = u * U + d * X + f * W + h * ee,
        o[1] = m * A + g * R + _ * oe + x * H,
        o[5] = m * F + g * V + _ * le + x * Me,
        o[9] = m * z + g * Q + _ * O + x * k,
        o[13] = m * U + g * X + _ * W + x * ee,
        o[2] = E * A + M * R + b * oe + y * H,
        o[6] = E * F + M * V + b * le + y * Me,
        o[10] = E * z + M * Q + b * O + y * k,
        o[14] = E * U + M * X + b * W + y * ee,
        o[3] = T * A + D * R + C * oe + P * H,
        o[7] = T * F + D * V + C * le + P * Me,
        o[11] = T * z + D * Q + C * O + P * k,
        o[15] = T * U + D * X + C * W + P * ee,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[4] *= e,
        t[8] *= e,
        t[12] *= e,
        t[1] *= e,
        t[5] *= e,
        t[9] *= e,
        t[13] *= e,
        t[2] *= e,
        t[6] *= e,
        t[10] *= e,
        t[14] *= e,
        t[3] *= e,
        t[7] *= e,
        t[11] *= e,
        t[15] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , r = e[4]
          , s = e[8]
          , o = e[12]
          , u = e[1]
          , d = e[5]
          , f = e[9]
          , h = e[13]
          , m = e[2]
          , g = e[6]
          , _ = e[10]
          , x = e[14]
          , E = e[3]
          , M = e[7]
          , b = e[11]
          , y = e[15];
        return E * (+o * f * g - s * h * g - o * d * _ + r * h * _ + s * d * x - r * f * x) + M * (+t * f * x - t * h * _ + o * u * _ - s * u * x + s * h * m - o * f * m) + b * (+t * h * g - t * d * x - o * u * g + r * u * x + o * d * m - r * h * m) + y * (-s * d * m - t * f * g + t * d * _ + s * u * g - r * u * _ + r * f * m)
    }
    transpose() {
        const e = this.elements;
        let t;
        return t = e[1],
        e[1] = e[4],
        e[4] = t,
        t = e[2],
        e[2] = e[8],
        e[8] = t,
        t = e[6],
        e[6] = e[9],
        e[9] = t,
        t = e[3],
        e[3] = e[12],
        e[12] = t,
        t = e[7],
        e[7] = e[13],
        e[13] = t,
        t = e[11],
        e[11] = e[14],
        e[14] = t,
        this
    }
    setPosition(e, t, r) {
        const s = this.elements;
        return e.isVector3 ? (s[12] = e.x,
        s[13] = e.y,
        s[14] = e.z) : (s[12] = e,
        s[13] = t,
        s[14] = r),
        this
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , r = e[1]
          , s = e[2]
          , o = e[3]
          , u = e[4]
          , d = e[5]
          , f = e[6]
          , h = e[7]
          , m = e[8]
          , g = e[9]
          , _ = e[10]
          , x = e[11]
          , E = e[12]
          , M = e[13]
          , b = e[14]
          , y = e[15]
          , T = g * b * h - M * _ * h + M * f * x - d * b * x - g * f * y + d * _ * y
          , D = E * _ * h - m * b * h - E * f * x + u * b * x + m * f * y - u * _ * y
          , C = m * M * h - E * g * h + E * d * x - u * M * x - m * d * y + u * g * y
          , P = E * g * f - m * M * f - E * d * _ + u * M * _ + m * d * b - u * g * b
          , A = t * T + r * D + s * C + o * P;
        if (A === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const F = 1 / A;
        return e[0] = T * F,
        e[1] = (M * _ * o - g * b * o - M * s * x + r * b * x + g * s * y - r * _ * y) * F,
        e[2] = (d * b * o - M * f * o + M * s * h - r * b * h - d * s * y + r * f * y) * F,
        e[3] = (g * f * o - d * _ * o - g * s * h + r * _ * h + d * s * x - r * f * x) * F,
        e[4] = D * F,
        e[5] = (m * b * o - E * _ * o + E * s * x - t * b * x - m * s * y + t * _ * y) * F,
        e[6] = (E * f * o - u * b * o - E * s * h + t * b * h + u * s * y - t * f * y) * F,
        e[7] = (u * _ * o - m * f * o + m * s * h - t * _ * h - u * s * x + t * f * x) * F,
        e[8] = C * F,
        e[9] = (E * g * o - m * M * o - E * r * x + t * M * x + m * r * y - t * g * y) * F,
        e[10] = (u * M * o - E * d * o + E * r * h - t * M * h - u * r * y + t * d * y) * F,
        e[11] = (m * d * o - u * g * o - m * r * h + t * g * h + u * r * x - t * d * x) * F,
        e[12] = P * F,
        e[13] = (m * M * s - E * g * s + E * r * _ - t * M * _ - m * r * b + t * g * b) * F,
        e[14] = (E * d * s - u * M * s - E * r * f + t * M * f + u * r * b - t * d * b) * F,
        e[15] = (u * g * s - m * d * s + m * r * f - t * g * f - u * r * _ + t * d * _) * F,
        this
    }
    scale(e) {
        const t = this.elements
          , r = e.x
          , s = e.y
          , o = e.z;
        return t[0] *= r,
        t[4] *= s,
        t[8] *= o,
        t[1] *= r,
        t[5] *= s,
        t[9] *= o,
        t[2] *= r,
        t[6] *= s,
        t[10] *= o,
        t[3] *= r,
        t[7] *= s,
        t[11] *= o,
        this
    }
    getMaxScaleOnAxis() {
        const e = this.elements
          , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
          , r = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
          , s = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, r, s))
    }
    makeTranslation(e, t, r) {
        return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, r, 0, 0, 0, 1),
        this
    }
    makeRotationX(e) {
        const t = Math.cos(e)
          , r = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -r, 0, 0, r, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationY(e) {
        const t = Math.cos(e)
          , r = Math.sin(e);
        return this.set(t, 0, r, 0, 0, 1, 0, 0, -r, 0, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationZ(e) {
        const t = Math.cos(e)
          , r = Math.sin(e);
        return this.set(t, -r, 0, 0, r, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    makeRotationAxis(e, t) {
        const r = Math.cos(t)
          , s = Math.sin(t)
          , o = 1 - r
          , u = e.x
          , d = e.y
          , f = e.z
          , h = o * u
          , m = o * d;
        return this.set(h * u + r, h * d - s * f, h * f + s * d, 0, h * d + s * f, m * d + r, m * f - s * u, 0, h * f - s * d, m * f + s * u, o * f * f + r, 0, 0, 0, 0, 1),
        this
    }
    makeScale(e, t, r) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, r, 0, 0, 0, 0, 1),
        this
    }
    makeShear(e, t, r, s, o, u) {
        return this.set(1, r, o, 0, e, 1, u, 0, t, s, 1, 0, 0, 0, 0, 1),
        this
    }
    compose(e, t, r) {
        const s = this.elements
          , o = t._x
          , u = t._y
          , d = t._z
          , f = t._w
          , h = o + o
          , m = u + u
          , g = d + d
          , _ = o * h
          , x = o * m
          , E = o * g
          , M = u * m
          , b = u * g
          , y = d * g
          , T = f * h
          , D = f * m
          , C = f * g
          , P = r.x
          , A = r.y
          , F = r.z;
        return s[0] = (1 - (M + y)) * P,
        s[1] = (x + C) * P,
        s[2] = (E - D) * P,
        s[3] = 0,
        s[4] = (x - C) * A,
        s[5] = (1 - (_ + y)) * A,
        s[6] = (b + T) * A,
        s[7] = 0,
        s[8] = (E + D) * F,
        s[9] = (b - T) * F,
        s[10] = (1 - (_ + M)) * F,
        s[11] = 0,
        s[12] = e.x,
        s[13] = e.y,
        s[14] = e.z,
        s[15] = 1,
        this
    }
    decompose(e, t, r) {
        const s = this.elements;
        let o = Xo.set(s[0], s[1], s[2]).length();
        const u = Xo.set(s[4], s[5], s[6]).length()
          , d = Xo.set(s[8], s[9], s[10]).length();
        this.determinant() < 0 && (o = -o),
        e.x = s[12],
        e.y = s[13],
        e.z = s[14],
        hr.copy(this);
        const h = 1 / o
          , m = 1 / u
          , g = 1 / d;
        return hr.elements[0] *= h,
        hr.elements[1] *= h,
        hr.elements[2] *= h,
        hr.elements[4] *= m,
        hr.elements[5] *= m,
        hr.elements[6] *= m,
        hr.elements[8] *= g,
        hr.elements[9] *= g,
        hr.elements[10] *= g,
        t.setFromRotationMatrix(hr),
        r.x = o,
        r.y = u,
        r.z = d,
        this
    }
    makePerspective(e, t, r, s, o, u, d=xa) {
        const f = this.elements
          , h = 2 * o / (t - e)
          , m = 2 * o / (r - s)
          , g = (t + e) / (t - e)
          , _ = (r + s) / (r - s);
        let x, E;
        if (d === xa)
            x = -(u + o) / (u - o),
            E = -2 * u * o / (u - o);
        else if (d === Tf)
            x = -u / (u - o),
            E = -u * o / (u - o);
        else
            throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + d);
        return f[0] = h,
        f[4] = 0,
        f[8] = g,
        f[12] = 0,
        f[1] = 0,
        f[5] = m,
        f[9] = _,
        f[13] = 0,
        f[2] = 0,
        f[6] = 0,
        f[10] = x,
        f[14] = E,
        f[3] = 0,
        f[7] = 0,
        f[11] = -1,
        f[15] = 0,
        this
    }
    makeOrthographic(e, t, r, s, o, u, d=xa) {
        const f = this.elements
          , h = 1 / (t - e)
          , m = 1 / (r - s)
          , g = 1 / (u - o)
          , _ = (t + e) * h
          , x = (r + s) * m;
        let E, M;
        if (d === xa)
            E = (u + o) * g,
            M = -2 * g;
        else if (d === Tf)
            E = o * g,
            M = -1 * g;
        else
            throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + d);
        return f[0] = 2 * h,
        f[4] = 0,
        f[8] = 0,
        f[12] = -_,
        f[1] = 0,
        f[5] = 2 * m,
        f[9] = 0,
        f[13] = -x,
        f[2] = 0,
        f[6] = 0,
        f[10] = M,
        f[14] = -E,
        f[3] = 0,
        f[7] = 0,
        f[11] = 0,
        f[15] = 1,
        this
    }
    equals(e) {
        const t = this.elements
          , r = e.elements;
        for (let s = 0; s < 16; s++)
            if (t[s] !== r[s])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let r = 0; r < 16; r++)
            this.elements[r] = e[r + t];
        return this
    }
    toArray(e=[], t=0) {
        const r = this.elements;
        return e[t] = r[0],
        e[t + 1] = r[1],
        e[t + 2] = r[2],
        e[t + 3] = r[3],
        e[t + 4] = r[4],
        e[t + 5] = r[5],
        e[t + 6] = r[6],
        e[t + 7] = r[7],
        e[t + 8] = r[8],
        e[t + 9] = r[9],
        e[t + 10] = r[10],
        e[t + 11] = r[11],
        e[t + 12] = r[12],
        e[t + 13] = r[13],
        e[t + 14] = r[14],
        e[t + 15] = r[15],
        e
    }
}
const Xo = new Ee
  , hr = new Ln
  , rL = new Ee(0,0,0)
  , aL = new Ee(1,1,1)
  , ns = new Ee
  , Bd = new Ee
  , Hi = new Ee
  , oS = new Ln
  , lS = new mu;
class Aa {
    constructor(e=0, t=0, r=0, s=Aa.DEFAULT_ORDER) {
        this.isEuler = !0,
        this._x = e,
        this._y = t,
        this._z = r,
        this._order = s
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(e) {
        this._order = e,
        this._onChangeCallback()
    }
    set(e, t, r, s=this._order) {
        return this._x = e,
        this._y = t,
        this._z = r,
        this._order = s,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._order)
    }
    copy(e) {
        return this._x = e._x,
        this._y = e._y,
        this._z = e._z,
        this._order = e._order,
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e, t=this._order, r=!0) {
        const s = e.elements
          , o = s[0]
          , u = s[4]
          , d = s[8]
          , f = s[1]
          , h = s[5]
          , m = s[9]
          , g = s[2]
          , _ = s[6]
          , x = s[10];
        switch (t) {
        case "XYZ":
            this._y = Math.asin(sn(d, -1, 1)),
            Math.abs(d) < .9999999 ? (this._x = Math.atan2(-m, x),
            this._z = Math.atan2(-u, o)) : (this._x = Math.atan2(_, h),
            this._z = 0);
            break;
        case "YXZ":
            this._x = Math.asin(-sn(m, -1, 1)),
            Math.abs(m) < .9999999 ? (this._y = Math.atan2(d, x),
            this._z = Math.atan2(f, h)) : (this._y = Math.atan2(-g, o),
            this._z = 0);
            break;
        case "ZXY":
            this._x = Math.asin(sn(_, -1, 1)),
            Math.abs(_) < .9999999 ? (this._y = Math.atan2(-g, x),
            this._z = Math.atan2(-u, h)) : (this._y = 0,
            this._z = Math.atan2(f, o));
            break;
        case "ZYX":
            this._y = Math.asin(-sn(g, -1, 1)),
            Math.abs(g) < .9999999 ? (this._x = Math.atan2(_, x),
            this._z = Math.atan2(f, o)) : (this._x = 0,
            this._z = Math.atan2(-u, h));
            break;
        case "YZX":
            this._z = Math.asin(sn(f, -1, 1)),
            Math.abs(f) < .9999999 ? (this._x = Math.atan2(-m, h),
            this._y = Math.atan2(-g, o)) : (this._x = 0,
            this._y = Math.atan2(d, x));
            break;
        case "XZY":
            this._z = Math.asin(-sn(u, -1, 1)),
            Math.abs(u) < .9999999 ? (this._x = Math.atan2(_, h),
            this._y = Math.atan2(d, o)) : (this._x = Math.atan2(-m, x),
            this._y = 0);
            break;
        default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
        }
        return this._order = t,
        r === !0 && this._onChangeCallback(),
        this
    }
    setFromQuaternion(e, t, r) {
        return oS.makeRotationFromQuaternion(e),
        this.setFromRotationMatrix(oS, t, r)
    }
    setFromVector3(e, t=this._order) {
        return this.set(e.x, e.y, e.z, t)
    }
    reorder(e) {
        return lS.setFromEuler(this),
        this.setFromQuaternion(lS, e)
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    }
    fromArray(e) {
        return this._x = e[0],
        this._y = e[1],
        this._z = e[2],
        e[3] !== void 0 && (this._order = e[3]),
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._order,
        e
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._order
    }
}
Aa.DEFAULT_ORDER = "XYZ";
class JM {
    constructor() {
        this.mask = 1
    }
    set(e) {
        this.mask = (1 << e | 0) >>> 0
    }
    enable(e) {
        this.mask |= 1 << e | 0
    }
    enableAll() {
        this.mask = -1
    }
    toggle(e) {
        this.mask ^= 1 << e | 0
    }
    disable(e) {
        this.mask &= ~(1 << e | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test(e) {
        return (this.mask & e.mask) !== 0
    }
    isEnabled(e) {
        return (this.mask & (1 << e | 0)) !== 0
    }
}
let sL = 0;
const cS = new Ee
  , qo = new mu
  , aa = new Ln
  , Vd = new Ee
  , Uc = new Ee
  , oL = new Ee
  , lL = new mu
  , uS = new Ee(1,0,0)
  , dS = new Ee(0,1,0)
  , fS = new Ee(0,0,1)
  , hS = {
    type: "added"
}
  , cL = {
    type: "removed"
}
  , Yo = {
    type: "childadded",
    child: null
}
  , Ym = {
    type: "childremoved",
    child: null
};
class fi extends wl {
    constructor() {
        super(),
        this.isObject3D = !0,
        Object.defineProperty(this, "id", {
            value: sL++
        }),
        this.uuid = pu(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = fi.DEFAULT_UP.clone();
        const e = new Ee
          , t = new Aa
          , r = new mu
          , s = new Ee(1,1,1);
        function o() {
            r.setFromEuler(t, !1)
        }
        function u() {
            t.setFromQuaternion(r, void 0, !1)
        }
        t._onChange(o),
        r._onChange(u),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: r
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: s
            },
            modelViewMatrix: {
                value: new Ln
            },
            normalMatrix: {
                value: new Vt
            }
        }),
        this.matrix = new Ln,
        this.matrixWorld = new Ln,
        this.matrixAutoUpdate = fi.DEFAULT_MATRIX_AUTO_UPDATE,
        this.matrixWorldAutoUpdate = fi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new JM,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.customDepthMaterial = void 0,
        this.customDistanceMaterial = void 0,
        this.userData = {}
    }
    onBeforeShadow() {}
    onAfterShadow() {}
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(e),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e),
        this
    }
    setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t)
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0)
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e)
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e)
    }
    rotateOnAxis(e, t) {
        return qo.setFromAxisAngle(e, t),
        this.quaternion.multiply(qo),
        this
    }
    rotateOnWorldAxis(e, t) {
        return qo.setFromAxisAngle(e, t),
        this.quaternion.premultiply(qo),
        this
    }
    rotateX(e) {
        return this.rotateOnAxis(uS, e)
    }
    rotateY(e) {
        return this.rotateOnAxis(dS, e)
    }
    rotateZ(e) {
        return this.rotateOnAxis(fS, e)
    }
    translateOnAxis(e, t) {
        return cS.copy(e).applyQuaternion(this.quaternion),
        this.position.add(cS.multiplyScalar(t)),
        this
    }
    translateX(e) {
        return this.translateOnAxis(uS, e)
    }
    translateY(e) {
        return this.translateOnAxis(dS, e)
    }
    translateZ(e) {
        return this.translateOnAxis(fS, e)
    }
    localToWorld(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(aa.copy(this.matrixWorld).invert())
    }
    lookAt(e, t, r) {
        e.isVector3 ? Vd.copy(e) : Vd.set(e, t, r);
        const s = this.parent;
        this.updateWorldMatrix(!0, !1),
        Uc.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight ? aa.lookAt(Uc, Vd, this.up) : aa.lookAt(Vd, Uc, this.up),
        this.quaternion.setFromRotationMatrix(aa),
        s && (aa.extractRotation(s.matrixWorld),
        qo.setFromRotationMatrix(aa),
        this.quaternion.premultiply(qo.invert()))
    }
    add(e) {
        if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++)
                this.add(arguments[t]);
            return this
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
        this) : (e && e.isObject3D ? (e.removeFromParent(),
        e.parent = this,
        this.children.push(e),
        e.dispatchEvent(hS),
        Yo.child = e,
        this.dispatchEvent(Yo),
        Yo.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
        this)
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let r = 0; r < arguments.length; r++)
                this.remove(arguments[r]);
            return this
        }
        const t = this.children.indexOf(e);
        return t !== -1 && (e.parent = null,
        this.children.splice(t, 1),
        e.dispatchEvent(cL),
        Ym.child = e,
        this.dispatchEvent(Ym),
        Ym.child = null),
        this
    }
    removeFromParent() {
        const e = this.parent;
        return e !== null && e.remove(this),
        this
    }
    clear() {
        return this.remove(...this.children)
    }
    attach(e) {
        return this.updateWorldMatrix(!0, !1),
        aa.copy(this.matrixWorld).invert(),
        e.parent !== null && (e.parent.updateWorldMatrix(!0, !1),
        aa.multiply(e.parent.matrixWorld)),
        e.applyMatrix4(aa),
        e.removeFromParent(),
        e.parent = this,
        this.children.push(e),
        e.updateWorldMatrix(!1, !0),
        e.dispatchEvent(hS),
        Yo.child = e,
        this.dispatchEvent(Yo),
        Yo.child = null,
        this
    }
    getObjectById(e) {
        return this.getObjectByProperty("id", e)
    }
    getObjectByName(e) {
        return this.getObjectByProperty("name", e)
    }
    getObjectByProperty(e, t) {
        if (this[e] === t)
            return this;
        for (let r = 0, s = this.children.length; r < s; r++) {
            const u = this.children[r].getObjectByProperty(e, t);
            if (u !== void 0)
                return u
        }
    }
    getObjectsByProperty(e, t, r=[]) {
        this[e] === t && r.push(this);
        const s = this.children;
        for (let o = 0, u = s.length; o < u; o++)
            s[o].getObjectsByProperty(e, t, r);
        return r
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1),
        e.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(Uc, e, oL),
        e
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose(Uc, lL, e),
        e
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize()
    }
    raycast() {}
    traverse(e) {
        e(this);
        const t = this.children;
        for (let r = 0, s = t.length; r < s; r++)
            t[r].traverse(e)
    }
    traverseVisible(e) {
        if (this.visible === !1)
            return;
        e(this);
        const t = this.children;
        for (let r = 0, s = t.length; r < s; r++)
            t[r].traverseVisible(e)
    }
    traverseAncestors(e) {
        const t = this.parent;
        t !== null && (e(t),
        t.traverseAncestors(e))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
        this.matrixWorldNeedsUpdate = !1,
        e = !0);
        const t = this.children;
        for (let r = 0, s = t.length; r < s; r++)
            t[r].updateMatrixWorld(e)
    }
    updateWorldMatrix(e, t) {
        const r = this.parent;
        if (e === !0 && r !== null && r.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
        t === !0) {
            const s = this.children;
            for (let o = 0, u = s.length; o < u; o++)
                s[o].updateWorldMatrix(!1, !0)
        }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string"
          , r = {};
        t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        },
        r.metadata = {
            version: 4.6,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const s = {};
        s.uuid = this.uuid,
        s.type = this.type,
        this.name !== "" && (s.name = this.name),
        this.castShadow === !0 && (s.castShadow = !0),
        this.receiveShadow === !0 && (s.receiveShadow = !0),
        this.visible === !1 && (s.visible = !1),
        this.frustumCulled === !1 && (s.frustumCulled = !1),
        this.renderOrder !== 0 && (s.renderOrder = this.renderOrder),
        Object.keys(this.userData).length > 0 && (s.userData = this.userData),
        s.layers = this.layers.mask,
        s.matrix = this.matrix.toArray(),
        s.up = this.up.toArray(),
        this.matrixAutoUpdate === !1 && (s.matrixAutoUpdate = !1),
        this.isInstancedMesh && (s.type = "InstancedMesh",
        s.count = this.count,
        s.instanceMatrix = this.instanceMatrix.toJSON(),
        this.instanceColor !== null && (s.instanceColor = this.instanceColor.toJSON())),
        this.isBatchedMesh && (s.type = "BatchedMesh",
        s.perObjectFrustumCulled = this.perObjectFrustumCulled,
        s.sortObjects = this.sortObjects,
        s.drawRanges = this._drawRanges,
        s.reservedRanges = this._reservedRanges,
        s.visibility = this._visibility,
        s.active = this._active,
        s.bounds = this._bounds.map(d => ({
            boxInitialized: d.boxInitialized,
            boxMin: d.box.min.toArray(),
            boxMax: d.box.max.toArray(),
            sphereInitialized: d.sphereInitialized,
            sphereRadius: d.sphere.radius,
            sphereCenter: d.sphere.center.toArray()
        })),
        s.maxInstanceCount = this._maxInstanceCount,
        s.maxVertexCount = this._maxVertexCount,
        s.maxIndexCount = this._maxIndexCount,
        s.geometryInitialized = this._geometryInitialized,
        s.geometryCount = this._geometryCount,
        s.matricesTexture = this._matricesTexture.toJSON(e),
        this._colorsTexture !== null && (s.colorsTexture = this._colorsTexture.toJSON(e)),
        this.boundingSphere !== null && (s.boundingSphere = {
            center: s.boundingSphere.center.toArray(),
            radius: s.boundingSphere.radius
        }),
        this.boundingBox !== null && (s.boundingBox = {
            min: s.boundingBox.min.toArray(),
            max: s.boundingBox.max.toArray()
        }));
        function o(d, f) {
            return d[f.uuid] === void 0 && (d[f.uuid] = f.toJSON(e)),
            f.uuid
        }
        if (this.isScene)
            this.background && (this.background.isColor ? s.background = this.background.toJSON() : this.background.isTexture && (s.background = this.background.toJSON(e).uuid)),
            this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (s.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            s.geometry = o(e.geometries, this.geometry);
            const d = this.geometry.parameters;
            if (d !== void 0 && d.shapes !== void 0) {
                const f = d.shapes;
                if (Array.isArray(f))
                    for (let h = 0, m = f.length; h < m; h++) {
                        const g = f[h];
                        o(e.shapes, g)
                    }
                else
                    o(e.shapes, f)
            }
        }
        if (this.isSkinnedMesh && (s.bindMode = this.bindMode,
        s.bindMatrix = this.bindMatrix.toArray(),
        this.skeleton !== void 0 && (o(e.skeletons, this.skeleton),
        s.skeleton = this.skeleton.uuid)),
        this.material !== void 0)
            if (Array.isArray(this.material)) {
                const d = [];
                for (let f = 0, h = this.material.length; f < h; f++)
                    d.push(o(e.materials, this.material[f]));
                s.material = d
            } else
                s.material = o(e.materials, this.material);
        if (this.children.length > 0) {
            s.children = [];
            for (let d = 0; d < this.children.length; d++)
                s.children.push(this.children[d].toJSON(e).object)
        }
        if (this.animations.length > 0) {
            s.animations = [];
            for (let d = 0; d < this.animations.length; d++) {
                const f = this.animations[d];
                s.animations.push(o(e.animations, f))
            }
        }
        if (t) {
            const d = u(e.geometries)
              , f = u(e.materials)
              , h = u(e.textures)
              , m = u(e.images)
              , g = u(e.shapes)
              , _ = u(e.skeletons)
              , x = u(e.animations)
              , E = u(e.nodes);
            d.length > 0 && (r.geometries = d),
            f.length > 0 && (r.materials = f),
            h.length > 0 && (r.textures = h),
            m.length > 0 && (r.images = m),
            g.length > 0 && (r.shapes = g),
            _.length > 0 && (r.skeletons = _),
            x.length > 0 && (r.animations = x),
            E.length > 0 && (r.nodes = E)
        }
        return r.object = s,
        r;
        function u(d) {
            const f = [];
            for (const h in d) {
                const m = d[h];
                delete m.metadata,
                f.push(m)
            }
            return f
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e)
    }
    copy(e, t=!0) {
        if (this.name = e.name,
        this.up.copy(e.up),
        this.position.copy(e.position),
        this.rotation.order = e.rotation.order,
        this.quaternion.copy(e.quaternion),
        this.scale.copy(e.scale),
        this.matrix.copy(e.matrix),
        this.matrixWorld.copy(e.matrixWorld),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
        this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
        this.layers.mask = e.layers.mask,
        this.visible = e.visible,
        this.castShadow = e.castShadow,
        this.receiveShadow = e.receiveShadow,
        this.frustumCulled = e.frustumCulled,
        this.renderOrder = e.renderOrder,
        this.animations = e.animations.slice(),
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        t === !0)
            for (let r = 0; r < e.children.length; r++) {
                const s = e.children[r];
                this.add(s.clone())
            }
        return this
    }
}
fi.DEFAULT_UP = new Ee(0,1,0);
fi.DEFAULT_MATRIX_AUTO_UPDATE = !0;
fi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const pr = new Ee
  , sa = new Ee
  , Zm = new Ee
  , oa = new Ee
  , Zo = new Ee
  , $o = new Ee
  , pS = new Ee
  , $m = new Ee
  , Km = new Ee
  , Qm = new Ee
  , Jm = new zn
  , eg = new zn
  , tg = new zn;
class gr {
    constructor(e=new Ee, t=new Ee, r=new Ee) {
        this.a = e,
        this.b = t,
        this.c = r
    }
    static getNormal(e, t, r, s) {
        s.subVectors(r, t),
        pr.subVectors(e, t),
        s.cross(pr);
        const o = s.lengthSq();
        return o > 0 ? s.multiplyScalar(1 / Math.sqrt(o)) : s.set(0, 0, 0)
    }
    static getBarycoord(e, t, r, s, o) {
        pr.subVectors(s, t),
        sa.subVectors(r, t),
        Zm.subVectors(e, t);
        const u = pr.dot(pr)
          , d = pr.dot(sa)
          , f = pr.dot(Zm)
          , h = sa.dot(sa)
          , m = sa.dot(Zm)
          , g = u * h - d * d;
        if (g === 0)
            return o.set(0, 0, 0),
            null;
        const _ = 1 / g
          , x = (h * f - d * m) * _
          , E = (u * m - d * f) * _;
        return o.set(1 - x - E, E, x)
    }
    static containsPoint(e, t, r, s) {
        return this.getBarycoord(e, t, r, s, oa) === null ? !1 : oa.x >= 0 && oa.y >= 0 && oa.x + oa.y <= 1
    }
    static getInterpolation(e, t, r, s, o, u, d, f) {
        return this.getBarycoord(e, t, r, s, oa) === null ? (f.x = 0,
        f.y = 0,
        "z"in f && (f.z = 0),
        "w"in f && (f.w = 0),
        null) : (f.setScalar(0),
        f.addScaledVector(o, oa.x),
        f.addScaledVector(u, oa.y),
        f.addScaledVector(d, oa.z),
        f)
    }
    static getInterpolatedAttribute(e, t, r, s, o, u) {
        return Jm.setScalar(0),
        eg.setScalar(0),
        tg.setScalar(0),
        Jm.fromBufferAttribute(e, t),
        eg.fromBufferAttribute(e, r),
        tg.fromBufferAttribute(e, s),
        u.setScalar(0),
        u.addScaledVector(Jm, o.x),
        u.addScaledVector(eg, o.y),
        u.addScaledVector(tg, o.z),
        u
    }
    static isFrontFacing(e, t, r, s) {
        return pr.subVectors(r, t),
        sa.subVectors(e, t),
        pr.cross(sa).dot(s) < 0
    }
    set(e, t, r) {
        return this.a.copy(e),
        this.b.copy(t),
        this.c.copy(r),
        this
    }
    setFromPointsAndIndices(e, t, r, s) {
        return this.a.copy(e[t]),
        this.b.copy(e[r]),
        this.c.copy(e[s]),
        this
    }
    setFromAttributeAndIndices(e, t, r, s) {
        return this.a.fromBufferAttribute(e, t),
        this.b.fromBufferAttribute(e, r),
        this.c.fromBufferAttribute(e, s),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.a.copy(e.a),
        this.b.copy(e.b),
        this.c.copy(e.c),
        this
    }
    getArea() {
        return pr.subVectors(this.c, this.b),
        sa.subVectors(this.a, this.b),
        pr.cross(sa).length() * .5
    }
    getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(e) {
        return gr.getNormal(this.a, this.b, this.c, e)
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(e, t) {
        return gr.getBarycoord(e, this.a, this.b, this.c, t)
    }
    getInterpolation(e, t, r, s, o) {
        return gr.getInterpolation(e, this.a, this.b, this.c, t, r, s, o)
    }
    containsPoint(e) {
        return gr.containsPoint(e, this.a, this.b, this.c)
    }
    isFrontFacing(e) {
        return gr.isFrontFacing(this.a, this.b, this.c, e)
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this)
    }
    closestPointToPoint(e, t) {
        const r = this.a
          , s = this.b
          , o = this.c;
        let u, d;
        Zo.subVectors(s, r),
        $o.subVectors(o, r),
        $m.subVectors(e, r);
        const f = Zo.dot($m)
          , h = $o.dot($m);
        if (f <= 0 && h <= 0)
            return t.copy(r);
        Km.subVectors(e, s);
        const m = Zo.dot(Km)
          , g = $o.dot(Km);
        if (m >= 0 && g <= m)
            return t.copy(s);
        const _ = f * g - m * h;
        if (_ <= 0 && f >= 0 && m <= 0)
            return u = f / (f - m),
            t.copy(r).addScaledVector(Zo, u);
        Qm.subVectors(e, o);
        const x = Zo.dot(Qm)
          , E = $o.dot(Qm);
        if (E >= 0 && x <= E)
            return t.copy(o);
        const M = x * h - f * E;
        if (M <= 0 && h >= 0 && E <= 0)
            return d = h / (h - E),
            t.copy(r).addScaledVector($o, d);
        const b = m * E - x * g;
        if (b <= 0 && g - m >= 0 && x - E >= 0)
            return pS.subVectors(o, s),
            d = (g - m) / (g - m + (x - E)),
            t.copy(s).addScaledVector(pS, d);
        const y = 1 / (b + M + _);
        return u = M * y,
        d = _ * y,
        t.copy(r).addScaledVector(Zo, u).addScaledVector($o, d)
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
}
const ew = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}
  , is = {
    h: 0,
    s: 0,
    l: 0
}
  , Hd = {
    h: 0,
    s: 0,
    l: 0
};
function ng(n, e, t) {
    return t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * 6 * (2 / 3 - t) : n
}
class pn {
    constructor(e, t, r) {
        return this.isColor = !0,
        this.r = 1,
        this.g = 1,
        this.b = 1,
        this.set(e, t, r)
    }
    set(e, t, r) {
        if (t === void 0 && r === void 0) {
            const s = e;
            s && s.isColor ? this.copy(s) : typeof s == "number" ? this.setHex(s) : typeof s == "string" && this.setStyle(s)
        } else
            this.setRGB(e, t, r);
        return this
    }
    setScalar(e) {
        return this.r = e,
        this.g = e,
        this.b = e,
        this
    }
    setHex(e, t=Xi) {
        return e = Math.floor(e),
        this.r = (e >> 16 & 255) / 255,
        this.g = (e >> 8 & 255) / 255,
        this.b = (e & 255) / 255,
        fn.toWorkingColorSpace(this, t),
        this
    }
    setRGB(e, t, r, s=fn.workingColorSpace) {
        return this.r = e,
        this.g = t,
        this.b = r,
        fn.toWorkingColorSpace(this, s),
        this
    }
    setHSL(e, t, r, s=fn.workingColorSpace) {
        if (e = XU(e, 1),
        t = sn(t, 0, 1),
        r = sn(r, 0, 1),
        t === 0)
            this.r = this.g = this.b = r;
        else {
            const o = r <= .5 ? r * (1 + t) : r + t - r * t
              , u = 2 * r - o;
            this.r = ng(u, o, e + 1 / 3),
            this.g = ng(u, o, e),
            this.b = ng(u, o, e - 1 / 3)
        }
        return fn.toWorkingColorSpace(this, s),
        this
    }
    setStyle(e, t=Xi) {
        function r(o) {
            o !== void 0 && parseFloat(o) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
        }
        let s;
        if (s = /^(\w+)\(([^\)]*)\)/.exec(e)) {
            let o;
            const u = s[1]
              , d = s[2];
            switch (u) {
            case "rgb":
            case "rgba":
                if (o = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(d))
                    return r(o[4]),
                    this.setRGB(Math.min(255, parseInt(o[1], 10)) / 255, Math.min(255, parseInt(o[2], 10)) / 255, Math.min(255, parseInt(o[3], 10)) / 255, t);
                if (o = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(d))
                    return r(o[4]),
                    this.setRGB(Math.min(100, parseInt(o[1], 10)) / 100, Math.min(100, parseInt(o[2], 10)) / 100, Math.min(100, parseInt(o[3], 10)) / 100, t);
                break;
            case "hsl":
            case "hsla":
                if (o = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(d))
                    return r(o[4]),
                    this.setHSL(parseFloat(o[1]) / 360, parseFloat(o[2]) / 100, parseFloat(o[3]) / 100, t);
                break;
            default:
                console.warn("THREE.Color: Unknown color model " + e)
            }
        } else if (s = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const o = s[1]
              , u = o.length;
            if (u === 3)
                return this.setRGB(parseInt(o.charAt(0), 16) / 15, parseInt(o.charAt(1), 16) / 15, parseInt(o.charAt(2), 16) / 15, t);
            if (u === 6)
                return this.setHex(parseInt(o, 16), t);
            console.warn("THREE.Color: Invalid hex color " + e)
        } else if (e && e.length > 0)
            return this.setColorName(e, t);
        return this
    }
    setColorName(e, t=Xi) {
        const r = ew[e.toLowerCase()];
        return r !== void 0 ? this.setHex(r, t) : console.warn("THREE.Color: Unknown color " + e),
        this
    }
    clone() {
        return new this.constructor(this.r,this.g,this.b)
    }
    copy(e) {
        return this.r = e.r,
        this.g = e.g,
        this.b = e.b,
        this
    }
    copySRGBToLinear(e) {
        return this.r = Ea(e.r),
        this.g = Ea(e.g),
        this.b = Ea(e.b),
        this
    }
    copyLinearToSRGB(e) {
        return this.r = dl(e.r),
        this.g = dl(e.g),
        this.b = dl(e.b),
        this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this),
        this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this),
        this
    }
    getHex(e=Xi) {
        return fn.fromWorkingColorSpace(_i.copy(this), e),
        Math.round(sn(_i.r * 255, 0, 255)) * 65536 + Math.round(sn(_i.g * 255, 0, 255)) * 256 + Math.round(sn(_i.b * 255, 0, 255))
    }
    getHexString(e=Xi) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6)
    }
    getHSL(e, t=fn.workingColorSpace) {
        fn.fromWorkingColorSpace(_i.copy(this), t);
        const r = _i.r
          , s = _i.g
          , o = _i.b
          , u = Math.max(r, s, o)
          , d = Math.min(r, s, o);
        let f, h;
        const m = (d + u) / 2;
        if (d === u)
            f = 0,
            h = 0;
        else {
            const g = u - d;
            switch (h = m <= .5 ? g / (u + d) : g / (2 - u - d),
            u) {
            case r:
                f = (s - o) / g + (s < o ? 6 : 0);
                break;
            case s:
                f = (o - r) / g + 2;
                break;
            case o:
                f = (r - s) / g + 4;
                break
            }
            f /= 6
        }
        return e.h = f,
        e.s = h,
        e.l = m,
        e
    }
    getRGB(e, t=fn.workingColorSpace) {
        return fn.fromWorkingColorSpace(_i.copy(this), t),
        e.r = _i.r,
        e.g = _i.g,
        e.b = _i.b,
        e
    }
    getStyle(e=Xi) {
        fn.fromWorkingColorSpace(_i.copy(this), e);
        const t = _i.r
          , r = _i.g
          , s = _i.b;
        return e !== Xi ? `color(${e} ${t.toFixed(3)} ${r.toFixed(3)} ${s.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(r * 255)},${Math.round(s * 255)})`
    }
    offsetHSL(e, t, r) {
        return this.getHSL(is),
        this.setHSL(is.h + e, is.s + t, is.l + r)
    }
    add(e) {
        return this.r += e.r,
        this.g += e.g,
        this.b += e.b,
        this
    }
    addColors(e, t) {
        return this.r = e.r + t.r,
        this.g = e.g + t.g,
        this.b = e.b + t.b,
        this
    }
    addScalar(e) {
        return this.r += e,
        this.g += e,
        this.b += e,
        this
    }
    sub(e) {
        return this.r = Math.max(0, this.r - e.r),
        this.g = Math.max(0, this.g - e.g),
        this.b = Math.max(0, this.b - e.b),
        this
    }
    multiply(e) {
        return this.r *= e.r,
        this.g *= e.g,
        this.b *= e.b,
        this
    }
    multiplyScalar(e) {
        return this.r *= e,
        this.g *= e,
        this.b *= e,
        this
    }
    lerp(e, t) {
        return this.r += (e.r - this.r) * t,
        this.g += (e.g - this.g) * t,
        this.b += (e.b - this.b) * t,
        this
    }
    lerpColors(e, t, r) {
        return this.r = e.r + (t.r - e.r) * r,
        this.g = e.g + (t.g - e.g) * r,
        this.b = e.b + (t.b - e.b) * r,
        this
    }
    lerpHSL(e, t) {
        this.getHSL(is),
        e.getHSL(Hd);
        const r = Fm(is.h, Hd.h, t)
          , s = Fm(is.s, Hd.s, t)
          , o = Fm(is.l, Hd.l, t);
        return this.setHSL(r, s, o),
        this
    }
    setFromVector3(e) {
        return this.r = e.x,
        this.g = e.y,
        this.b = e.z,
        this
    }
    applyMatrix3(e) {
        const t = this.r
          , r = this.g
          , s = this.b
          , o = e.elements;
        return this.r = o[0] * t + o[3] * r + o[6] * s,
        this.g = o[1] * t + o[4] * r + o[7] * s,
        this.b = o[2] * t + o[5] * r + o[8] * s,
        this
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b
    }
    fromArray(e, t=0) {
        return this.r = e[t],
        this.g = e[t + 1],
        this.b = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.r,
        e[t + 1] = this.g,
        e[t + 2] = this.b,
        e
    }
    fromBufferAttribute(e, t) {
        return this.r = e.getX(t),
        this.g = e.getY(t),
        this.b = e.getZ(t),
        this
    }
    toJSON() {
        return this.getHex()
    }
    *[Symbol.iterator]() {
        yield this.r,
        yield this.g,
        yield this.b
    }
}
const _i = new pn;
pn.NAMES = ew;
let uL = 0;
class vu extends wl {
    constructor() {
        super(),
        this.isMaterial = !0,
        Object.defineProperty(this, "id", {
            value: uL++
        }),
        this.uuid = pu(),
        this.name = "",
        this.type = "Material",
        this.blending = ul,
        this.side = _s,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.alphaHash = !1,
        this.blendSrc = zg,
        this.blendDst = kg,
        this.blendEquation = Ys,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.blendColor = new pn(0,0,0),
        this.blendAlpha = 0,
        this.depthFunc = pl,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = eS,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = Vo,
        this.stencilZFail = Vo,
        this.stencilZPass = Vo,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaToCoverage = !1,
        this.premultipliedAlpha = !1,
        this.forceSinglePass = !1,
        this.allowOverride = !0,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0,
        this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++,
        this._alphaTest = e
    }
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues(e) {
        if (e !== void 0)
            for (const t in e) {
                const r = e[t];
                if (r === void 0) {
                    console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                    continue
                }
                const s = this[t];
                if (s === void 0) {
                    console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
                    continue
                }
                s && s.isColor ? s.set(r) : s && s.isVector3 && r && r.isVector3 ? s.copy(r) : this[t] = r
            }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        t && (e = {
            textures: {},
            images: {}
        });
        const r = {
            metadata: {
                version: 4.6,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        r.uuid = this.uuid,
        r.type = this.type,
        this.name !== "" && (r.name = this.name),
        this.color && this.color.isColor && (r.color = this.color.getHex()),
        this.roughness !== void 0 && (r.roughness = this.roughness),
        this.metalness !== void 0 && (r.metalness = this.metalness),
        this.sheen !== void 0 && (r.sheen = this.sheen),
        this.sheenColor && this.sheenColor.isColor && (r.sheenColor = this.sheenColor.getHex()),
        this.sheenRoughness !== void 0 && (r.sheenRoughness = this.sheenRoughness),
        this.emissive && this.emissive.isColor && (r.emissive = this.emissive.getHex()),
        this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (r.emissiveIntensity = this.emissiveIntensity),
        this.specular && this.specular.isColor && (r.specular = this.specular.getHex()),
        this.specularIntensity !== void 0 && (r.specularIntensity = this.specularIntensity),
        this.specularColor && this.specularColor.isColor && (r.specularColor = this.specularColor.getHex()),
        this.shininess !== void 0 && (r.shininess = this.shininess),
        this.clearcoat !== void 0 && (r.clearcoat = this.clearcoat),
        this.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap && this.clearcoatMap.isTexture && (r.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (r.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (r.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
        r.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
        this.dispersion !== void 0 && (r.dispersion = this.dispersion),
        this.iridescence !== void 0 && (r.iridescence = this.iridescence),
        this.iridescenceIOR !== void 0 && (r.iridescenceIOR = this.iridescenceIOR),
        this.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap && this.iridescenceMap.isTexture && (r.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
        this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (r.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
        this.anisotropy !== void 0 && (r.anisotropy = this.anisotropy),
        this.anisotropyRotation !== void 0 && (r.anisotropyRotation = this.anisotropyRotation),
        this.anisotropyMap && this.anisotropyMap.isTexture && (r.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
        this.map && this.map.isTexture && (r.map = this.map.toJSON(e).uuid),
        this.matcap && this.matcap.isTexture && (r.matcap = this.matcap.toJSON(e).uuid),
        this.alphaMap && this.alphaMap.isTexture && (r.alphaMap = this.alphaMap.toJSON(e).uuid),
        this.lightMap && this.lightMap.isTexture && (r.lightMap = this.lightMap.toJSON(e).uuid,
        r.lightMapIntensity = this.lightMapIntensity),
        this.aoMap && this.aoMap.isTexture && (r.aoMap = this.aoMap.toJSON(e).uuid,
        r.aoMapIntensity = this.aoMapIntensity),
        this.bumpMap && this.bumpMap.isTexture && (r.bumpMap = this.bumpMap.toJSON(e).uuid,
        r.bumpScale = this.bumpScale),
        this.normalMap && this.normalMap.isTexture && (r.normalMap = this.normalMap.toJSON(e).uuid,
        r.normalMapType = this.normalMapType,
        r.normalScale = this.normalScale.toArray()),
        this.displacementMap && this.displacementMap.isTexture && (r.displacementMap = this.displacementMap.toJSON(e).uuid,
        r.displacementScale = this.displacementScale,
        r.displacementBias = this.displacementBias),
        this.roughnessMap && this.roughnessMap.isTexture && (r.roughnessMap = this.roughnessMap.toJSON(e).uuid),
        this.metalnessMap && this.metalnessMap.isTexture && (r.metalnessMap = this.metalnessMap.toJSON(e).uuid),
        this.emissiveMap && this.emissiveMap.isTexture && (r.emissiveMap = this.emissiveMap.toJSON(e).uuid),
        this.specularMap && this.specularMap.isTexture && (r.specularMap = this.specularMap.toJSON(e).uuid),
        this.specularIntensityMap && this.specularIntensityMap.isTexture && (r.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
        this.specularColorMap && this.specularColorMap.isTexture && (r.specularColorMap = this.specularColorMap.toJSON(e).uuid),
        this.envMap && this.envMap.isTexture && (r.envMap = this.envMap.toJSON(e).uuid,
        this.combine !== void 0 && (r.combine = this.combine)),
        this.envMapRotation !== void 0 && (r.envMapRotation = this.envMapRotation.toArray()),
        this.envMapIntensity !== void 0 && (r.envMapIntensity = this.envMapIntensity),
        this.reflectivity !== void 0 && (r.reflectivity = this.reflectivity),
        this.refractionRatio !== void 0 && (r.refractionRatio = this.refractionRatio),
        this.gradientMap && this.gradientMap.isTexture && (r.gradientMap = this.gradientMap.toJSON(e).uuid),
        this.transmission !== void 0 && (r.transmission = this.transmission),
        this.transmissionMap && this.transmissionMap.isTexture && (r.transmissionMap = this.transmissionMap.toJSON(e).uuid),
        this.thickness !== void 0 && (r.thickness = this.thickness),
        this.thicknessMap && this.thicknessMap.isTexture && (r.thicknessMap = this.thicknessMap.toJSON(e).uuid),
        this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (r.attenuationDistance = this.attenuationDistance),
        this.attenuationColor !== void 0 && (r.attenuationColor = this.attenuationColor.getHex()),
        this.size !== void 0 && (r.size = this.size),
        this.shadowSide !== null && (r.shadowSide = this.shadowSide),
        this.sizeAttenuation !== void 0 && (r.sizeAttenuation = this.sizeAttenuation),
        this.blending !== ul && (r.blending = this.blending),
        this.side !== _s && (r.side = this.side),
        this.vertexColors === !0 && (r.vertexColors = !0),
        this.opacity < 1 && (r.opacity = this.opacity),
        this.transparent === !0 && (r.transparent = !0),
        this.blendSrc !== zg && (r.blendSrc = this.blendSrc),
        this.blendDst !== kg && (r.blendDst = this.blendDst),
        this.blendEquation !== Ys && (r.blendEquation = this.blendEquation),
        this.blendSrcAlpha !== null && (r.blendSrcAlpha = this.blendSrcAlpha),
        this.blendDstAlpha !== null && (r.blendDstAlpha = this.blendDstAlpha),
        this.blendEquationAlpha !== null && (r.blendEquationAlpha = this.blendEquationAlpha),
        this.blendColor && this.blendColor.isColor && (r.blendColor = this.blendColor.getHex()),
        this.blendAlpha !== 0 && (r.blendAlpha = this.blendAlpha),
        this.depthFunc !== pl && (r.depthFunc = this.depthFunc),
        this.depthTest === !1 && (r.depthTest = this.depthTest),
        this.depthWrite === !1 && (r.depthWrite = this.depthWrite),
        this.colorWrite === !1 && (r.colorWrite = this.colorWrite),
        this.stencilWriteMask !== 255 && (r.stencilWriteMask = this.stencilWriteMask),
        this.stencilFunc !== eS && (r.stencilFunc = this.stencilFunc),
        this.stencilRef !== 0 && (r.stencilRef = this.stencilRef),
        this.stencilFuncMask !== 255 && (r.stencilFuncMask = this.stencilFuncMask),
        this.stencilFail !== Vo && (r.stencilFail = this.stencilFail),
        this.stencilZFail !== Vo && (r.stencilZFail = this.stencilZFail),
        this.stencilZPass !== Vo && (r.stencilZPass = this.stencilZPass),
        this.stencilWrite === !0 && (r.stencilWrite = this.stencilWrite),
        this.rotation !== void 0 && this.rotation !== 0 && (r.rotation = this.rotation),
        this.polygonOffset === !0 && (r.polygonOffset = !0),
        this.polygonOffsetFactor !== 0 && (r.polygonOffsetFactor = this.polygonOffsetFactor),
        this.polygonOffsetUnits !== 0 && (r.polygonOffsetUnits = this.polygonOffsetUnits),
        this.linewidth !== void 0 && this.linewidth !== 1 && (r.linewidth = this.linewidth),
        this.dashSize !== void 0 && (r.dashSize = this.dashSize),
        this.gapSize !== void 0 && (r.gapSize = this.gapSize),
        this.scale !== void 0 && (r.scale = this.scale),
        this.dithering === !0 && (r.dithering = !0),
        this.alphaTest > 0 && (r.alphaTest = this.alphaTest),
        this.alphaHash === !0 && (r.alphaHash = !0),
        this.alphaToCoverage === !0 && (r.alphaToCoverage = !0),
        this.premultipliedAlpha === !0 && (r.premultipliedAlpha = !0),
        this.forceSinglePass === !0 && (r.forceSinglePass = !0),
        this.wireframe === !0 && (r.wireframe = !0),
        this.wireframeLinewidth > 1 && (r.wireframeLinewidth = this.wireframeLinewidth),
        this.wireframeLinecap !== "round" && (r.wireframeLinecap = this.wireframeLinecap),
        this.wireframeLinejoin !== "round" && (r.wireframeLinejoin = this.wireframeLinejoin),
        this.flatShading === !0 && (r.flatShading = !0),
        this.visible === !1 && (r.visible = !1),
        this.toneMapped === !1 && (r.toneMapped = !1),
        this.fog === !1 && (r.fog = !1),
        Object.keys(this.userData).length > 0 && (r.userData = this.userData);
        function s(o) {
            const u = [];
            for (const d in o) {
                const f = o[d];
                delete f.metadata,
                u.push(f)
            }
            return u
        }
        if (t) {
            const o = s(e.textures)
              , u = s(e.images);
            o.length > 0 && (r.textures = o),
            u.length > 0 && (r.images = u)
        }
        return r
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.name = e.name,
        this.blending = e.blending,
        this.side = e.side,
        this.vertexColors = e.vertexColors,
        this.opacity = e.opacity,
        this.transparent = e.transparent,
        this.blendSrc = e.blendSrc,
        this.blendDst = e.blendDst,
        this.blendEquation = e.blendEquation,
        this.blendSrcAlpha = e.blendSrcAlpha,
        this.blendDstAlpha = e.blendDstAlpha,
        this.blendEquationAlpha = e.blendEquationAlpha,
        this.blendColor.copy(e.blendColor),
        this.blendAlpha = e.blendAlpha,
        this.depthFunc = e.depthFunc,
        this.depthTest = e.depthTest,
        this.depthWrite = e.depthWrite,
        this.stencilWriteMask = e.stencilWriteMask,
        this.stencilFunc = e.stencilFunc,
        this.stencilRef = e.stencilRef,
        this.stencilFuncMask = e.stencilFuncMask,
        this.stencilFail = e.stencilFail,
        this.stencilZFail = e.stencilZFail,
        this.stencilZPass = e.stencilZPass,
        this.stencilWrite = e.stencilWrite;
        const t = e.clippingPlanes;
        let r = null;
        if (t !== null) {
            const s = t.length;
            r = new Array(s);
            for (let o = 0; o !== s; ++o)
                r[o] = t[o].clone()
        }
        return this.clippingPlanes = r,
        this.clipIntersection = e.clipIntersection,
        this.clipShadows = e.clipShadows,
        this.shadowSide = e.shadowSide,
        this.colorWrite = e.colorWrite,
        this.precision = e.precision,
        this.polygonOffset = e.polygonOffset,
        this.polygonOffsetFactor = e.polygonOffsetFactor,
        this.polygonOffsetUnits = e.polygonOffsetUnits,
        this.dithering = e.dithering,
        this.alphaTest = e.alphaTest,
        this.alphaHash = e.alphaHash,
        this.alphaToCoverage = e.alphaToCoverage,
        this.premultipliedAlpha = e.premultipliedAlpha,
        this.forceSinglePass = e.forceSinglePass,
        this.visible = e.visible,
        this.toneMapped = e.toneMapped,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    onBuild() {
        console.warn("Material: onBuild() has been removed.")
    }
}
class tw extends vu {
    constructor(e) {
        super(),
        this.isMeshBasicMaterial = !0,
        this.type = "MeshBasicMaterial",
        this.color = new pn(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new Aa,
        this.combine = zM,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
const jn = new Ee
  , Gd = new _n;
let dL = 0;
class ar {
    constructor(e, t, r=!1) {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0,
        Object.defineProperty(this, "id", {
            value: dL++
        }),
        this.name = "",
        this.array = e,
        this.itemSize = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.normalized = r,
        this.usage = tS,
        this.updateRanges = [],
        this.gpuType = ya,
        this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.name = e.name,
        this.array = new e.array.constructor(e.array),
        this.itemSize = e.itemSize,
        this.count = e.count,
        this.normalized = e.normalized,
        this.usage = e.usage,
        this.gpuType = e.gpuType,
        this
    }
    copyAt(e, t, r) {
        e *= this.itemSize,
        r *= t.itemSize;
        for (let s = 0, o = this.itemSize; s < o; s++)
            this.array[e + s] = t.array[r + s];
        return this
    }
    copyArray(e) {
        return this.array.set(e),
        this
    }
    applyMatrix3(e) {
        if (this.itemSize === 2)
            for (let t = 0, r = this.count; t < r; t++)
                Gd.fromBufferAttribute(this, t),
                Gd.applyMatrix3(e),
                this.setXY(t, Gd.x, Gd.y);
        else if (this.itemSize === 3)
            for (let t = 0, r = this.count; t < r; t++)
                jn.fromBufferAttribute(this, t),
                jn.applyMatrix3(e),
                this.setXYZ(t, jn.x, jn.y, jn.z);
        return this
    }
    applyMatrix4(e) {
        for (let t = 0, r = this.count; t < r; t++)
            jn.fromBufferAttribute(this, t),
            jn.applyMatrix4(e),
            this.setXYZ(t, jn.x, jn.y, jn.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, r = this.count; t < r; t++)
            jn.fromBufferAttribute(this, t),
            jn.applyNormalMatrix(e),
            this.setXYZ(t, jn.x, jn.y, jn.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, r = this.count; t < r; t++)
            jn.fromBufferAttribute(this, t),
            jn.transformDirection(e),
            this.setXYZ(t, jn.x, jn.y, jn.z);
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    getComponent(e, t) {
        let r = this.array[e * this.itemSize + t];
        return this.normalized && (r = Rc(r, this.array)),
        r
    }
    setComponent(e, t, r) {
        return this.normalized && (r = Ui(r, this.array)),
        this.array[e * this.itemSize + t] = r,
        this
    }
    getX(e) {
        let t = this.array[e * this.itemSize];
        return this.normalized && (t = Rc(t, this.array)),
        t
    }
    setX(e, t) {
        return this.normalized && (t = Ui(t, this.array)),
        this.array[e * this.itemSize] = t,
        this
    }
    getY(e) {
        let t = this.array[e * this.itemSize + 1];
        return this.normalized && (t = Rc(t, this.array)),
        t
    }
    setY(e, t) {
        return this.normalized && (t = Ui(t, this.array)),
        this.array[e * this.itemSize + 1] = t,
        this
    }
    getZ(e) {
        let t = this.array[e * this.itemSize + 2];
        return this.normalized && (t = Rc(t, this.array)),
        t
    }
    setZ(e, t) {
        return this.normalized && (t = Ui(t, this.array)),
        this.array[e * this.itemSize + 2] = t,
        this
    }
    getW(e) {
        let t = this.array[e * this.itemSize + 3];
        return this.normalized && (t = Rc(t, this.array)),
        t
    }
    setW(e, t) {
        return this.normalized && (t = Ui(t, this.array)),
        this.array[e * this.itemSize + 3] = t,
        this
    }
    setXY(e, t, r) {
        return e *= this.itemSize,
        this.normalized && (t = Ui(t, this.array),
        r = Ui(r, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = r,
        this
    }
    setXYZ(e, t, r, s) {
        return e *= this.itemSize,
        this.normalized && (t = Ui(t, this.array),
        r = Ui(r, this.array),
        s = Ui(s, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = r,
        this.array[e + 2] = s,
        this
    }
    setXYZW(e, t, r, s, o) {
        return e *= this.itemSize,
        this.normalized && (t = Ui(t, this.array),
        r = Ui(r, this.array),
        s = Ui(s, this.array),
        o = Ui(o, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = r,
        this.array[e + 2] = s,
        this.array[e + 3] = o,
        this
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    clone() {
        return new this.constructor(this.array,this.itemSize).copy(this)
    }
    toJSON() {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (e.name = this.name),
        this.usage !== tS && (e.usage = this.usage),
        e
    }
}
class nw extends ar {
    constructor(e, t, r) {
        super(new Uint16Array(e), t, r)
    }
}
class iw extends ar {
    constructor(e, t, r) {
        super(new Uint32Array(e), t, r)
    }
}
class eo extends ar {
    constructor(e, t, r) {
        super(new Float32Array(e), t, r)
    }
}
let fL = 0;
const tr = new Ln
  , ig = new fi
  , Ko = new Ee
  , Gi = new gu
  , Lc = new gu
  , ai = new Ee;
class Ir extends wl {
    constructor() {
        super(),
        this.isBufferGeometry = !0,
        Object.defineProperty(this, "id", {
            value: fL++
        }),
        this.uuid = pu(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.indirect = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(e) {
        return Array.isArray(e) ? this.index = new ($M(e) ? iw : nw)(e,1) : this.index = e,
        this
    }
    setIndirect(e) {
        return this.indirect = e,
        this
    }
    getIndirect() {
        return this.indirect
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    setAttribute(e, t) {
        return this.attributes[e] = t,
        this
    }
    deleteAttribute(e) {
        return delete this.attributes[e],
        this
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0
    }
    addGroup(e, t, r=0) {
        this.groups.push({
            start: e,
            count: t,
            materialIndex: r
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(e, t) {
        this.drawRange.start = e,
        this.drawRange.count = t
    }
    applyMatrix4(e) {
        const t = this.attributes.position;
        t !== void 0 && (t.applyMatrix4(e),
        t.needsUpdate = !0);
        const r = this.attributes.normal;
        if (r !== void 0) {
            const o = new Vt().getNormalMatrix(e);
            r.applyNormalMatrix(o),
            r.needsUpdate = !0
        }
        const s = this.attributes.tangent;
        return s !== void 0 && (s.transformDirection(e),
        s.needsUpdate = !0),
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        this
    }
    applyQuaternion(e) {
        return tr.makeRotationFromQuaternion(e),
        this.applyMatrix4(tr),
        this
    }
    rotateX(e) {
        return tr.makeRotationX(e),
        this.applyMatrix4(tr),
        this
    }
    rotateY(e) {
        return tr.makeRotationY(e),
        this.applyMatrix4(tr),
        this
    }
    rotateZ(e) {
        return tr.makeRotationZ(e),
        this.applyMatrix4(tr),
        this
    }
    translate(e, t, r) {
        return tr.makeTranslation(e, t, r),
        this.applyMatrix4(tr),
        this
    }
    scale(e, t, r) {
        return tr.makeScale(e, t, r),
        this.applyMatrix4(tr),
        this
    }
    lookAt(e) {
        return ig.lookAt(e),
        ig.updateMatrix(),
        this.applyMatrix4(ig.matrix),
        this
    }
    center() {
        return this.computeBoundingBox(),
        this.boundingBox.getCenter(Ko).negate(),
        this.translate(Ko.x, Ko.y, Ko.z),
        this
    }
    setFromPoints(e) {
        const t = this.getAttribute("position");
        if (t === void 0) {
            const r = [];
            for (let s = 0, o = e.length; s < o; s++) {
                const u = e[s];
                r.push(u.x, u.y, u.z || 0)
            }
            this.setAttribute("position", new eo(r,3))
        } else {
            const r = Math.min(e.length, t.count);
            for (let s = 0; s < r; s++) {
                const o = e[s];
                t.setXYZ(s, o.x, o.y, o.z || 0)
            }
            e.length > t.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),
            t.needsUpdate = !0
        }
        return this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new gu);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this),
            this.boundingBox.set(new Ee(-1 / 0,-1 / 0,-1 / 0), new Ee(1 / 0,1 / 0,1 / 0));
            return
        }
        if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e),
            t)
                for (let r = 0, s = t.length; r < s; r++) {
                    const o = t[r];
                    Gi.setFromBufferAttribute(o),
                    this.morphTargetsRelative ? (ai.addVectors(this.boundingBox.min, Gi.min),
                    this.boundingBox.expandByPoint(ai),
                    ai.addVectors(this.boundingBox.max, Gi.max),
                    this.boundingBox.expandByPoint(ai)) : (this.boundingBox.expandByPoint(Gi.min),
                    this.boundingBox.expandByPoint(Gi.max))
                }
        } else
            this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new ih);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this),
            this.boundingSphere.set(new Ee, 1 / 0);
            return
        }
        if (e) {
            const r = this.boundingSphere.center;
            if (Gi.setFromBufferAttribute(e),
            t)
                for (let o = 0, u = t.length; o < u; o++) {
                    const d = t[o];
                    Lc.setFromBufferAttribute(d),
                    this.morphTargetsRelative ? (ai.addVectors(Gi.min, Lc.min),
                    Gi.expandByPoint(ai),
                    ai.addVectors(Gi.max, Lc.max),
                    Gi.expandByPoint(ai)) : (Gi.expandByPoint(Lc.min),
                    Gi.expandByPoint(Lc.max))
                }
            Gi.getCenter(r);
            let s = 0;
            for (let o = 0, u = e.count; o < u; o++)
                ai.fromBufferAttribute(e, o),
                s = Math.max(s, r.distanceToSquared(ai));
            if (t)
                for (let o = 0, u = t.length; o < u; o++) {
                    const d = t[o]
                      , f = this.morphTargetsRelative;
                    for (let h = 0, m = d.count; h < m; h++)
                        ai.fromBufferAttribute(d, h),
                        f && (Ko.fromBufferAttribute(e, h),
                        ai.add(Ko)),
                        s = Math.max(s, r.distanceToSquared(ai))
                }
            this.boundingSphere.radius = Math.sqrt(s),
            isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const e = this.index
          , t = this.attributes;
        if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const r = t.position
          , s = t.normal
          , o = t.uv;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new ar(new Float32Array(4 * r.count),4));
        const u = this.getAttribute("tangent")
          , d = []
          , f = [];
        for (let z = 0; z < r.count; z++)
            d[z] = new Ee,
            f[z] = new Ee;
        const h = new Ee
          , m = new Ee
          , g = new Ee
          , _ = new _n
          , x = new _n
          , E = new _n
          , M = new Ee
          , b = new Ee;
        function y(z, U, R) {
            h.fromBufferAttribute(r, z),
            m.fromBufferAttribute(r, U),
            g.fromBufferAttribute(r, R),
            _.fromBufferAttribute(o, z),
            x.fromBufferAttribute(o, U),
            E.fromBufferAttribute(o, R),
            m.sub(h),
            g.sub(h),
            x.sub(_),
            E.sub(_);
            const V = 1 / (x.x * E.y - E.x * x.y);
            isFinite(V) && (M.copy(m).multiplyScalar(E.y).addScaledVector(g, -x.y).multiplyScalar(V),
            b.copy(g).multiplyScalar(x.x).addScaledVector(m, -E.x).multiplyScalar(V),
            d[z].add(M),
            d[U].add(M),
            d[R].add(M),
            f[z].add(b),
            f[U].add(b),
            f[R].add(b))
        }
        let T = this.groups;
        T.length === 0 && (T = [{
            start: 0,
            count: e.count
        }]);
        for (let z = 0, U = T.length; z < U; ++z) {
            const R = T[z]
              , V = R.start
              , Q = R.count;
            for (let X = V, oe = V + Q; X < oe; X += 3)
                y(e.getX(X + 0), e.getX(X + 1), e.getX(X + 2))
        }
        const D = new Ee
          , C = new Ee
          , P = new Ee
          , A = new Ee;
        function F(z) {
            P.fromBufferAttribute(s, z),
            A.copy(P);
            const U = d[z];
            D.copy(U),
            D.sub(P.multiplyScalar(P.dot(U))).normalize(),
            C.crossVectors(A, U);
            const V = C.dot(f[z]) < 0 ? -1 : 1;
            u.setXYZW(z, D.x, D.y, D.z, V)
        }
        for (let z = 0, U = T.length; z < U; ++z) {
            const R = T[z]
              , V = R.start
              , Q = R.count;
            for (let X = V, oe = V + Q; X < oe; X += 3)
                F(e.getX(X + 0)),
                F(e.getX(X + 1)),
                F(e.getX(X + 2))
        }
    }
    computeVertexNormals() {
        const e = this.index
          , t = this.getAttribute("position");
        if (t !== void 0) {
            let r = this.getAttribute("normal");
            if (r === void 0)
                r = new ar(new Float32Array(t.count * 3),3),
                this.setAttribute("normal", r);
            else
                for (let _ = 0, x = r.count; _ < x; _++)
                    r.setXYZ(_, 0, 0, 0);
            const s = new Ee
              , o = new Ee
              , u = new Ee
              , d = new Ee
              , f = new Ee
              , h = new Ee
              , m = new Ee
              , g = new Ee;
            if (e)
                for (let _ = 0, x = e.count; _ < x; _ += 3) {
                    const E = e.getX(_ + 0)
                      , M = e.getX(_ + 1)
                      , b = e.getX(_ + 2);
                    s.fromBufferAttribute(t, E),
                    o.fromBufferAttribute(t, M),
                    u.fromBufferAttribute(t, b),
                    m.subVectors(u, o),
                    g.subVectors(s, o),
                    m.cross(g),
                    d.fromBufferAttribute(r, E),
                    f.fromBufferAttribute(r, M),
                    h.fromBufferAttribute(r, b),
                    d.add(m),
                    f.add(m),
                    h.add(m),
                    r.setXYZ(E, d.x, d.y, d.z),
                    r.setXYZ(M, f.x, f.y, f.z),
                    r.setXYZ(b, h.x, h.y, h.z)
                }
            else
                for (let _ = 0, x = t.count; _ < x; _ += 3)
                    s.fromBufferAttribute(t, _ + 0),
                    o.fromBufferAttribute(t, _ + 1),
                    u.fromBufferAttribute(t, _ + 2),
                    m.subVectors(u, o),
                    g.subVectors(s, o),
                    m.cross(g),
                    r.setXYZ(_ + 0, m.x, m.y, m.z),
                    r.setXYZ(_ + 1, m.x, m.y, m.z),
                    r.setXYZ(_ + 2, m.x, m.y, m.z);
            this.normalizeNormals(),
            r.needsUpdate = !0
        }
    }
    normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, r = e.count; t < r; t++)
            ai.fromBufferAttribute(e, t),
            ai.normalize(),
            e.setXYZ(t, ai.x, ai.y, ai.z)
    }
    toNonIndexed() {
        function e(d, f) {
            const h = d.array
              , m = d.itemSize
              , g = d.normalized
              , _ = new h.constructor(f.length * m);
            let x = 0
              , E = 0;
            for (let M = 0, b = f.length; M < b; M++) {
                d.isInterleavedBufferAttribute ? x = f[M] * d.data.stride + d.offset : x = f[M] * m;
                for (let y = 0; y < m; y++)
                    _[E++] = h[x++]
            }
            return new ar(_,m,g)
        }
        if (this.index === null)
            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
            this;
        const t = new Ir
          , r = this.index.array
          , s = this.attributes;
        for (const d in s) {
            const f = s[d]
              , h = e(f, r);
            t.setAttribute(d, h)
        }
        const o = this.morphAttributes;
        for (const d in o) {
            const f = []
              , h = o[d];
            for (let m = 0, g = h.length; m < g; m++) {
                const _ = h[m]
                  , x = e(_, r);
                f.push(x)
            }
            t.morphAttributes[d] = f
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const u = this.groups;
        for (let d = 0, f = u.length; d < f; d++) {
            const h = u[d];
            t.addGroup(h.start, h.count, h.materialIndex)
        }
        return t
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid,
        e.type = this.type,
        this.name !== "" && (e.name = this.name),
        Object.keys(this.userData).length > 0 && (e.userData = this.userData),
        this.parameters !== void 0) {
            const f = this.parameters;
            for (const h in f)
                f[h] !== void 0 && (e[h] = f[h]);
            return e
        }
        e.data = {
            attributes: {}
        };
        const t = this.index;
        t !== null && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
        });
        const r = this.attributes;
        for (const f in r) {
            const h = r[f];
            e.data.attributes[f] = h.toJSON(e.data)
        }
        const s = {};
        let o = !1;
        for (const f in this.morphAttributes) {
            const h = this.morphAttributes[f]
              , m = [];
            for (let g = 0, _ = h.length; g < _; g++) {
                const x = h[g];
                m.push(x.toJSON(e.data))
            }
            m.length > 0 && (s[f] = m,
            o = !0)
        }
        o && (e.data.morphAttributes = s,
        e.data.morphTargetsRelative = this.morphTargetsRelative);
        const u = this.groups;
        u.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(u)));
        const d = this.boundingSphere;
        return d !== null && (e.data.boundingSphere = {
            center: d.center.toArray(),
            radius: d.radius
        }),
        e
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null;
        const t = {};
        this.name = e.name;
        const r = e.index;
        r !== null && this.setIndex(r.clone());
        const s = e.attributes;
        for (const h in s) {
            const m = s[h];
            this.setAttribute(h, m.clone(t))
        }
        const o = e.morphAttributes;
        for (const h in o) {
            const m = []
              , g = o[h];
            for (let _ = 0, x = g.length; _ < x; _++)
                m.push(g[_].clone(t));
            this.morphAttributes[h] = m
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const u = e.groups;
        for (let h = 0, m = u.length; h < m; h++) {
            const g = u[h];
            this.addGroup(g.start, g.count, g.materialIndex)
        }
        const d = e.boundingBox;
        d !== null && (this.boundingBox = d.clone());
        const f = e.boundingSphere;
        return f !== null && (this.boundingSphere = f.clone()),
        this.drawRange.start = e.drawRange.start,
        this.drawRange.count = e.drawRange.count,
        this.userData = e.userData,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const mS = new Ln
  , Bs = new QM
  , jd = new ih
  , gS = new Ee
  , Wd = new Ee
  , Xd = new Ee
  , qd = new Ee
  , rg = new Ee
  , Yd = new Ee
  , vS = new Ee
  , Zd = new Ee;
class ba extends fi {
    constructor(e=new Ir, t=new tw) {
        super(),
        this.isMesh = !0,
        this.type = "Mesh",
        this.geometry = e,
        this.material = t,
        this.morphTargetDictionary = void 0,
        this.morphTargetInfluences = void 0,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
        e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , r = Object.keys(t);
        if (r.length > 0) {
            const s = t[r[0]];
            if (s !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let o = 0, u = s.length; o < u; o++) {
                    const d = s[o].name || String(o);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[d] = o
                }
            }
        }
    }
    getVertexPosition(e, t) {
        const r = this.geometry
          , s = r.attributes.position
          , o = r.morphAttributes.position
          , u = r.morphTargetsRelative;
        t.fromBufferAttribute(s, e);
        const d = this.morphTargetInfluences;
        if (o && d) {
            Yd.set(0, 0, 0);
            for (let f = 0, h = o.length; f < h; f++) {
                const m = d[f]
                  , g = o[f];
                m !== 0 && (rg.fromBufferAttribute(g, e),
                u ? Yd.addScaledVector(rg, m) : Yd.addScaledVector(rg.sub(t), m))
            }
            t.add(Yd)
        }
        return t
    }
    raycast(e, t) {
        const r = this.geometry
          , s = this.material
          , o = this.matrixWorld;
        s !== void 0 && (r.boundingSphere === null && r.computeBoundingSphere(),
        jd.copy(r.boundingSphere),
        jd.applyMatrix4(o),
        Bs.copy(e.ray).recast(e.near),
        !(jd.containsPoint(Bs.origin) === !1 && (Bs.intersectSphere(jd, gS) === null || Bs.origin.distanceToSquared(gS) > (e.far - e.near) ** 2)) && (mS.copy(o).invert(),
        Bs.copy(e.ray).applyMatrix4(mS),
        !(r.boundingBox !== null && Bs.intersectsBox(r.boundingBox) === !1) && this._computeIntersections(e, t, Bs)))
    }
    _computeIntersections(e, t, r) {
        let s;
        const o = this.geometry
          , u = this.material
          , d = o.index
          , f = o.attributes.position
          , h = o.attributes.uv
          , m = o.attributes.uv1
          , g = o.attributes.normal
          , _ = o.groups
          , x = o.drawRange;
        if (d !== null)
            if (Array.isArray(u))
                for (let E = 0, M = _.length; E < M; E++) {
                    const b = _[E]
                      , y = u[b.materialIndex]
                      , T = Math.max(b.start, x.start)
                      , D = Math.min(d.count, Math.min(b.start + b.count, x.start + x.count));
                    for (let C = T, P = D; C < P; C += 3) {
                        const A = d.getX(C)
                          , F = d.getX(C + 1)
                          , z = d.getX(C + 2);
                        s = $d(this, y, e, r, h, m, g, A, F, z),
                        s && (s.faceIndex = Math.floor(C / 3),
                        s.face.materialIndex = b.materialIndex,
                        t.push(s))
                    }
                }
            else {
                const E = Math.max(0, x.start)
                  , M = Math.min(d.count, x.start + x.count);
                for (let b = E, y = M; b < y; b += 3) {
                    const T = d.getX(b)
                      , D = d.getX(b + 1)
                      , C = d.getX(b + 2);
                    s = $d(this, u, e, r, h, m, g, T, D, C),
                    s && (s.faceIndex = Math.floor(b / 3),
                    t.push(s))
                }
            }
        else if (f !== void 0)
            if (Array.isArray(u))
                for (let E = 0, M = _.length; E < M; E++) {
                    const b = _[E]
                      , y = u[b.materialIndex]
                      , T = Math.max(b.start, x.start)
                      , D = Math.min(f.count, Math.min(b.start + b.count, x.start + x.count));
                    for (let C = T, P = D; C < P; C += 3) {
                        const A = C
                          , F = C + 1
                          , z = C + 2;
                        s = $d(this, y, e, r, h, m, g, A, F, z),
                        s && (s.faceIndex = Math.floor(C / 3),
                        s.face.materialIndex = b.materialIndex,
                        t.push(s))
                    }
                }
            else {
                const E = Math.max(0, x.start)
                  , M = Math.min(f.count, x.start + x.count);
                for (let b = E, y = M; b < y; b += 3) {
                    const T = b
                      , D = b + 1
                      , C = b + 2;
                    s = $d(this, u, e, r, h, m, g, T, D, C),
                    s && (s.faceIndex = Math.floor(b / 3),
                    t.push(s))
                }
            }
    }
}
function hL(n, e, t, r, s, o, u, d) {
    let f;
    if (e.side === Ni ? f = r.intersectTriangle(u, o, s, !0, d) : f = r.intersectTriangle(s, o, u, e.side === _s, d),
    f === null)
        return null;
    Zd.copy(d),
    Zd.applyMatrix4(n.matrixWorld);
    const h = t.ray.origin.distanceTo(Zd);
    return h < t.near || h > t.far ? null : {
        distance: h,
        point: Zd.clone(),
        object: n
    }
}
function $d(n, e, t, r, s, o, u, d, f, h) {
    n.getVertexPosition(d, Wd),
    n.getVertexPosition(f, Xd),
    n.getVertexPosition(h, qd);
    const m = hL(n, e, t, r, Wd, Xd, qd, vS);
    if (m) {
        const g = new Ee;
        gr.getBarycoord(vS, Wd, Xd, qd, g),
        s && (m.uv = gr.getInterpolatedAttribute(s, d, f, h, g, new _n)),
        o && (m.uv1 = gr.getInterpolatedAttribute(o, d, f, h, g, new _n)),
        u && (m.normal = gr.getInterpolatedAttribute(u, d, f, h, g, new Ee),
        m.normal.dot(r.direction) > 0 && m.normal.multiplyScalar(-1));
        const _ = {
            a: d,
            b: f,
            c: h,
            normal: new Ee,
            materialIndex: 0
        };
        gr.getNormal(Wd, Xd, qd, _.normal),
        m.face = _,
        m.barycoord = g
    }
    return m
}
class _u extends Ir {
    constructor(e=1, t=1, r=1, s=1, o=1, u=1) {
        super(),
        this.type = "BoxGeometry",
        this.parameters = {
            width: e,
            height: t,
            depth: r,
            widthSegments: s,
            heightSegments: o,
            depthSegments: u
        };
        const d = this;
        s = Math.floor(s),
        o = Math.floor(o),
        u = Math.floor(u);
        const f = []
          , h = []
          , m = []
          , g = [];
        let _ = 0
          , x = 0;
        E("z", "y", "x", -1, -1, r, t, e, u, o, 0),
        E("z", "y", "x", 1, -1, r, t, -e, u, o, 1),
        E("x", "z", "y", 1, 1, e, r, t, s, u, 2),
        E("x", "z", "y", 1, -1, e, r, -t, s, u, 3),
        E("x", "y", "z", 1, -1, e, t, r, s, o, 4),
        E("x", "y", "z", -1, -1, e, t, -r, s, o, 5),
        this.setIndex(f),
        this.setAttribute("position", new eo(h,3)),
        this.setAttribute("normal", new eo(m,3)),
        this.setAttribute("uv", new eo(g,2));
        function E(M, b, y, T, D, C, P, A, F, z, U) {
            const R = C / F
              , V = P / z
              , Q = C / 2
              , X = P / 2
              , oe = A / 2
              , le = F + 1
              , O = z + 1;
            let W = 0
              , H = 0;
            const Me = new Ee;
            for (let k = 0; k < O; k++) {
                const ee = k * V - X;
                for (let ge = 0; ge < le; ge++) {
                    const pe = ge * R - Q;
                    Me[M] = pe * T,
                    Me[b] = ee * D,
                    Me[y] = oe,
                    h.push(Me.x, Me.y, Me.z),
                    Me[M] = 0,
                    Me[b] = 0,
                    Me[y] = A > 0 ? 1 : -1,
                    m.push(Me.x, Me.y, Me.z),
                    g.push(ge / F),
                    g.push(1 - k / z),
                    W += 1
                }
            }
            for (let k = 0; k < z; k++)
                for (let ee = 0; ee < F; ee++) {
                    const ge = _ + ee + le * k
                      , pe = _ + ee + le * (k + 1)
                      , te = _ + (ee + 1) + le * (k + 1)
                      , we = _ + (ee + 1) + le * k;
                    f.push(ge, pe, we),
                    f.push(pe, te, we),
                    H += 6
                }
            d.addGroup(x, H, U),
            x += H,
            _ += W
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new _u(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
    }
}
function _l(n) {
    const e = {};
    for (const t in n) {
        e[t] = {};
        for (const r in n[t]) {
            const s = n[t][r];
            s && (s.isColor || s.isMatrix3 || s.isMatrix4 || s.isVector2 || s.isVector3 || s.isVector4 || s.isTexture || s.isQuaternion) ? s.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
            e[t][r] = null) : e[t][r] = s.clone() : Array.isArray(s) ? e[t][r] = s.slice() : e[t][r] = s
        }
    }
    return e
}
function xi(n) {
    const e = {};
    for (let t = 0; t < n.length; t++) {
        const r = _l(n[t]);
        for (const s in r)
            e[s] = r[s]
    }
    return e
}
function pL(n) {
    const e = [];
    for (let t = 0; t < n.length; t++)
        e.push(n[t].clone());
    return e
}
function rw(n) {
    const e = n.getRenderTarget();
    return e === null ? n.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : fn.workingColorSpace
}
const mL = {
    clone: _l,
    merge: xi
};
var gL = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`
  , vL = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class ys extends vu {
    constructor(e) {
        super(),
        this.isShaderMaterial = !0,
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.uniformsGroups = [],
        this.vertexShader = gL,
        this.fragmentShader = vL,
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.forceSinglePass = !0,
        this.extensions = {
            clipCullDistance: !1,
            multiDraw: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv1: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        this.glslVersion = null,
        e !== void 0 && this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.fragmentShader = e.fragmentShader,
        this.vertexShader = e.vertexShader,
        this.uniforms = _l(e.uniforms),
        this.uniformsGroups = pL(e.uniformsGroups),
        this.defines = Object.assign({}, e.defines),
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.fog = e.fog,
        this.lights = e.lights,
        this.clipping = e.clipping,
        this.extensions = Object.assign({}, e.extensions),
        this.glslVersion = e.glslVersion,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        t.glslVersion = this.glslVersion,
        t.uniforms = {};
        for (const s in this.uniforms) {
            const u = this.uniforms[s].value;
            u && u.isTexture ? t.uniforms[s] = {
                type: "t",
                value: u.toJSON(e).uuid
            } : u && u.isColor ? t.uniforms[s] = {
                type: "c",
                value: u.getHex()
            } : u && u.isVector2 ? t.uniforms[s] = {
                type: "v2",
                value: u.toArray()
            } : u && u.isVector3 ? t.uniforms[s] = {
                type: "v3",
                value: u.toArray()
            } : u && u.isVector4 ? t.uniforms[s] = {
                type: "v4",
                value: u.toArray()
            } : u && u.isMatrix3 ? t.uniforms[s] = {
                type: "m3",
                value: u.toArray()
            } : u && u.isMatrix4 ? t.uniforms[s] = {
                type: "m4",
                value: u.toArray()
            } : t.uniforms[s] = {
                value: u
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
        t.vertexShader = this.vertexShader,
        t.fragmentShader = this.fragmentShader,
        t.lights = this.lights,
        t.clipping = this.clipping;
        const r = {};
        for (const s in this.extensions)
            this.extensions[s] === !0 && (r[s] = !0);
        return Object.keys(r).length > 0 && (t.extensions = r),
        t
    }
}
class aw extends fi {
    constructor() {
        super(),
        this.isCamera = !0,
        this.type = "Camera",
        this.matrixWorldInverse = new Ln,
        this.projectionMatrix = new Ln,
        this.projectionMatrixInverse = new Ln,
        this.coordinateSystem = xa
    }
    copy(e, t) {
        return super.copy(e, t),
        this.matrixWorldInverse.copy(e.matrixWorldInverse),
        this.projectionMatrix.copy(e.projectionMatrix),
        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
        this.coordinateSystem = e.coordinateSystem,
        this
    }
    getWorldDirection(e) {
        return super.getWorldDirection(e).negate()
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const rs = new Ee
  , _S = new _n
  , yS = new _n;
class ir extends aw {
    constructor(e=50, t=1, r=.1, s=2e3) {
        super(),
        this.isPerspectiveCamera = !0,
        this.type = "PerspectiveCamera",
        this.fov = e,
        this.zoom = 1,
        this.near = r,
        this.far = s,
        this.focus = 10,
        this.aspect = t,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.fov = e.fov,
        this.zoom = e.zoom,
        this.near = e.near,
        this.far = e.far,
        this.focus = e.focus,
        this.aspect = e.aspect,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this.filmGauge = e.filmGauge,
        this.filmOffset = e.filmOffset,
        this
    }
    setFocalLength(e) {
        const t = .5 * this.getFilmHeight() / e;
        this.fov = Sv * 2 * Math.atan(t),
        this.updateProjectionMatrix()
    }
    getFocalLength() {
        const e = Math.tan(km * .5 * this.fov);
        return .5 * this.getFilmHeight() / e
    }
    getEffectiveFOV() {
        return Sv * 2 * Math.atan(Math.tan(km * .5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    getViewBounds(e, t, r) {
        rs.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse),
        t.set(rs.x, rs.y).multiplyScalar(-e / rs.z),
        rs.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse),
        r.set(rs.x, rs.y).multiplyScalar(-e / rs.z)
    }
    getViewSize(e, t) {
        return this.getViewBounds(e, _S, yS),
        t.subVectors(yS, _S)
    }
    setViewOffset(e, t, r, s, o, u) {
        this.aspect = e / t,
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = r,
        this.view.offsetY = s,
        this.view.width = o,
        this.view.height = u,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = this.near;
        let t = e * Math.tan(km * .5 * this.fov) / this.zoom
          , r = 2 * t
          , s = this.aspect * r
          , o = -.5 * s;
        const u = this.view;
        if (this.view !== null && this.view.enabled) {
            const f = u.fullWidth
              , h = u.fullHeight;
            o += u.offsetX * s / f,
            t -= u.offsetY * r / h,
            s *= u.width / f,
            r *= u.height / h
        }
        const d = this.filmOffset;
        d !== 0 && (o += e * d / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(o, o + s, t, t - r, e, this.far, this.coordinateSystem),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.fov = this.fov,
        t.object.zoom = this.zoom,
        t.object.near = this.near,
        t.object.far = this.far,
        t.object.focus = this.focus,
        t.object.aspect = this.aspect,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t.object.filmGauge = this.filmGauge,
        t.object.filmOffset = this.filmOffset,
        t
    }
}
const Qo = -90
  , Jo = 1;
class _L extends fi {
    constructor(e, t, r) {
        super(),
        this.type = "CubeCamera",
        this.renderTarget = r,
        this.coordinateSystem = null,
        this.activeMipmapLevel = 0;
        const s = new ir(Qo,Jo,e,t);
        s.layers = this.layers,
        this.add(s);
        const o = new ir(Qo,Jo,e,t);
        o.layers = this.layers,
        this.add(o);
        const u = new ir(Qo,Jo,e,t);
        u.layers = this.layers,
        this.add(u);
        const d = new ir(Qo,Jo,e,t);
        d.layers = this.layers,
        this.add(d);
        const f = new ir(Qo,Jo,e,t);
        f.layers = this.layers,
        this.add(f);
        const h = new ir(Qo,Jo,e,t);
        h.layers = this.layers,
        this.add(h)
    }
    updateCoordinateSystem() {
        const e = this.coordinateSystem
          , t = this.children.concat()
          , [r,s,o,u,d,f] = t;
        for (const h of t)
            this.remove(h);
        if (e === xa)
            r.up.set(0, 1, 0),
            r.lookAt(1, 0, 0),
            s.up.set(0, 1, 0),
            s.lookAt(-1, 0, 0),
            o.up.set(0, 0, -1),
            o.lookAt(0, 1, 0),
            u.up.set(0, 0, 1),
            u.lookAt(0, -1, 0),
            d.up.set(0, 1, 0),
            d.lookAt(0, 0, 1),
            f.up.set(0, 1, 0),
            f.lookAt(0, 0, -1);
        else if (e === Tf)
            r.up.set(0, -1, 0),
            r.lookAt(-1, 0, 0),
            s.up.set(0, -1, 0),
            s.lookAt(1, 0, 0),
            o.up.set(0, 0, 1),
            o.lookAt(0, 1, 0),
            u.up.set(0, 0, -1),
            u.lookAt(0, -1, 0),
            d.up.set(0, -1, 0),
            d.lookAt(0, 0, 1),
            f.up.set(0, -1, 0),
            f.lookAt(0, 0, -1);
        else
            throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
        for (const h of t)
            this.add(h),
            h.updateMatrixWorld()
    }
    update(e, t) {
        this.parent === null && this.updateMatrixWorld();
        const {renderTarget: r, activeMipmapLevel: s} = this;
        this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem,
        this.updateCoordinateSystem());
        const [o,u,d,f,h,m] = this.children
          , g = e.getRenderTarget()
          , _ = e.getActiveCubeFace()
          , x = e.getActiveMipmapLevel()
          , E = e.xr.enabled;
        e.xr.enabled = !1;
        const M = r.texture.generateMipmaps;
        r.texture.generateMipmaps = !1,
        e.setRenderTarget(r, 0, s),
        e.render(t, o),
        e.setRenderTarget(r, 1, s),
        e.render(t, u),
        e.setRenderTarget(r, 2, s),
        e.render(t, d),
        e.setRenderTarget(r, 3, s),
        e.render(t, f),
        e.setRenderTarget(r, 4, s),
        e.render(t, h),
        r.texture.generateMipmaps = M,
        e.setRenderTarget(r, 5, s),
        e.render(t, m),
        e.setRenderTarget(g, _, x),
        e.xr.enabled = E,
        r.texture.needsPMREMUpdate = !0
    }
}
class sw extends wi {
    constructor(e=[], t=ml, r, s, o, u, d, f, h, m) {
        super(e, t, r, s, o, u, d, f, h, m),
        this.isCubeTexture = !0,
        this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(e) {
        this.image = e
    }
}
class yL extends io {
    constructor(e=1, t={}) {
        super(e, e, t),
        this.isWebGLCubeRenderTarget = !0;
        const r = {
            width: e,
            height: e,
            depth: 1
        }
          , s = [r, r, r, r, r, r];
        this.texture = new sw(s,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),
        this.texture.isRenderTargetTexture = !0,
        this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1,
        this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Ur
    }
    fromEquirectangularTexture(e, t) {
        this.texture.type = t.type,
        this.texture.colorSpace = t.colorSpace,
        this.texture.generateMipmaps = t.generateMipmaps,
        this.texture.minFilter = t.minFilter,
        this.texture.magFilter = t.magFilter;
        const r = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        }
          , s = new _u(5,5,5)
          , o = new ys({
            name: "CubemapFromEquirect",
            uniforms: _l(r.uniforms),
            vertexShader: r.vertexShader,
            fragmentShader: r.fragmentShader,
            side: Ni,
            blending: ms
        });
        o.uniforms.tEquirect.value = t;
        const u = new ba(s,o)
          , d = t.minFilter;
        return t.minFilter === Qs && (t.minFilter = Ur),
        new _L(1,10,this).update(e, u),
        t.minFilter = d,
        u.geometry.dispose(),
        u.material.dispose(),
        this
    }
    clear(e, t=!0, r=!0, s=!0) {
        const o = e.getRenderTarget();
        for (let u = 0; u < 6; u++)
            e.setRenderTarget(this, u),
            e.clear(t, r, s);
        e.setRenderTarget(o)
    }
}
class Kd extends fi {
    constructor() {
        super(),
        this.isGroup = !0,
        this.type = "Group"
    }
}
const xL = {
    type: "move"
};
class ag {
    constructor() {
        this._targetRay = null,
        this._grip = null,
        this._hand = null
    }
    getHandSpace() {
        return this._hand === null && (this._hand = new Kd,
        this._hand.matrixAutoUpdate = !1,
        this._hand.visible = !1,
        this._hand.joints = {},
        this._hand.inputState = {
            pinching: !1
        }),
        this._hand
    }
    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new Kd,
        this._targetRay.matrixAutoUpdate = !1,
        this._targetRay.visible = !1,
        this._targetRay.hasLinearVelocity = !1,
        this._targetRay.linearVelocity = new Ee,
        this._targetRay.hasAngularVelocity = !1,
        this._targetRay.angularVelocity = new Ee),
        this._targetRay
    }
    getGripSpace() {
        return this._grip === null && (this._grip = new Kd,
        this._grip.matrixAutoUpdate = !1,
        this._grip.visible = !1,
        this._grip.hasLinearVelocity = !1,
        this._grip.linearVelocity = new Ee,
        this._grip.hasAngularVelocity = !1,
        this._grip.angularVelocity = new Ee),
        this._grip
    }
    dispatchEvent(e) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(e),
        this._grip !== null && this._grip.dispatchEvent(e),
        this._hand !== null && this._hand.dispatchEvent(e),
        this
    }
    connect(e) {
        if (e && e.hand) {
            const t = this._hand;
            if (t)
                for (const r of e.hand.values())
                    this._getHandJoint(t, r)
        }
        return this.dispatchEvent({
            type: "connected",
            data: e
        }),
        this
    }
    disconnect(e) {
        return this.dispatchEvent({
            type: "disconnected",
            data: e
        }),
        this._targetRay !== null && (this._targetRay.visible = !1),
        this._grip !== null && (this._grip.visible = !1),
        this._hand !== null && (this._hand.visible = !1),
        this
    }
    update(e, t, r) {
        let s = null
          , o = null
          , u = null;
        const d = this._targetRay
          , f = this._grip
          , h = this._hand;
        if (e && t.session.visibilityState !== "visible-blurred") {
            if (h && e.hand) {
                u = !0;
                for (const M of e.hand.values()) {
                    const b = t.getJointPose(M, r)
                      , y = this._getHandJoint(h, M);
                    b !== null && (y.matrix.fromArray(b.transform.matrix),
                    y.matrix.decompose(y.position, y.rotation, y.scale),
                    y.matrixWorldNeedsUpdate = !0,
                    y.jointRadius = b.radius),
                    y.visible = b !== null
                }
                const m = h.joints["index-finger-tip"]
                  , g = h.joints["thumb-tip"]
                  , _ = m.position.distanceTo(g.position)
                  , x = .02
                  , E = .005;
                h.inputState.pinching && _ > x + E ? (h.inputState.pinching = !1,
                this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !h.inputState.pinching && _ <= x - E && (h.inputState.pinching = !0,
                this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }))
            } else
                f !== null && e.gripSpace && (o = t.getPose(e.gripSpace, r),
                o !== null && (f.matrix.fromArray(o.transform.matrix),
                f.matrix.decompose(f.position, f.rotation, f.scale),
                f.matrixWorldNeedsUpdate = !0,
                o.linearVelocity ? (f.hasLinearVelocity = !0,
                f.linearVelocity.copy(o.linearVelocity)) : f.hasLinearVelocity = !1,
                o.angularVelocity ? (f.hasAngularVelocity = !0,
                f.angularVelocity.copy(o.angularVelocity)) : f.hasAngularVelocity = !1));
            d !== null && (s = t.getPose(e.targetRaySpace, r),
            s === null && o !== null && (s = o),
            s !== null && (d.matrix.fromArray(s.transform.matrix),
            d.matrix.decompose(d.position, d.rotation, d.scale),
            d.matrixWorldNeedsUpdate = !0,
            s.linearVelocity ? (d.hasLinearVelocity = !0,
            d.linearVelocity.copy(s.linearVelocity)) : d.hasLinearVelocity = !1,
            s.angularVelocity ? (d.hasAngularVelocity = !0,
            d.angularVelocity.copy(s.angularVelocity)) : d.hasAngularVelocity = !1,
            this.dispatchEvent(xL)))
        }
        return d !== null && (d.visible = s !== null),
        f !== null && (f.visible = o !== null),
        h !== null && (h.visible = u !== null),
        this
    }
    _getHandJoint(e, t) {
        if (e.joints[t.jointName] === void 0) {
            const r = new Kd;
            r.matrixAutoUpdate = !1,
            r.visible = !1,
            e.joints[t.jointName] = r,
            e.add(r)
        }
        return e.joints[t.jointName]
    }
}
class bL extends fi {
    constructor() {
        super(),
        this.isScene = !0,
        this.type = "Scene",
        this.background = null,
        this.environment = null,
        this.fog = null,
        this.backgroundBlurriness = 0,
        this.backgroundIntensity = 1,
        this.backgroundRotation = new Aa,
        this.environmentIntensity = 1,
        this.environmentRotation = new Aa,
        this.overrideMaterial = null,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    copy(e, t) {
        return super.copy(e, t),
        e.background !== null && (this.background = e.background.clone()),
        e.environment !== null && (this.environment = e.environment.clone()),
        e.fog !== null && (this.fog = e.fog.clone()),
        this.backgroundBlurriness = e.backgroundBlurriness,
        this.backgroundIntensity = e.backgroundIntensity,
        this.backgroundRotation.copy(e.backgroundRotation),
        this.environmentIntensity = e.environmentIntensity,
        this.environmentRotation.copy(e.environmentRotation),
        e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.fog !== null && (t.object.fog = this.fog.toJSON()),
        this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
        this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity),
        t.object.backgroundRotation = this.backgroundRotation.toArray(),
        this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity),
        t.object.environmentRotation = this.environmentRotation.toArray(),
        t
    }
}
const sg = new Ee
  , SL = new Ee
  , EL = new Vt;
class Ws {
    constructor(e=new Ee(1,0,0), t=0) {
        this.isPlane = !0,
        this.normal = e,
        this.constant = t
    }
    set(e, t) {
        return this.normal.copy(e),
        this.constant = t,
        this
    }
    setComponents(e, t, r, s) {
        return this.normal.set(e, t, r),
        this.constant = s,
        this
    }
    setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e),
        this.constant = -t.dot(this.normal),
        this
    }
    setFromCoplanarPoints(e, t, r) {
        const s = sg.subVectors(r, t).cross(SL.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(s, e),
        this
    }
    copy(e) {
        return this.normal.copy(e.normal),
        this.constant = e.constant,
        this
    }
    normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e),
        this.constant *= e,
        this
    }
    negate() {
        return this.constant *= -1,
        this.normal.negate(),
        this
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius
    }
    projectPoint(e, t) {
        return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
    }
    intersectLine(e, t) {
        const r = e.delta(sg)
          , s = this.normal.dot(r);
        if (s === 0)
            return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
        const o = -(e.start.dot(this.normal) + this.constant) / s;
        return o < 0 || o > 1 ? null : t.copy(e.start).addScaledVector(r, o)
    }
    intersectsLine(e) {
        const t = this.distanceToPoint(e.start)
          , r = this.distanceToPoint(e.end);
        return t < 0 && r > 0 || r < 0 && t > 0
    }
    intersectsBox(e) {
        return e.intersectsPlane(this)
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this)
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(e, t) {
        const r = t || EL.getNormalMatrix(e)
          , s = this.coplanarPoint(sg).applyMatrix4(e)
          , o = this.normal.applyMatrix3(r).normalize();
        return this.constant = -s.dot(o),
        this
    }
    translate(e) {
        return this.constant -= e.dot(this.normal),
        this
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const Vs = new ih
  , Qd = new Ee;
class d_ {
    constructor(e=new Ws, t=new Ws, r=new Ws, s=new Ws, o=new Ws, u=new Ws) {
        this.planes = [e, t, r, s, o, u]
    }
    set(e, t, r, s, o, u) {
        const d = this.planes;
        return d[0].copy(e),
        d[1].copy(t),
        d[2].copy(r),
        d[3].copy(s),
        d[4].copy(o),
        d[5].copy(u),
        this
    }
    copy(e) {
        const t = this.planes;
        for (let r = 0; r < 6; r++)
            t[r].copy(e.planes[r]);
        return this
    }
    setFromProjectionMatrix(e, t=xa) {
        const r = this.planes
          , s = e.elements
          , o = s[0]
          , u = s[1]
          , d = s[2]
          , f = s[3]
          , h = s[4]
          , m = s[5]
          , g = s[6]
          , _ = s[7]
          , x = s[8]
          , E = s[9]
          , M = s[10]
          , b = s[11]
          , y = s[12]
          , T = s[13]
          , D = s[14]
          , C = s[15];
        if (r[0].setComponents(f - o, _ - h, b - x, C - y).normalize(),
        r[1].setComponents(f + o, _ + h, b + x, C + y).normalize(),
        r[2].setComponents(f + u, _ + m, b + E, C + T).normalize(),
        r[3].setComponents(f - u, _ - m, b - E, C - T).normalize(),
        r[4].setComponents(f - d, _ - g, b - M, C - D).normalize(),
        t === xa)
            r[5].setComponents(f + d, _ + g, b + M, C + D).normalize();
        else if (t === Tf)
            r[5].setComponents(d, g, M, D).normalize();
        else
            throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
        return this
    }
    intersectsObject(e) {
        if (e.boundingSphere !== void 0)
            e.boundingSphere === null && e.computeBoundingSphere(),
            Vs.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
        else {
            const t = e.geometry;
            t.boundingSphere === null && t.computeBoundingSphere(),
            Vs.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
        }
        return this.intersectsSphere(Vs)
    }
    intersectsSprite(e) {
        return Vs.center.set(0, 0, 0),
        Vs.radius = .7071067811865476,
        Vs.applyMatrix4(e.matrixWorld),
        this.intersectsSphere(Vs)
    }
    intersectsSphere(e) {
        const t = this.planes
          , r = e.center
          , s = -e.radius;
        for (let o = 0; o < 6; o++)
            if (t[o].distanceToPoint(r) < s)
                return !1;
        return !0
    }
    intersectsBox(e) {
        const t = this.planes;
        for (let r = 0; r < 6; r++) {
            const s = t[r];
            if (Qd.x = s.normal.x > 0 ? e.max.x : e.min.x,
            Qd.y = s.normal.y > 0 ? e.max.y : e.min.y,
            Qd.z = s.normal.z > 0 ? e.max.z : e.min.z,
            s.distanceToPoint(Qd) < 0)
                return !1
        }
        return !0
    }
    containsPoint(e) {
        const t = this.planes;
        for (let r = 0; r < 6; r++)
            if (t[r].distanceToPoint(e) < 0)
                return !1;
        return !0
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class Ev extends vu {
    constructor(e) {
        super(),
        this.isPointsMaterial = !0,
        this.type = "PointsMaterial",
        this.color = new pn(16777215),
        this.map = null,
        this.alphaMap = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.size = e.size,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this
    }
}
const xS = new Ln
  , Mv = new QM
  , Jd = new ih
  , ef = new Ee;
class bS extends fi {
    constructor(e=new Ir, t=new Ev) {
        super(),
        this.isPoints = !0,
        this.type = "Points",
        this.geometry = e,
        this.material = t,
        this.morphTargetDictionary = void 0,
        this.morphTargetInfluences = void 0,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    raycast(e, t) {
        const r = this.geometry
          , s = this.matrixWorld
          , o = e.params.Points.threshold
          , u = r.drawRange;
        if (r.boundingSphere === null && r.computeBoundingSphere(),
        Jd.copy(r.boundingSphere),
        Jd.applyMatrix4(s),
        Jd.radius += o,
        e.ray.intersectsSphere(Jd) === !1)
            return;
        xS.copy(s).invert(),
        Mv.copy(e.ray).applyMatrix4(xS);
        const d = o / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , f = d * d
          , h = r.index
          , g = r.attributes.position;
        if (h !== null) {
            const _ = Math.max(0, u.start)
              , x = Math.min(h.count, u.start + u.count);
            for (let E = _, M = x; E < M; E++) {
                const b = h.getX(E);
                ef.fromBufferAttribute(g, b),
                SS(ef, b, f, s, e, t, this)
            }
        } else {
            const _ = Math.max(0, u.start)
              , x = Math.min(g.count, u.start + u.count);
            for (let E = _, M = x; E < M; E++)
                ef.fromBufferAttribute(g, E),
                SS(ef, E, f, s, e, t, this)
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , r = Object.keys(t);
        if (r.length > 0) {
            const s = t[r[0]];
            if (s !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let o = 0, u = s.length; o < u; o++) {
                    const d = s[o].name || String(o);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[d] = o
                }
            }
        }
    }
}
function SS(n, e, t, r, s, o, u) {
    const d = Mv.distanceSqToPoint(n);
    if (d < t) {
        const f = new Ee;
        Mv.closestPointToPoint(n, f),
        f.applyMatrix4(r);
        const h = s.ray.origin.distanceTo(f);
        if (h < s.near || h > s.far)
            return;
        o.push({
            distance: h,
            distanceToRay: Math.sqrt(d),
            point: f,
            index: e,
            face: null,
            faceIndex: null,
            barycoord: null,
            object: u
        })
    }
}
class ow extends wi {
    constructor(e, t, r=no, s, o, u, d=xr, f=xr, h, m=eu) {
        if (m !== eu && m !== tu)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        super(null, s, o, u, d, f, m, r, h),
        this.isDepthTexture = !0,
        this.image = {
            width: e,
            height: t
        },
        this.flipY = !1,
        this.generateMipmaps = !1,
        this.compareFunction = null
    }
    copy(e) {
        return super.copy(e),
        this.source = new u_(Object.assign({}, e.image)),
        this.compareFunction = e.compareFunction,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.compareFunction !== null && (t.compareFunction = this.compareFunction),
        t
    }
}
class rh extends Ir {
    constructor(e=1, t=1, r=1, s=1) {
        super(),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: r,
            heightSegments: s
        };
        const o = e / 2
          , u = t / 2
          , d = Math.floor(r)
          , f = Math.floor(s)
          , h = d + 1
          , m = f + 1
          , g = e / d
          , _ = t / f
          , x = []
          , E = []
          , M = []
          , b = [];
        for (let y = 0; y < m; y++) {
            const T = y * _ - u;
            for (let D = 0; D < h; D++) {
                const C = D * g - o;
                E.push(C, -T, 0),
                M.push(0, 0, 1),
                b.push(D / d),
                b.push(1 - y / f)
            }
        }
        for (let y = 0; y < f; y++)
            for (let T = 0; T < d; T++) {
                const D = T + h * y
                  , C = T + h * (y + 1)
                  , P = T + 1 + h * (y + 1)
                  , A = T + 1 + h * y;
                x.push(D, C, A),
                x.push(C, P, A)
            }
        this.setIndex(x),
        this.setAttribute("position", new eo(E,3)),
        this.setAttribute("normal", new eo(M,3)),
        this.setAttribute("uv", new eo(b,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new rh(e.width,e.height,e.widthSegments,e.heightSegments)
    }
}
class ML extends vu {
    constructor(e) {
        super(),
        this.isMeshDepthMaterial = !0,
        this.type = "MeshDepthMaterial",
        this.depthPacking = PU,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.depthPacking = e.depthPacking,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this
    }
}
class wL extends vu {
    constructor(e) {
        super(),
        this.isMeshDistanceMaterial = !0,
        this.type = "MeshDistanceMaterial",
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this
    }
}
const ES = {
    enabled: !1,
    files: {},
    add: function(n, e) {
        this.enabled !== !1 && (this.files[n] = e)
    },
    get: function(n) {
        if (this.enabled !== !1)
            return this.files[n]
    },
    remove: function(n) {
        delete this.files[n]
    },
    clear: function() {
        this.files = {}
    }
};
class TL {
    constructor(e, t, r) {
        const s = this;
        let o = !1, u = 0, d = 0, f;
        const h = [];
        this.onStart = void 0,
        this.onLoad = e,
        this.onProgress = t,
        this.onError = r,
        this.itemStart = function(m) {
            d++,
            o === !1 && s.onStart !== void 0 && s.onStart(m, u, d),
            o = !0
        }
        ,
        this.itemEnd = function(m) {
            u++,
            s.onProgress !== void 0 && s.onProgress(m, u, d),
            u === d && (o = !1,
            s.onLoad !== void 0 && s.onLoad())
        }
        ,
        this.itemError = function(m) {
            s.onError !== void 0 && s.onError(m)
        }
        ,
        this.resolveURL = function(m) {
            return f ? f(m) : m
        }
        ,
        this.setURLModifier = function(m) {
            return f = m,
            this
        }
        ,
        this.addHandler = function(m, g) {
            return h.push(m, g),
            this
        }
        ,
        this.removeHandler = function(m) {
            const g = h.indexOf(m);
            return g !== -1 && h.splice(g, 2),
            this
        }
        ,
        this.getHandler = function(m) {
            for (let g = 0, _ = h.length; g < _; g += 2) {
                const x = h[g]
                  , E = h[g + 1];
                if (x.global && (x.lastIndex = 0),
                x.test(m))
                    return E
            }
            return null
        }
    }
}
const AL = new TL;
let f_ = class {
    constructor(e) {
        this.manager = e !== void 0 ? e : AL,
        this.crossOrigin = "anonymous",
        this.withCredentials = !1,
        this.path = "",
        this.resourcePath = "",
        this.requestHeader = {}
    }
    load() {}
    loadAsync(e, t) {
        const r = this;
        return new Promise(function(s, o) {
            r.load(e, s, t, o)
        }
        )
    }
    parse() {}
    setCrossOrigin(e) {
        return this.crossOrigin = e,
        this
    }
    setWithCredentials(e) {
        return this.withCredentials = e,
        this
    }
    setPath(e) {
        return this.path = e,
        this
    }
    setResourcePath(e) {
        return this.resourcePath = e,
        this
    }
    setRequestHeader(e) {
        return this.requestHeader = e,
        this
    }
}
;
f_.DEFAULT_MATERIAL_NAME = "__DEFAULT";
class RL extends f_ {
    constructor(e) {
        super(e)
    }
    load(e, t, r, s) {
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const o = this
          , u = ES.get(e);
        if (u !== void 0)
            return o.manager.itemStart(e),
            setTimeout(function() {
                t && t(u),
                o.manager.itemEnd(e)
            }, 0),
            u;
        const d = nu("img");
        function f() {
            m(),
            ES.add(e, this),
            t && t(this),
            o.manager.itemEnd(e)
        }
        function h(g) {
            m(),
            s && s(g),
            o.manager.itemError(e),
            o.manager.itemEnd(e)
        }
        function m() {
            d.removeEventListener("load", f, !1),
            d.removeEventListener("error", h, !1)
        }
        return d.addEventListener("load", f, !1),
        d.addEventListener("error", h, !1),
        e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (d.crossOrigin = this.crossOrigin),
        o.manager.itemStart(e),
        d.src = e,
        d
    }
}
class CL extends f_ {
    constructor(e) {
        super(e)
    }
    load(e, t, r, s) {
        const o = new wi
          , u = new RL(this.manager);
        return u.setCrossOrigin(this.crossOrigin),
        u.setPath(this.path),
        u.load(e, function(d) {
            o.image = d,
            o.needsUpdate = !0,
            t !== void 0 && t(o)
        }, r, s),
        o
    }
}
class DL extends fi {
    constructor(e, t=1) {
        super(),
        this.isLight = !0,
        this.type = "Light",
        this.color = new pn(e),
        this.intensity = t
    }
    dispose() {}
    copy(e, t) {
        return super.copy(e, t),
        this.color.copy(e.color),
        this.intensity = e.intensity,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.color = this.color.getHex(),
        t.object.intensity = this.intensity,
        this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()),
        this.distance !== void 0 && (t.object.distance = this.distance),
        this.angle !== void 0 && (t.object.angle = this.angle),
        this.decay !== void 0 && (t.object.decay = this.decay),
        this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
        this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
        this.target !== void 0 && (t.object.target = this.target.uuid),
        t
    }
}
const og = new Ln
  , MS = new Ee
  , wS = new Ee;
class UL {
    constructor(e) {
        this.camera = e,
        this.intensity = 1,
        this.bias = 0,
        this.normalBias = 0,
        this.radius = 1,
        this.blurSamples = 8,
        this.mapSize = new _n(512,512),
        this.map = null,
        this.mapPass = null,
        this.matrix = new Ln,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this._frustum = new d_,
        this._frameExtents = new _n(1,1),
        this._viewportCount = 1,
        this._viewports = [new zn(0,0,1,1)]
    }
    getViewportCount() {
        return this._viewportCount
    }
    getFrustum() {
        return this._frustum
    }
    updateMatrices(e) {
        const t = this.camera
          , r = this.matrix;
        MS.setFromMatrixPosition(e.matrixWorld),
        t.position.copy(MS),
        wS.setFromMatrixPosition(e.target.matrixWorld),
        t.lookAt(wS),
        t.updateMatrixWorld(),
        og.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(og),
        r.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
        r.multiply(og)
    }
    getViewport(e) {
        return this._viewports[e]
    }
    getFrameExtents() {
        return this._frameExtents
    }
    dispose() {
        this.map && this.map.dispose(),
        this.mapPass && this.mapPass.dispose()
    }
    copy(e) {
        return this.camera = e.camera.clone(),
        this.intensity = e.intensity,
        this.bias = e.bias,
        this.radius = e.radius,
        this.mapSize.copy(e.mapSize),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        const e = {};
        return this.intensity !== 1 && (e.intensity = this.intensity),
        this.bias !== 0 && (e.bias = this.bias),
        this.normalBias !== 0 && (e.normalBias = this.normalBias),
        this.radius !== 1 && (e.radius = this.radius),
        (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()),
        e.camera = this.camera.toJSON(!1).object,
        delete e.camera.matrix,
        e
    }
}
class lw extends aw {
    constructor(e=-1, t=1, r=1, s=-1, o=.1, u=2e3) {
        super(),
        this.isOrthographicCamera = !0,
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = e,
        this.right = t,
        this.top = r,
        this.bottom = s,
        this.near = o,
        this.far = u,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.left = e.left,
        this.right = e.right,
        this.top = e.top,
        this.bottom = e.bottom,
        this.near = e.near,
        this.far = e.far,
        this.zoom = e.zoom,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this
    }
    setViewOffset(e, t, r, s, o, u) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = r,
        this.view.offsetY = s,
        this.view.width = o,
        this.view.height = u,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom)
          , t = (this.top - this.bottom) / (2 * this.zoom)
          , r = (this.right + this.left) / 2
          , s = (this.top + this.bottom) / 2;
        let o = r - e
          , u = r + e
          , d = s + t
          , f = s - t;
        if (this.view !== null && this.view.enabled) {
            const h = (this.right - this.left) / this.view.fullWidth / this.zoom
              , m = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            o += h * this.view.offsetX,
            u = o + h * this.view.width,
            d -= m * this.view.offsetY,
            f = d - m * this.view.height
        }
        this.projectionMatrix.makeOrthographic(o, u, d, f, this.near, this.far, this.coordinateSystem),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.zoom = this.zoom,
        t.object.left = this.left,
        t.object.right = this.right,
        t.object.top = this.top,
        t.object.bottom = this.bottom,
        t.object.near = this.near,
        t.object.far = this.far,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t
    }
}
class LL extends UL {
    constructor() {
        super(new lw(-5,5,5,-5,.5,500)),
        this.isDirectionalLightShadow = !0
    }
}
class NL extends DL {
    constructor(e, t) {
        super(e, t),
        this.isDirectionalLight = !0,
        this.type = "DirectionalLight",
        this.position.copy(fi.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new fi,
        this.shadow = new LL
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e) {
        return super.copy(e),
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
class OL extends ir {
    constructor(e=[]) {
        super(),
        this.isArrayCamera = !0,
        this.cameras = e,
        this.index = 0
    }
}
function TS(n, e, t, r) {
    const s = PL(r);
    switch (t) {
    case HM:
        return n * e;
    case jM:
        return n * e;
    case WM:
        return n * e * 2;
    case XM:
        return n * e / s.components * s.byteLength;
    case o_:
        return n * e / s.components * s.byteLength;
    case qM:
        return n * e * 2 / s.components * s.byteLength;
    case l_:
        return n * e * 2 / s.components * s.byteLength;
    case GM:
        return n * e * 3 / s.components * s.byteLength;
    case yr:
        return n * e * 4 / s.components * s.byteLength;
    case c_:
        return n * e * 4 / s.components * s.byteLength;
    case ff:
    case hf:
        return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case pf:
    case mf:
        return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case Kg:
    case Jg:
        return Math.max(n, 16) * Math.max(e, 8) / 4;
    case $g:
    case Qg:
        return Math.max(n, 8) * Math.max(e, 8) / 2;
    case ev:
    case tv:
        return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case nv:
        return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case iv:
        return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case rv:
        return Math.floor((n + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case av:
        return Math.floor((n + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case sv:
        return Math.floor((n + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case ov:
        return Math.floor((n + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case lv:
        return Math.floor((n + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case cv:
        return Math.floor((n + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case uv:
        return Math.floor((n + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case dv:
        return Math.floor((n + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case fv:
        return Math.floor((n + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case hv:
        return Math.floor((n + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case pv:
        return Math.floor((n + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case mv:
        return Math.floor((n + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case gv:
        return Math.floor((n + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case gf:
    case vv:
    case _v:
        return Math.ceil(n / 4) * Math.ceil(e / 4) * 16;
    case YM:
    case yv:
        return Math.ceil(n / 4) * Math.ceil(e / 4) * 8;
    case xv:
    case bv:
        return Math.ceil(n / 4) * Math.ceil(e / 4) * 16
    }
    throw new Error(`Unable to determine texture byte length for ${t} format.`)
}
function PL(n) {
    switch (n) {
    case Ta:
    case FM:
        return {
            byteLength: 1,
            components: 1
        };
    case Qc:
    case BM:
    case hu:
        return {
            byteLength: 2,
            components: 1
        };
    case a_:
    case s_:
        return {
            byteLength: 2,
            components: 4
        };
    case no:
    case r_:
    case ya:
        return {
            byteLength: 4,
            components: 1
        };
    case VM:
        return {
            byteLength: 4,
            components: 3
        }
    }
    throw new Error(`Unknown texture type ${n}.`)
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
    detail: {
        revision: i_
    }
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = i_);
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
function cw() {
    let n = null
      , e = !1
      , t = null
      , r = null;
    function s(o, u) {
        t(o, u),
        r = n.requestAnimationFrame(s)
    }
    return {
        start: function() {
            e !== !0 && t !== null && (r = n.requestAnimationFrame(s),
            e = !0)
        },
        stop: function() {
            n.cancelAnimationFrame(r),
            e = !1
        },
        setAnimationLoop: function(o) {
            t = o
        },
        setContext: function(o) {
            n = o
        }
    }
}
function IL(n) {
    const e = new WeakMap;
    function t(d, f) {
        const h = d.array
          , m = d.usage
          , g = h.byteLength
          , _ = n.createBuffer();
        n.bindBuffer(f, _),
        n.bufferData(f, h, m),
        d.onUploadCallback();
        let x;
        if (h instanceof Float32Array)
            x = n.FLOAT;
        else if (h instanceof Uint16Array)
            d.isFloat16BufferAttribute ? x = n.HALF_FLOAT : x = n.UNSIGNED_SHORT;
        else if (h instanceof Int16Array)
            x = n.SHORT;
        else if (h instanceof Uint32Array)
            x = n.UNSIGNED_INT;
        else if (h instanceof Int32Array)
            x = n.INT;
        else if (h instanceof Int8Array)
            x = n.BYTE;
        else if (h instanceof Uint8Array)
            x = n.UNSIGNED_BYTE;
        else if (h instanceof Uint8ClampedArray)
            x = n.UNSIGNED_BYTE;
        else
            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + h);
        return {
            buffer: _,
            type: x,
            bytesPerElement: h.BYTES_PER_ELEMENT,
            version: d.version,
            size: g
        }
    }
    function r(d, f, h) {
        const m = f.array
          , g = f.updateRanges;
        if (n.bindBuffer(h, d),
        g.length === 0)
            n.bufferSubData(h, 0, m);
        else {
            g.sort( (x, E) => x.start - E.start);
            let _ = 0;
            for (let x = 1; x < g.length; x++) {
                const E = g[_]
                  , M = g[x];
                M.start <= E.start + E.count + 1 ? E.count = Math.max(E.count, M.start + M.count - E.start) : (++_,
                g[_] = M)
            }
            g.length = _ + 1;
            for (let x = 0, E = g.length; x < E; x++) {
                const M = g[x];
                n.bufferSubData(h, M.start * m.BYTES_PER_ELEMENT, m, M.start, M.count)
            }
            f.clearUpdateRanges()
        }
        f.onUploadCallback()
    }
    function s(d) {
        return d.isInterleavedBufferAttribute && (d = d.data),
        e.get(d)
    }
    function o(d) {
        d.isInterleavedBufferAttribute && (d = d.data);
        const f = e.get(d);
        f && (n.deleteBuffer(f.buffer),
        e.delete(d))
    }
    function u(d, f) {
        if (d.isInterleavedBufferAttribute && (d = d.data),
        d.isGLBufferAttribute) {
            const m = e.get(d);
            (!m || m.version < d.version) && e.set(d, {
                buffer: d.buffer,
                type: d.type,
                bytesPerElement: d.elementSize,
                version: d.version
            });
            return
        }
        const h = e.get(d);
        if (h === void 0)
            e.set(d, t(d, f));
        else if (h.version < d.version) {
            if (h.size !== d.array.byteLength)
                throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
            r(h.buffer, d, f),
            h.version = d.version
        }
    }
    return {
        get: s,
        remove: o,
        update: u
    }
}
var zL = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`
  , kL = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`
  , FL = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`
  , BL = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , VL = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`
  , HL = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`
  , GL = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`
  , jL = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`
  , WL = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`
  , XL = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`
  , qL = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`
  , YL = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`
  , ZL = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`
  , $L = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`
  , KL = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`
  , QL = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`
  , JL = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`
  , eN = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`
  , tN = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`
  , nN = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`
  , iN = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`
  , rN = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`
  , aN = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`
  , sN = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`
  , oN = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`
  , lN = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`
  , cN = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`
  , uN = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`
  , dN = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`
  , fN = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`
  , hN = "gl_FragColor = linearToOutputTexel( gl_FragColor );"
  , pN = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`
  , mN = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`
  , gN = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`
  , vN = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`
  , _N = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`
  , yN = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`
  , xN = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`
  , bN = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`
  , SN = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`
  , EN = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`
  , MN = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`
  , wN = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`
  , TN = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`
  , AN = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`
  , RN = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`
  , CN = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`
  , DN = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`
  , UN = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`
  , LN = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`
  , NN = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`
  , ON = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`
  , PN = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`
  , IN = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`
  , zN = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`
  , kN = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`
  , FN = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`
  , BN = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , VN = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , HN = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`
  , GN = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`
  , jN = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`
  , WN = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`
  , XN = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , qN = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`
  , YN = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`
  , ZN = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`
  , $N = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`
  , KN = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`
  , QN = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`
  , JN = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`
  , eO = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`
  , tO = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`
  , nO = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , iO = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , rO = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`
  , aO = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`
  , sO = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`
  , oO = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`
  , lO = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`
  , cO = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`
  , uO = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`
  , dO = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`
  , fO = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`
  , hO = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`
  , pO = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`
  , mO = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`
  , gO = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`
  , vO = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`
  , _O = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`
  , yO = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`
  , xO = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`
  , bO = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`
  , SO = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`
  , EO = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`
  , MO = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`
  , wO = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`
  , TO = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`
  , AO = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`
  , RO = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`
  , CO = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`
  , DO = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`
  , UO = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`
  , LO = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
  , NO = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
  , OO = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`
  , PO = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const IO = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`
  , zO = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , kO = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , FO = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , BO = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , VO = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , HO = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`
  , GO = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`
  , jO = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`
  , WO = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`
  , XO = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`
  , qO = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , YO = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , ZO = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , $O = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`
  , KO = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , QO = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , JO = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , e3 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

    
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`
  , t3 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , n3 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`
  , i3 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`
  , r3 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , a3 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , s3 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`
  , o3 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , l3 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , c3 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , u3 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`
  , d3 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , f3 = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , h3 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
  , p3 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , m3 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
  , Ht = {
    alphahash_fragment: zL,
    alphahash_pars_fragment: kL,
    alphamap_fragment: FL,
    alphamap_pars_fragment: BL,
    alphatest_fragment: VL,
    alphatest_pars_fragment: HL,
    aomap_fragment: GL,
    aomap_pars_fragment: jL,
    batching_pars_vertex: WL,
    batching_vertex: XL,
    begin_vertex: qL,
    beginnormal_vertex: YL,
    bsdfs: ZL,
    iridescence_fragment: $L,
    bumpmap_pars_fragment: KL,
    clipping_planes_fragment: QL,
    clipping_planes_pars_fragment: JL,
    clipping_planes_pars_vertex: eN,
    clipping_planes_vertex: tN,
    color_fragment: nN,
    color_pars_fragment: iN,
    color_pars_vertex: rN,
    color_vertex: aN,
    common: sN,
    cube_uv_reflection_fragment: oN,
    defaultnormal_vertex: lN,
    displacementmap_pars_vertex: cN,
    displacementmap_vertex: uN,
    emissivemap_fragment: dN,
    emissivemap_pars_fragment: fN,
    colorspace_fragment: hN,
    colorspace_pars_fragment: pN,
    envmap_fragment: mN,
    envmap_common_pars_fragment: gN,
    envmap_pars_fragment: vN,
    envmap_pars_vertex: _N,
    envmap_physical_pars_fragment: CN,
    envmap_vertex: yN,
    fog_vertex: xN,
    fog_pars_vertex: bN,
    fog_fragment: SN,
    fog_pars_fragment: EN,
    gradientmap_pars_fragment: MN,
    lightmap_pars_fragment: wN,
    lights_lambert_fragment: TN,
    lights_lambert_pars_fragment: AN,
    lights_pars_begin: RN,
    lights_toon_fragment: DN,
    lights_toon_pars_fragment: UN,
    lights_phong_fragment: LN,
    lights_phong_pars_fragment: NN,
    lights_physical_fragment: ON,
    lights_physical_pars_fragment: PN,
    lights_fragment_begin: IN,
    lights_fragment_maps: zN,
    lights_fragment_end: kN,
    logdepthbuf_fragment: FN,
    logdepthbuf_pars_fragment: BN,
    logdepthbuf_pars_vertex: VN,
    logdepthbuf_vertex: HN,
    map_fragment: GN,
    map_pars_fragment: jN,
    map_particle_fragment: WN,
    map_particle_pars_fragment: XN,
    metalnessmap_fragment: qN,
    metalnessmap_pars_fragment: YN,
    morphinstance_vertex: ZN,
    morphcolor_vertex: $N,
    morphnormal_vertex: KN,
    morphtarget_pars_vertex: QN,
    morphtarget_vertex: JN,
    normal_fragment_begin: eO,
    normal_fragment_maps: tO,
    normal_pars_fragment: nO,
    normal_pars_vertex: iO,
    normal_vertex: rO,
    normalmap_pars_fragment: aO,
    clearcoat_normal_fragment_begin: sO,
    clearcoat_normal_fragment_maps: oO,
    clearcoat_pars_fragment: lO,
    iridescence_pars_fragment: cO,
    opaque_fragment: uO,
    packing: dO,
    premultiplied_alpha_fragment: fO,
    project_vertex: hO,
    dithering_fragment: pO,
    dithering_pars_fragment: mO,
    roughnessmap_fragment: gO,
    roughnessmap_pars_fragment: vO,
    shadowmap_pars_fragment: _O,
    shadowmap_pars_vertex: yO,
    shadowmap_vertex: xO,
    shadowmask_pars_fragment: bO,
    skinbase_vertex: SO,
    skinning_pars_vertex: EO,
    skinning_vertex: MO,
    skinnormal_vertex: wO,
    specularmap_fragment: TO,
    specularmap_pars_fragment: AO,
    tonemapping_fragment: RO,
    tonemapping_pars_fragment: CO,
    transmission_fragment: DO,
    transmission_pars_fragment: UO,
    uv_pars_fragment: LO,
    uv_pars_vertex: NO,
    uv_vertex: OO,
    worldpos_vertex: PO,
    background_vert: IO,
    background_frag: zO,
    backgroundCube_vert: kO,
    backgroundCube_frag: FO,
    cube_vert: BO,
    cube_frag: VO,
    depth_vert: HO,
    depth_frag: GO,
    distanceRGBA_vert: jO,
    distanceRGBA_frag: WO,
    equirect_vert: XO,
    equirect_frag: qO,
    linedashed_vert: YO,
    linedashed_frag: ZO,
    meshbasic_vert: $O,
    meshbasic_frag: KO,
    meshlambert_vert: QO,
    meshlambert_frag: JO,
    meshmatcap_vert: e3,
    meshmatcap_frag: t3,
    meshnormal_vert: n3,
    meshnormal_frag: i3,
    meshphong_vert: r3,
    meshphong_frag: a3,
    meshphysical_vert: s3,
    meshphysical_frag: o3,
    meshtoon_vert: l3,
    meshtoon_frag: c3,
    points_vert: u3,
    points_frag: d3,
    shadow_vert: f3,
    shadow_frag: h3,
    sprite_vert: p3,
    sprite_frag: m3
}
  , et = {
    common: {
        diffuse: {
            value: new pn(16777215)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new Vt
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new Vt
        },
        alphaTest: {
            value: 0
        }
    },
    specularmap: {
        specularMap: {
            value: null
        },
        specularMapTransform: {
            value: new Vt
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        envMapRotation: {
            value: new Vt
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        ior: {
            value: 1.5
        },
        refractionRatio: {
            value: .98
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        },
        aoMapTransform: {
            value: new Vt
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        },
        lightMapTransform: {
            value: new Vt
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpMapTransform: {
            value: new Vt
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalMapTransform: {
            value: new Vt
        },
        normalScale: {
            value: new _n(1,1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementMapTransform: {
            value: new Vt
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        },
        emissiveMapTransform: {
            value: new Vt
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        },
        metalnessMapTransform: {
            value: new Vt
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        },
        roughnessMapTransform: {
            value: new Vt
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 25e-5
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2e3
        },
        fogColor: {
            value: new pn(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotLightMap: {
            value: []
        },
        spotShadowMap: {
            value: []
        },
        spotLightMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new pn(16777215)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new Vt
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new Vt
        }
    },
    sprite: {
        diffuse: {
            value: new pn(16777215)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new _n(.5,.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new Vt
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new Vt
        },
        alphaTest: {
            value: 0
        }
    }
}
  , Dr = {
    basic: {
        uniforms: xi([et.common, et.specularmap, et.envmap, et.aomap, et.lightmap, et.fog]),
        vertexShader: Ht.meshbasic_vert,
        fragmentShader: Ht.meshbasic_frag
    },
    lambert: {
        uniforms: xi([et.common, et.specularmap, et.envmap, et.aomap, et.lightmap, et.emissivemap, et.bumpmap, et.normalmap, et.displacementmap, et.fog, et.lights, {
            emissive: {
                value: new pn(0)
            }
        }]),
        vertexShader: Ht.meshlambert_vert,
        fragmentShader: Ht.meshlambert_frag
    },
    phong: {
        uniforms: xi([et.common, et.specularmap, et.envmap, et.aomap, et.lightmap, et.emissivemap, et.bumpmap, et.normalmap, et.displacementmap, et.fog, et.lights, {
            emissive: {
                value: new pn(0)
            },
            specular: {
                value: new pn(1118481)
            },
            shininess: {
                value: 30
            }
        }]),
        vertexShader: Ht.meshphong_vert,
        fragmentShader: Ht.meshphong_frag
    },
    standard: {
        uniforms: xi([et.common, et.envmap, et.aomap, et.lightmap, et.emissivemap, et.bumpmap, et.normalmap, et.displacementmap, et.roughnessmap, et.metalnessmap, et.fog, et.lights, {
            emissive: {
                value: new pn(0)
            },
            roughness: {
                value: 1
            },
            metalness: {
                value: 0
            },
            envMapIntensity: {
                value: 1
            }
        }]),
        vertexShader: Ht.meshphysical_vert,
        fragmentShader: Ht.meshphysical_frag
    },
    toon: {
        uniforms: xi([et.common, et.aomap, et.lightmap, et.emissivemap, et.bumpmap, et.normalmap, et.displacementmap, et.gradientmap, et.fog, et.lights, {
            emissive: {
                value: new pn(0)
            }
        }]),
        vertexShader: Ht.meshtoon_vert,
        fragmentShader: Ht.meshtoon_frag
    },
    matcap: {
        uniforms: xi([et.common, et.bumpmap, et.normalmap, et.displacementmap, et.fog, {
            matcap: {
                value: null
            }
        }]),
        vertexShader: Ht.meshmatcap_vert,
        fragmentShader: Ht.meshmatcap_frag
    },
    points: {
        uniforms: xi([et.points, et.fog]),
        vertexShader: Ht.points_vert,
        fragmentShader: Ht.points_frag
    },
    dashed: {
        uniforms: xi([et.common, et.fog, {
            scale: {
                value: 1
            },
            dashSize: {
                value: 1
            },
            totalSize: {
                value: 2
            }
        }]),
        vertexShader: Ht.linedashed_vert,
        fragmentShader: Ht.linedashed_frag
    },
    depth: {
        uniforms: xi([et.common, et.displacementmap]),
        vertexShader: Ht.depth_vert,
        fragmentShader: Ht.depth_frag
    },
    normal: {
        uniforms: xi([et.common, et.bumpmap, et.normalmap, et.displacementmap, {
            opacity: {
                value: 1
            }
        }]),
        vertexShader: Ht.meshnormal_vert,
        fragmentShader: Ht.meshnormal_frag
    },
    sprite: {
        uniforms: xi([et.sprite, et.fog]),
        vertexShader: Ht.sprite_vert,
        fragmentShader: Ht.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new Vt
            },
            t2D: {
                value: null
            },
            backgroundIntensity: {
                value: 1
            }
        },
        vertexShader: Ht.background_vert,
        fragmentShader: Ht.background_frag
    },
    backgroundCube: {
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            backgroundBlurriness: {
                value: 0
            },
            backgroundIntensity: {
                value: 1
            },
            backgroundRotation: {
                value: new Vt
            }
        },
        vertexShader: Ht.backgroundCube_vert,
        fragmentShader: Ht.backgroundCube_frag
    },
    cube: {
        uniforms: {
            tCube: {
                value: null
            },
            tFlip: {
                value: -1
            },
            opacity: {
                value: 1
            }
        },
        vertexShader: Ht.cube_vert,
        fragmentShader: Ht.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: Ht.equirect_vert,
        fragmentShader: Ht.equirect_frag
    },
    distanceRGBA: {
        uniforms: xi([et.common, et.displacementmap, {
            referencePosition: {
                value: new Ee
            },
            nearDistance: {
                value: 1
            },
            farDistance: {
                value: 1e3
            }
        }]),
        vertexShader: Ht.distanceRGBA_vert,
        fragmentShader: Ht.distanceRGBA_frag
    },
    shadow: {
        uniforms: xi([et.lights, et.fog, {
            color: {
                value: new pn(0)
            },
            opacity: {
                value: 1
            }
        }]),
        vertexShader: Ht.shadow_vert,
        fragmentShader: Ht.shadow_frag
    }
};
Dr.physical = {
    uniforms: xi([Dr.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatMapTransform: {
            value: new Vt
        },
        clearcoatNormalMap: {
            value: null
        },
        clearcoatNormalMapTransform: {
            value: new Vt
        },
        clearcoatNormalScale: {
            value: new _n(1,1)
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatRoughnessMapTransform: {
            value: new Vt
        },
        dispersion: {
            value: 0
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceMapTransform: {
            value: new Vt
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        iridescenceThicknessMapTransform: {
            value: new Vt
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new pn(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenColorMapTransform: {
            value: new Vt
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        sheenRoughnessMapTransform: {
            value: new Vt
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionMapTransform: {
            value: new Vt
        },
        transmissionSamplerSize: {
            value: new _n
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        thicknessMapTransform: {
            value: new Vt
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new pn(0)
        },
        specularColor: {
            value: new pn(1,1,1)
        },
        specularColorMap: {
            value: null
        },
        specularColorMapTransform: {
            value: new Vt
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularIntensityMapTransform: {
            value: new Vt
        },
        anisotropyVector: {
            value: new _n
        },
        anisotropyMap: {
            value: null
        },
        anisotropyMapTransform: {
            value: new Vt
        }
    }]),
    vertexShader: Ht.meshphysical_vert,
    fragmentShader: Ht.meshphysical_frag
};
const tf = {
    r: 0,
    b: 0,
    g: 0
}
  , Hs = new Aa
  , g3 = new Ln;
function v3(n, e, t, r, s, o, u) {
    const d = new pn(0);
    let f = o === !0 ? 0 : 1, h, m, g = null, _ = 0, x = null;
    function E(D) {
        let C = D.isScene === !0 ? D.background : null;
        return C && C.isTexture && (C = (D.backgroundBlurriness > 0 ? t : e).get(C)),
        C
    }
    function M(D) {
        let C = !1;
        const P = E(D);
        P === null ? y(d, f) : P && P.isColor && (y(P, 1),
        C = !0);
        const A = n.xr.getEnvironmentBlendMode();
        A === "additive" ? r.buffers.color.setClear(0, 0, 0, 1, u) : A === "alpha-blend" && r.buffers.color.setClear(0, 0, 0, 0, u),
        (n.autoClear || C) && (r.buffers.depth.setTest(!0),
        r.buffers.depth.setMask(!0),
        r.buffers.color.setMask(!0),
        n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil))
    }
    function b(D, C) {
        const P = E(C);
        P && (P.isCubeTexture || P.mapping === nh) ? (m === void 0 && (m = new ba(new _u(1,1,1),new ys({
            name: "BackgroundCubeMaterial",
            uniforms: _l(Dr.backgroundCube.uniforms),
            vertexShader: Dr.backgroundCube.vertexShader,
            fragmentShader: Dr.backgroundCube.fragmentShader,
            side: Ni,
            depthTest: !1,
            depthWrite: !1,
            fog: !1,
            allowOverride: !1
        })),
        m.geometry.deleteAttribute("normal"),
        m.geometry.deleteAttribute("uv"),
        m.onBeforeRender = function(A, F, z) {
            this.matrixWorld.copyPosition(z.matrixWorld)
        }
        ,
        Object.defineProperty(m.material, "envMap", {
            get: function() {
                return this.uniforms.envMap.value
            }
        }),
        s.update(m)),
        Hs.copy(C.backgroundRotation),
        Hs.x *= -1,
        Hs.y *= -1,
        Hs.z *= -1,
        P.isCubeTexture && P.isRenderTargetTexture === !1 && (Hs.y *= -1,
        Hs.z *= -1),
        m.material.uniforms.envMap.value = P,
        m.material.uniforms.flipEnvMap.value = P.isCubeTexture && P.isRenderTargetTexture === !1 ? -1 : 1,
        m.material.uniforms.backgroundBlurriness.value = C.backgroundBlurriness,
        m.material.uniforms.backgroundIntensity.value = C.backgroundIntensity,
        m.material.uniforms.backgroundRotation.value.setFromMatrix4(g3.makeRotationFromEuler(Hs)),
        m.material.toneMapped = fn.getTransfer(P.colorSpace) !== Sn,
        (g !== P || _ !== P.version || x !== n.toneMapping) && (m.material.needsUpdate = !0,
        g = P,
        _ = P.version,
        x = n.toneMapping),
        m.layers.enableAll(),
        D.unshift(m, m.geometry, m.material, 0, 0, null)) : P && P.isTexture && (h === void 0 && (h = new ba(new rh(2,2),new ys({
            name: "BackgroundMaterial",
            uniforms: _l(Dr.background.uniforms),
            vertexShader: Dr.background.vertexShader,
            fragmentShader: Dr.background.fragmentShader,
            side: _s,
            depthTest: !1,
            depthWrite: !1,
            fog: !1,
            allowOverride: !1
        })),
        h.geometry.deleteAttribute("normal"),
        Object.defineProperty(h.material, "map", {
            get: function() {
                return this.uniforms.t2D.value
            }
        }),
        s.update(h)),
        h.material.uniforms.t2D.value = P,
        h.material.uniforms.backgroundIntensity.value = C.backgroundIntensity,
        h.material.toneMapped = fn.getTransfer(P.colorSpace) !== Sn,
        P.matrixAutoUpdate === !0 && P.updateMatrix(),
        h.material.uniforms.uvTransform.value.copy(P.matrix),
        (g !== P || _ !== P.version || x !== n.toneMapping) && (h.material.needsUpdate = !0,
        g = P,
        _ = P.version,
        x = n.toneMapping),
        h.layers.enableAll(),
        D.unshift(h, h.geometry, h.material, 0, 0, null))
    }
    function y(D, C) {
        D.getRGB(tf, rw(n)),
        r.buffers.color.setClear(tf.r, tf.g, tf.b, C, u)
    }
    function T() {
        m !== void 0 && (m.geometry.dispose(),
        m.material.dispose(),
        m = void 0),
        h !== void 0 && (h.geometry.dispose(),
        h.material.dispose(),
        h = void 0)
    }
    return {
        getClearColor: function() {
            return d
        },
        setClearColor: function(D, C=1) {
            d.set(D),
            f = C,
            y(d, f)
        },
        getClearAlpha: function() {
            return f
        },
        setClearAlpha: function(D) {
            f = D,
            y(d, f)
        },
        render: M,
        addToRenderList: b,
        dispose: T
    }
}
function _3(n, e) {
    const t = n.getParameter(n.MAX_VERTEX_ATTRIBS)
      , r = {}
      , s = _(null);
    let o = s
      , u = !1;
    function d(R, V, Q, X, oe) {
        let le = !1;
        const O = g(X, Q, V);
        o !== O && (o = O,
        h(o.object)),
        le = x(R, X, Q, oe),
        le && E(R, X, Q, oe),
        oe !== null && e.update(oe, n.ELEMENT_ARRAY_BUFFER),
        (le || u) && (u = !1,
        C(R, V, Q, X),
        oe !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.get(oe).buffer))
    }
    function f() {
        return n.createVertexArray()
    }
    function h(R) {
        return n.bindVertexArray(R)
    }
    function m(R) {
        return n.deleteVertexArray(R)
    }
    function g(R, V, Q) {
        const X = Q.wireframe === !0;
        let oe = r[R.id];
        oe === void 0 && (oe = {},
        r[R.id] = oe);
        let le = oe[V.id];
        le === void 0 && (le = {},
        oe[V.id] = le);
        let O = le[X];
        return O === void 0 && (O = _(f()),
        le[X] = O),
        O
    }
    function _(R) {
        const V = []
          , Q = []
          , X = [];
        for (let oe = 0; oe < t; oe++)
            V[oe] = 0,
            Q[oe] = 0,
            X[oe] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: V,
            enabledAttributes: Q,
            attributeDivisors: X,
            object: R,
            attributes: {},
            index: null
        }
    }
    function x(R, V, Q, X) {
        const oe = o.attributes
          , le = V.attributes;
        let O = 0;
        const W = Q.getAttributes();
        for (const H in W)
            if (W[H].location >= 0) {
                const k = oe[H];
                let ee = le[H];
                if (ee === void 0 && (H === "instanceMatrix" && R.instanceMatrix && (ee = R.instanceMatrix),
                H === "instanceColor" && R.instanceColor && (ee = R.instanceColor)),
                k === void 0 || k.attribute !== ee || ee && k.data !== ee.data)
                    return !0;
                O++
            }
        return o.attributesNum !== O || o.index !== X
    }
    function E(R, V, Q, X) {
        const oe = {}
          , le = V.attributes;
        let O = 0;
        const W = Q.getAttributes();
        for (const H in W)
            if (W[H].location >= 0) {
                let k = le[H];
                k === void 0 && (H === "instanceMatrix" && R.instanceMatrix && (k = R.instanceMatrix),
                H === "instanceColor" && R.instanceColor && (k = R.instanceColor));
                const ee = {};
                ee.attribute = k,
                k && k.data && (ee.data = k.data),
                oe[H] = ee,
                O++
            }
        o.attributes = oe,
        o.attributesNum = O,
        o.index = X
    }
    function M() {
        const R = o.newAttributes;
        for (let V = 0, Q = R.length; V < Q; V++)
            R[V] = 0
    }
    function b(R) {
        y(R, 0)
    }
    function y(R, V) {
        const Q = o.newAttributes
          , X = o.enabledAttributes
          , oe = o.attributeDivisors;
        Q[R] = 1,
        X[R] === 0 && (n.enableVertexAttribArray(R),
        X[R] = 1),
        oe[R] !== V && (n.vertexAttribDivisor(R, V),
        oe[R] = V)
    }
    function T() {
        const R = o.newAttributes
          , V = o.enabledAttributes;
        for (let Q = 0, X = V.length; Q < X; Q++)
            V[Q] !== R[Q] && (n.disableVertexAttribArray(Q),
            V[Q] = 0)
    }
    function D(R, V, Q, X, oe, le, O) {
        O === !0 ? n.vertexAttribIPointer(R, V, Q, oe, le) : n.vertexAttribPointer(R, V, Q, X, oe, le)
    }
    function C(R, V, Q, X) {
        M();
        const oe = X.attributes
          , le = Q.getAttributes()
          , O = V.defaultAttributeValues;
        for (const W in le) {
            const H = le[W];
            if (H.location >= 0) {
                let Me = oe[W];
                if (Me === void 0 && (W === "instanceMatrix" && R.instanceMatrix && (Me = R.instanceMatrix),
                W === "instanceColor" && R.instanceColor && (Me = R.instanceColor)),
                Me !== void 0) {
                    const k = Me.normalized
                      , ee = Me.itemSize
                      , ge = e.get(Me);
                    if (ge === void 0)
                        continue;
                    const pe = ge.buffer
                      , te = ge.type
                      , we = ge.bytesPerElement
                      , Se = te === n.INT || te === n.UNSIGNED_INT || Me.gpuType === r_;
                    if (Me.isInterleavedBufferAttribute) {
                        const De = Me.data
                          , Ve = De.stride
                          , _t = Me.offset;
                        if (De.isInstancedInterleavedBuffer) {
                            for (let He = 0; He < H.locationSize; He++)
                                y(H.location + He, De.meshPerAttribute);
                            R.isInstancedMesh !== !0 && X._maxInstanceCount === void 0 && (X._maxInstanceCount = De.meshPerAttribute * De.count)
                        } else
                            for (let He = 0; He < H.locationSize; He++)
                                b(H.location + He);
                        n.bindBuffer(n.ARRAY_BUFFER, pe);
                        for (let He = 0; He < H.locationSize; He++)
                            D(H.location + He, ee / H.locationSize, te, k, Ve * we, (_t + ee / H.locationSize * He) * we, Se)
                    } else {
                        if (Me.isInstancedBufferAttribute) {
                            for (let De = 0; De < H.locationSize; De++)
                                y(H.location + De, Me.meshPerAttribute);
                            R.isInstancedMesh !== !0 && X._maxInstanceCount === void 0 && (X._maxInstanceCount = Me.meshPerAttribute * Me.count)
                        } else
                            for (let De = 0; De < H.locationSize; De++)
                                b(H.location + De);
                        n.bindBuffer(n.ARRAY_BUFFER, pe);
                        for (let De = 0; De < H.locationSize; De++)
                            D(H.location + De, ee / H.locationSize, te, k, ee * we, ee / H.locationSize * De * we, Se)
                    }
                } else if (O !== void 0) {
                    const k = O[W];
                    if (k !== void 0)
                        switch (k.length) {
                        case 2:
                            n.vertexAttrib2fv(H.location, k);
                            break;
                        case 3:
                            n.vertexAttrib3fv(H.location, k);
                            break;
                        case 4:
                            n.vertexAttrib4fv(H.location, k);
                            break;
                        default:
                            n.vertexAttrib1fv(H.location, k)
                        }
                }
            }
        }
        T()
    }
    function P() {
        z();
        for (const R in r) {
            const V = r[R];
            for (const Q in V) {
                const X = V[Q];
                for (const oe in X)
                    m(X[oe].object),
                    delete X[oe];
                delete V[Q]
            }
            delete r[R]
        }
    }
    function A(R) {
        if (r[R.id] === void 0)
            return;
        const V = r[R.id];
        for (const Q in V) {
            const X = V[Q];
            for (const oe in X)
                m(X[oe].object),
                delete X[oe];
            delete V[Q]
        }
        delete r[R.id]
    }
    function F(R) {
        for (const V in r) {
            const Q = r[V];
            if (Q[R.id] === void 0)
                continue;
            const X = Q[R.id];
            for (const oe in X)
                m(X[oe].object),
                delete X[oe];
            delete Q[R.id]
        }
    }
    function z() {
        U(),
        u = !0,
        o !== s && (o = s,
        h(o.object))
    }
    function U() {
        s.geometry = null,
        s.program = null,
        s.wireframe = !1
    }
    return {
        setup: d,
        reset: z,
        resetDefaultState: U,
        dispose: P,
        releaseStatesOfGeometry: A,
        releaseStatesOfProgram: F,
        initAttributes: M,
        enableAttribute: b,
        disableUnusedAttributes: T
    }
}
function y3(n, e, t) {
    let r;
    function s(h) {
        r = h
    }
    function o(h, m) {
        n.drawArrays(r, h, m),
        t.update(m, r, 1)
    }
    function u(h, m, g) {
        g !== 0 && (n.drawArraysInstanced(r, h, m, g),
        t.update(m, r, g))
    }
    function d(h, m, g) {
        if (g === 0)
            return;
        e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(r, h, 0, m, 0, g);
        let x = 0;
        for (let E = 0; E < g; E++)
            x += m[E];
        t.update(x, r, 1)
    }
    function f(h, m, g, _) {
        if (g === 0)
            return;
        const x = e.get("WEBGL_multi_draw");
        if (x === null)
            for (let E = 0; E < h.length; E++)
                u(h[E], m[E], _[E]);
        else {
            x.multiDrawArraysInstancedWEBGL(r, h, 0, m, 0, _, 0, g);
            let E = 0;
            for (let M = 0; M < g; M++)
                E += m[M] * _[M];
            t.update(E, r, 1)
        }
    }
    this.setMode = s,
    this.render = o,
    this.renderInstances = u,
    this.renderMultiDraw = d,
    this.renderMultiDrawInstances = f
}
function x3(n, e, t, r) {
    let s;
    function o() {
        if (s !== void 0)
            return s;
        if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const F = e.get("EXT_texture_filter_anisotropic");
            s = n.getParameter(F.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else
            s = 0;
        return s
    }
    function u(F) {
        return !(F !== yr && r.convert(F) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_FORMAT))
    }
    function d(F) {
        const z = F === hu && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
        return !(F !== Ta && r.convert(F) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_TYPE) && F !== ya && !z)
    }
    function f(F) {
        if (F === "highp") {
            if (n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision > 0)
                return "highp";
            F = "mediump"
        }
        return F === "mediump" && n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
    }
    let h = t.precision !== void 0 ? t.precision : "highp";
    const m = f(h);
    m !== h && (console.warn("THREE.WebGLRenderer:", h, "not supported, using", m, "instead."),
    h = m);
    const g = t.logarithmicDepthBuffer === !0
      , _ = t.reverseDepthBuffer === !0 && e.has("EXT_clip_control")
      , x = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)
      , E = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
      , M = n.getParameter(n.MAX_TEXTURE_SIZE)
      , b = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE)
      , y = n.getParameter(n.MAX_VERTEX_ATTRIBS)
      , T = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS)
      , D = n.getParameter(n.MAX_VARYING_VECTORS)
      , C = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS)
      , P = E > 0
      , A = n.getParameter(n.MAX_SAMPLES);
    return {
        isWebGL2: !0,
        getMaxAnisotropy: o,
        getMaxPrecision: f,
        textureFormatReadable: u,
        textureTypeReadable: d,
        precision: h,
        logarithmicDepthBuffer: g,
        reverseDepthBuffer: _,
        maxTextures: x,
        maxVertexTextures: E,
        maxTextureSize: M,
        maxCubemapSize: b,
        maxAttributes: y,
        maxVertexUniforms: T,
        maxVaryings: D,
        maxFragmentUniforms: C,
        vertexTextures: P,
        maxSamples: A
    }
}
function b3(n) {
    const e = this;
    let t = null
      , r = 0
      , s = !1
      , o = !1;
    const u = new Ws
      , d = new Vt
      , f = {
        value: null,
        needsUpdate: !1
    };
    this.uniform = f,
    this.numPlanes = 0,
    this.numIntersection = 0,
    this.init = function(g, _) {
        const x = g.length !== 0 || _ || r !== 0 || s;
        return s = _,
        r = g.length,
        x
    }
    ,
    this.beginShadows = function() {
        o = !0,
        m(null)
    }
    ,
    this.endShadows = function() {
        o = !1
    }
    ,
    this.setGlobalState = function(g, _) {
        t = m(g, _, 0)
    }
    ,
    this.setState = function(g, _, x) {
        const E = g.clippingPlanes
          , M = g.clipIntersection
          , b = g.clipShadows
          , y = n.get(g);
        if (!s || E === null || E.length === 0 || o && !b)
            o ? m(null) : h();
        else {
            const T = o ? 0 : r
              , D = T * 4;
            let C = y.clippingState || null;
            f.value = C,
            C = m(E, _, D, x);
            for (let P = 0; P !== D; ++P)
                C[P] = t[P];
            y.clippingState = C,
            this.numIntersection = M ? this.numPlanes : 0,
            this.numPlanes += T
        }
    }
    ;
    function h() {
        f.value !== t && (f.value = t,
        f.needsUpdate = r > 0),
        e.numPlanes = r,
        e.numIntersection = 0
    }
    function m(g, _, x, E) {
        const M = g !== null ? g.length : 0;
        let b = null;
        if (M !== 0) {
            if (b = f.value,
            E !== !0 || b === null) {
                const y = x + M * 4
                  , T = _.matrixWorldInverse;
                d.getNormalMatrix(T),
                (b === null || b.length < y) && (b = new Float32Array(y));
                for (let D = 0, C = x; D !== M; ++D,
                C += 4)
                    u.copy(g[D]).applyMatrix4(T, d),
                    u.normal.toArray(b, C),
                    b[C + 3] = u.constant
            }
            f.value = b,
            f.needsUpdate = !0
        }
        return e.numPlanes = M,
        e.numIntersection = 0,
        b
    }
}
function S3(n) {
    let e = new WeakMap;
    function t(u, d) {
        return d === Xg ? u.mapping = ml : d === qg && (u.mapping = gl),
        u
    }
    function r(u) {
        if (u && u.isTexture) {
            const d = u.mapping;
            if (d === Xg || d === qg)
                if (e.has(u)) {
                    const f = e.get(u).texture;
                    return t(f, u.mapping)
                } else {
                    const f = u.image;
                    if (f && f.height > 0) {
                        const h = new yL(f.height);
                        return h.fromEquirectangularTexture(n, u),
                        e.set(u, h),
                        u.addEventListener("dispose", s),
                        t(h.texture, u.mapping)
                    } else
                        return null
                }
        }
        return u
    }
    function s(u) {
        const d = u.target;
        d.removeEventListener("dispose", s);
        const f = e.get(d);
        f !== void 0 && (e.delete(d),
        f.dispose())
    }
    function o() {
        e = new WeakMap
    }
    return {
        get: r,
        dispose: o
    }
}
const ll = 4
  , AS = [.125, .215, .35, .446, .526, .582]
  , Zs = 20
  , lg = new lw
  , RS = new pn;
let cg = null
  , ug = 0
  , dg = 0
  , fg = !1;
const Xs = (1 + Math.sqrt(5)) / 2
  , el = 1 / Xs
  , CS = [new Ee(-Xs,el,0), new Ee(Xs,el,0), new Ee(-el,0,Xs), new Ee(el,0,Xs), new Ee(0,Xs,-el), new Ee(0,Xs,el), new Ee(-1,1,-1), new Ee(1,1,-1), new Ee(-1,1,1), new Ee(1,1,1)]
  , E3 = new Ee;
class DS {
    constructor(e) {
        this._renderer = e,
        this._pingPongRenderTarget = null,
        this._lodMax = 0,
        this._cubeSize = 0,
        this._lodPlanes = [],
        this._sizeLods = [],
        this._sigmas = [],
        this._blurMaterial = null,
        this._cubemapMaterial = null,
        this._equirectMaterial = null,
        this._compileMaterial(this._blurMaterial)
    }
    fromScene(e, t=0, r=.1, s=100, o={}) {
        const {size: u=256, position: d=E3} = o;
        cg = this._renderer.getRenderTarget(),
        ug = this._renderer.getActiveCubeFace(),
        dg = this._renderer.getActiveMipmapLevel(),
        fg = this._renderer.xr.enabled,
        this._renderer.xr.enabled = !1,
        this._setSize(u);
        const f = this._allocateTargets();
        return f.depthBuffer = !0,
        this._sceneToCubeUV(e, r, s, f, d),
        t > 0 && this._blur(f, 0, 0, t),
        this._applyPMREM(f),
        this._cleanup(f),
        f
    }
    fromEquirectangular(e, t=null) {
        return this._fromTexture(e, t)
    }
    fromCubemap(e, t=null) {
        return this._fromTexture(e, t)
    }
    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = NS(),
        this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = LS(),
        this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(),
        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
        this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)),
        this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(),
        this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose()
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(cg, ug, dg),
        this._renderer.xr.enabled = fg,
        e.scissorTest = !1,
        nf(e, 0, 0, e.width, e.height)
    }
    _fromTexture(e, t) {
        e.mapping === ml || e.mapping === gl ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
        cg = this._renderer.getRenderTarget(),
        ug = this._renderer.getActiveCubeFace(),
        dg = this._renderer.getActiveMipmapLevel(),
        fg = this._renderer.xr.enabled,
        this._renderer.xr.enabled = !1;
        const r = t || this._allocateTargets();
        return this._textureToCubeUV(e, r),
        this._applyPMREM(r),
        this._cleanup(r),
        r
    }
    _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112)
          , t = 4 * this._cubeSize
          , r = {
            magFilter: Ur,
            minFilter: Ur,
            generateMipmaps: !1,
            type: hu,
            format: yr,
            colorSpace: vl,
            depthBuffer: !1
        }
          , s = US(e, t, r);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
            this._pingPongRenderTarget !== null && this._dispose(),
            this._pingPongRenderTarget = US(e, t, r);
            const {_lodMax: o} = this;
            ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = M3(o)),
            this._blurMaterial = w3(o, e, t)
        }
        return s
    }
    _compileMaterial(e) {
        const t = new ba(this._lodPlanes[0],e);
        this._renderer.compile(t, lg)
    }
    _sceneToCubeUV(e, t, r, s, o) {
        const f = new ir(90,1,t,r)
          , h = [1, -1, 1, 1, 1, 1]
          , m = [1, 1, 1, -1, -1, -1]
          , g = this._renderer
          , _ = g.autoClear
          , x = g.toneMapping;
        g.getClearColor(RS),
        g.toneMapping = gs,
        g.autoClear = !1;
        const E = new tw({
            name: "PMREM.Background",
            side: Ni,
            depthWrite: !1,
            depthTest: !1
        })
          , M = new ba(new _u,E);
        let b = !1;
        const y = e.background;
        y ? y.isColor && (E.color.copy(y),
        e.background = null,
        b = !0) : (E.color.copy(RS),
        b = !0);
        for (let T = 0; T < 6; T++) {
            const D = T % 3;
            D === 0 ? (f.up.set(0, h[T], 0),
            f.position.set(o.x, o.y, o.z),
            f.lookAt(o.x + m[T], o.y, o.z)) : D === 1 ? (f.up.set(0, 0, h[T]),
            f.position.set(o.x, o.y, o.z),
            f.lookAt(o.x, o.y + m[T], o.z)) : (f.up.set(0, h[T], 0),
            f.position.set(o.x, o.y, o.z),
            f.lookAt(o.x, o.y, o.z + m[T]));
            const C = this._cubeSize;
            nf(s, D * C, T > 2 ? C : 0, C, C),
            g.setRenderTarget(s),
            b && g.render(M, f),
            g.render(e, f)
        }
        M.geometry.dispose(),
        M.material.dispose(),
        g.toneMapping = x,
        g.autoClear = _,
        e.background = y
    }
    _textureToCubeUV(e, t) {
        const r = this._renderer
          , s = e.mapping === ml || e.mapping === gl;
        s ? (this._cubemapMaterial === null && (this._cubemapMaterial = NS()),
        this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = LS());
        const o = s ? this._cubemapMaterial : this._equirectMaterial
          , u = new ba(this._lodPlanes[0],o)
          , d = o.uniforms;
        d.envMap.value = e;
        const f = this._cubeSize;
        nf(t, 0, 0, 3 * f, 2 * f),
        r.setRenderTarget(t),
        r.render(u, lg)
    }
    _applyPMREM(e) {
        const t = this._renderer
          , r = t.autoClear;
        t.autoClear = !1;
        const s = this._lodPlanes.length;
        for (let o = 1; o < s; o++) {
            const u = Math.sqrt(this._sigmas[o] * this._sigmas[o] - this._sigmas[o - 1] * this._sigmas[o - 1])
              , d = CS[(s - o - 1) % CS.length];
            this._blur(e, o - 1, o, u, d)
        }
        t.autoClear = r
    }
    _blur(e, t, r, s, o) {
        const u = this._pingPongRenderTarget;
        this._halfBlur(e, u, t, r, s, "latitudinal", o),
        this._halfBlur(u, e, r, r, s, "longitudinal", o)
    }
    _halfBlur(e, t, r, s, o, u, d) {
        const f = this._renderer
          , h = this._blurMaterial;
        u !== "latitudinal" && u !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const m = 3
          , g = new ba(this._lodPlanes[s],h)
          , _ = h.uniforms
          , x = this._sizeLods[r] - 1
          , E = isFinite(o) ? Math.PI / (2 * x) : 2 * Math.PI / (2 * Zs - 1)
          , M = o / E
          , b = isFinite(o) ? 1 + Math.floor(m * M) : Zs;
        b > Zs && console.warn(`sigmaRadians, ${o}, is too large and will clip, as it requested ${b} samples when the maximum is set to ${Zs}`);
        const y = [];
        let T = 0;
        for (let F = 0; F < Zs; ++F) {
            const z = F / M
              , U = Math.exp(-z * z / 2);
            y.push(U),
            F === 0 ? T += U : F < b && (T += 2 * U)
        }
        for (let F = 0; F < y.length; F++)
            y[F] = y[F] / T;
        _.envMap.value = e.texture,
        _.samples.value = b,
        _.weights.value = y,
        _.latitudinal.value = u === "latitudinal",
        d && (_.poleAxis.value = d);
        const {_lodMax: D} = this;
        _.dTheta.value = E,
        _.mipInt.value = D - r;
        const C = this._sizeLods[s]
          , P = 3 * C * (s > D - ll ? s - D + ll : 0)
          , A = 4 * (this._cubeSize - C);
        nf(t, P, A, 3 * C, 2 * C),
        f.setRenderTarget(t),
        f.render(g, lg)
    }
}
function M3(n) {
    const e = []
      , t = []
      , r = [];
    let s = n;
    const o = n - ll + 1 + AS.length;
    for (let u = 0; u < o; u++) {
        const d = Math.pow(2, s);
        t.push(d);
        let f = 1 / d;
        u > n - ll ? f = AS[u - n + ll - 1] : u === 0 && (f = 0),
        r.push(f);
        const h = 1 / (d - 2)
          , m = -h
          , g = 1 + h
          , _ = [m, m, g, m, g, g, m, m, g, g, m, g]
          , x = 6
          , E = 6
          , M = 3
          , b = 2
          , y = 1
          , T = new Float32Array(M * E * x)
          , D = new Float32Array(b * E * x)
          , C = new Float32Array(y * E * x);
        for (let A = 0; A < x; A++) {
            const F = A % 3 * 2 / 3 - 1
              , z = A > 2 ? 0 : -1
              , U = [F, z, 0, F + 2 / 3, z, 0, F + 2 / 3, z + 1, 0, F, z, 0, F + 2 / 3, z + 1, 0, F, z + 1, 0];
            T.set(U, M * E * A),
            D.set(_, b * E * A);
            const R = [A, A, A, A, A, A];
            C.set(R, y * E * A)
        }
        const P = new Ir;
        P.setAttribute("position", new ar(T,M)),
        P.setAttribute("uv", new ar(D,b)),
        P.setAttribute("faceIndex", new ar(C,y)),
        e.push(P),
        s > ll && s--
    }
    return {
        lodPlanes: e,
        sizeLods: t,
        sigmas: r
    }
}
function US(n, e, t) {
    const r = new io(n,e,t);
    return r.texture.mapping = nh,
    r.texture.name = "PMREM.cubeUv",
    r.scissorTest = !0,
    r
}
function nf(n, e, t, r, s) {
    n.viewport.set(e, t, r, s),
    n.scissor.set(e, t, r, s)
}
function w3(n, e, t) {
    const r = new Float32Array(Zs)
      , s = new Ee(0,1,0);
    return new ys({
        name: "SphericalGaussianBlur",
        defines: {
            n: Zs,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${n}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: r
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: s
            }
        },
        vertexShader: h_(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: ms,
        depthTest: !1,
        depthWrite: !1
    })
}
function LS() {
    return new ys({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: h_(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: ms,
        depthTest: !1,
        depthWrite: !1
    })
}
function NS() {
    return new ys({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: h_(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: ms,
        depthTest: !1,
        depthWrite: !1
    })
}
function h_() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}
function T3(n) {
    let e = new WeakMap
      , t = null;
    function r(d) {
        if (d && d.isTexture) {
            const f = d.mapping
              , h = f === Xg || f === qg
              , m = f === ml || f === gl;
            if (h || m) {
                let g = e.get(d);
                const _ = g !== void 0 ? g.texture.pmremVersion : 0;
                if (d.isRenderTargetTexture && d.pmremVersion !== _)
                    return t === null && (t = new DS(n)),
                    g = h ? t.fromEquirectangular(d, g) : t.fromCubemap(d, g),
                    g.texture.pmremVersion = d.pmremVersion,
                    e.set(d, g),
                    g.texture;
                if (g !== void 0)
                    return g.texture;
                {
                    const x = d.image;
                    return h && x && x.height > 0 || m && x && s(x) ? (t === null && (t = new DS(n)),
                    g = h ? t.fromEquirectangular(d) : t.fromCubemap(d),
                    g.texture.pmremVersion = d.pmremVersion,
                    e.set(d, g),
                    d.addEventListener("dispose", o),
                    g.texture) : null
                }
            }
        }
        return d
    }
    function s(d) {
        let f = 0;
        const h = 6;
        for (let m = 0; m < h; m++)
            d[m] !== void 0 && f++;
        return f === h
    }
    function o(d) {
        const f = d.target;
        f.removeEventListener("dispose", o);
        const h = e.get(f);
        h !== void 0 && (e.delete(f),
        h.dispose())
    }
    function u() {
        e = new WeakMap,
        t !== null && (t.dispose(),
        t = null)
    }
    return {
        get: r,
        dispose: u
    }
}
function A3(n) {
    const e = {};
    function t(r) {
        if (e[r] !== void 0)
            return e[r];
        let s;
        switch (r) {
        case "WEBGL_depth_texture":
            s = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
        case "EXT_texture_filter_anisotropic":
            s = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            s = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            s = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        default:
            s = n.getExtension(r)
        }
        return e[r] = s,
        s
    }
    return {
        has: function(r) {
            return t(r) !== null
        },
        init: function() {
            t("EXT_color_buffer_float"),
            t("WEBGL_clip_cull_distance"),
            t("OES_texture_float_linear"),
            t("EXT_color_buffer_half_float"),
            t("WEBGL_multisampled_render_to_texture"),
            t("WEBGL_render_shared_exponent")
        },
        get: function(r) {
            const s = t(r);
            return s === null && vf("THREE.WebGLRenderer: " + r + " extension not supported."),
            s
        }
    }
}
function R3(n, e, t, r) {
    const s = {}
      , o = new WeakMap;
    function u(g) {
        const _ = g.target;
        _.index !== null && e.remove(_.index);
        for (const E in _.attributes)
            e.remove(_.attributes[E]);
        _.removeEventListener("dispose", u),
        delete s[_.id];
        const x = o.get(_);
        x && (e.remove(x),
        o.delete(_)),
        r.releaseStatesOfGeometry(_),
        _.isInstancedBufferGeometry === !0 && delete _._maxInstanceCount,
        t.memory.geometries--
    }
    function d(g, _) {
        return s[_.id] === !0 || (_.addEventListener("dispose", u),
        s[_.id] = !0,
        t.memory.geometries++),
        _
    }
    function f(g) {
        const _ = g.attributes;
        for (const x in _)
            e.update(_[x], n.ARRAY_BUFFER)
    }
    function h(g) {
        const _ = []
          , x = g.index
          , E = g.attributes.position;
        let M = 0;
        if (x !== null) {
            const T = x.array;
            M = x.version;
            for (let D = 0, C = T.length; D < C; D += 3) {
                const P = T[D + 0]
                  , A = T[D + 1]
                  , F = T[D + 2];
                _.push(P, A, A, F, F, P)
            }
        } else if (E !== void 0) {
            const T = E.array;
            M = E.version;
            for (let D = 0, C = T.length / 3 - 1; D < C; D += 3) {
                const P = D + 0
                  , A = D + 1
                  , F = D + 2;
                _.push(P, A, A, F, F, P)
            }
        } else
            return;
        const b = new ($M(_) ? iw : nw)(_,1);
        b.version = M;
        const y = o.get(g);
        y && e.remove(y),
        o.set(g, b)
    }
    function m(g) {
        const _ = o.get(g);
        if (_) {
            const x = g.index;
            x !== null && _.version < x.version && h(g)
        } else
            h(g);
        return o.get(g)
    }
    return {
        get: d,
        update: f,
        getWireframeAttribute: m
    }
}
function C3(n, e, t) {
    let r;
    function s(_) {
        r = _
    }
    let o, u;
    function d(_) {
        o = _.type,
        u = _.bytesPerElement
    }
    function f(_, x) {
        n.drawElements(r, x, o, _ * u),
        t.update(x, r, 1)
    }
    function h(_, x, E) {
        E !== 0 && (n.drawElementsInstanced(r, x, o, _ * u, E),
        t.update(x, r, E))
    }
    function m(_, x, E) {
        if (E === 0)
            return;
        e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(r, x, 0, o, _, 0, E);
        let b = 0;
        for (let y = 0; y < E; y++)
            b += x[y];
        t.update(b, r, 1)
    }
    function g(_, x, E, M) {
        if (E === 0)
            return;
        const b = e.get("WEBGL_multi_draw");
        if (b === null)
            for (let y = 0; y < _.length; y++)
                h(_[y] / u, x[y], M[y]);
        else {
            b.multiDrawElementsInstancedWEBGL(r, x, 0, o, _, 0, M, 0, E);
            let y = 0;
            for (let T = 0; T < E; T++)
                y += x[T] * M[T];
            t.update(y, r, 1)
        }
    }
    this.setMode = s,
    this.setIndex = d,
    this.render = f,
    this.renderInstances = h,
    this.renderMultiDraw = m,
    this.renderMultiDrawInstances = g
}
function D3(n) {
    const e = {
        geometries: 0,
        textures: 0
    }
      , t = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function r(o, u, d) {
        switch (t.calls++,
        u) {
        case n.TRIANGLES:
            t.triangles += d * (o / 3);
            break;
        case n.LINES:
            t.lines += d * (o / 2);
            break;
        case n.LINE_STRIP:
            t.lines += d * (o - 1);
            break;
        case n.LINE_LOOP:
            t.lines += d * o;
            break;
        case n.POINTS:
            t.points += d * o;
            break;
        default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", u);
            break
        }
    }
    function s() {
        t.calls = 0,
        t.triangles = 0,
        t.points = 0,
        t.lines = 0
    }
    return {
        memory: e,
        render: t,
        programs: null,
        autoReset: !0,
        reset: s,
        update: r
    }
}
function U3(n, e, t) {
    const r = new WeakMap
      , s = new zn;
    function o(u, d, f) {
        const h = u.morphTargetInfluences
          , m = d.morphAttributes.position || d.morphAttributes.normal || d.morphAttributes.color
          , g = m !== void 0 ? m.length : 0;
        let _ = r.get(d);
        if (_ === void 0 || _.count !== g) {
            let R = function() {
                z.dispose(),
                r.delete(d),
                d.removeEventListener("dispose", R)
            };
            var x = R;
            _ !== void 0 && _.texture.dispose();
            const E = d.morphAttributes.position !== void 0
              , M = d.morphAttributes.normal !== void 0
              , b = d.morphAttributes.color !== void 0
              , y = d.morphAttributes.position || []
              , T = d.morphAttributes.normal || []
              , D = d.morphAttributes.color || [];
            let C = 0;
            E === !0 && (C = 1),
            M === !0 && (C = 2),
            b === !0 && (C = 3);
            let P = d.attributes.position.count * C
              , A = 1;
            P > e.maxTextureSize && (A = Math.ceil(P / e.maxTextureSize),
            P = e.maxTextureSize);
            const F = new Float32Array(P * A * 4 * g)
              , z = new KM(F,P,A,g);
            z.type = ya,
            z.needsUpdate = !0;
            const U = C * 4;
            for (let V = 0; V < g; V++) {
                const Q = y[V]
                  , X = T[V]
                  , oe = D[V]
                  , le = P * A * 4 * V;
                for (let O = 0; O < Q.count; O++) {
                    const W = O * U;
                    E === !0 && (s.fromBufferAttribute(Q, O),
                    F[le + W + 0] = s.x,
                    F[le + W + 1] = s.y,
                    F[le + W + 2] = s.z,
                    F[le + W + 3] = 0),
                    M === !0 && (s.fromBufferAttribute(X, O),
                    F[le + W + 4] = s.x,
                    F[le + W + 5] = s.y,
                    F[le + W + 6] = s.z,
                    F[le + W + 7] = 0),
                    b === !0 && (s.fromBufferAttribute(oe, O),
                    F[le + W + 8] = s.x,
                    F[le + W + 9] = s.y,
                    F[le + W + 10] = s.z,
                    F[le + W + 11] = oe.itemSize === 4 ? s.w : 1)
                }
            }
            _ = {
                count: g,
                texture: z,
                size: new _n(P,A)
            },
            r.set(d, _),
            d.addEventListener("dispose", R)
        }
        if (u.isInstancedMesh === !0 && u.morphTexture !== null)
            f.getUniforms().setValue(n, "morphTexture", u.morphTexture, t);
        else {
            let E = 0;
            for (let b = 0; b < h.length; b++)
                E += h[b];
            const M = d.morphTargetsRelative ? 1 : 1 - E;
            f.getUniforms().setValue(n, "morphTargetBaseInfluence", M),
            f.getUniforms().setValue(n, "morphTargetInfluences", h)
        }
        f.getUniforms().setValue(n, "morphTargetsTexture", _.texture, t),
        f.getUniforms().setValue(n, "morphTargetsTextureSize", _.size)
    }
    return {
        update: o
    }
}
function L3(n, e, t, r) {
    let s = new WeakMap;
    function o(f) {
        const h = r.render.frame
          , m = f.geometry
          , g = e.get(f, m);
        if (s.get(g) !== h && (e.update(g),
        s.set(g, h)),
        f.isInstancedMesh && (f.hasEventListener("dispose", d) === !1 && f.addEventListener("dispose", d),
        s.get(f) !== h && (t.update(f.instanceMatrix, n.ARRAY_BUFFER),
        f.instanceColor !== null && t.update(f.instanceColor, n.ARRAY_BUFFER),
        s.set(f, h))),
        f.isSkinnedMesh) {
            const _ = f.skeleton;
            s.get(_) !== h && (_.update(),
            s.set(_, h))
        }
        return g
    }
    function u() {
        s = new WeakMap
    }
    function d(f) {
        const h = f.target;
        h.removeEventListener("dispose", d),
        t.remove(h.instanceMatrix),
        h.instanceColor !== null && t.remove(h.instanceColor)
    }
    return {
        update: o,
        dispose: u
    }
}
const uw = new wi
  , OS = new ow(1,1)
  , dw = new KM
  , fw = new nL
  , hw = new sw
  , PS = []
  , IS = []
  , zS = new Float32Array(16)
  , kS = new Float32Array(9)
  , FS = new Float32Array(4);
function Tl(n, e, t) {
    const r = n[0];
    if (r <= 0 || r > 0)
        return n;
    const s = e * t;
    let o = PS[s];
    if (o === void 0 && (o = new Float32Array(s),
    PS[s] = o),
    e !== 0) {
        r.toArray(o, 0);
        for (let u = 1, d = 0; u !== e; ++u)
            d += t,
            n[u].toArray(o, d)
    }
    return o
}
function Jn(n, e) {
    if (n.length !== e.length)
        return !1;
    for (let t = 0, r = n.length; t < r; t++)
        if (n[t] !== e[t])
            return !1;
    return !0
}
function ei(n, e) {
    for (let t = 0, r = e.length; t < r; t++)
        n[t] = e[t]
}
function ah(n, e) {
    let t = IS[e];
    t === void 0 && (t = new Int32Array(e),
    IS[e] = t);
    for (let r = 0; r !== e; ++r)
        t[r] = n.allocateTextureUnit();
    return t
}
function N3(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1f(this.addr, e),
    t[0] = e)
}
function O3(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2f(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (Jn(t, e))
            return;
        n.uniform2fv(this.addr, e),
        ei(t, e)
    }
}
function P3(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3f(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else if (e.r !== void 0)
        (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (n.uniform3f(this.addr, e.r, e.g, e.b),
        t[0] = e.r,
        t[1] = e.g,
        t[2] = e.b);
    else {
        if (Jn(t, e))
            return;
        n.uniform3fv(this.addr, e),
        ei(t, e)
    }
}
function I3(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (Jn(t, e))
            return;
        n.uniform4fv(this.addr, e),
        ei(t, e)
    }
}
function z3(n, e) {
    const t = this.cache
      , r = e.elements;
    if (r === void 0) {
        if (Jn(t, e))
            return;
        n.uniformMatrix2fv(this.addr, !1, e),
        ei(t, e)
    } else {
        if (Jn(t, r))
            return;
        FS.set(r),
        n.uniformMatrix2fv(this.addr, !1, FS),
        ei(t, r)
    }
}
function k3(n, e) {
    const t = this.cache
      , r = e.elements;
    if (r === void 0) {
        if (Jn(t, e))
            return;
        n.uniformMatrix3fv(this.addr, !1, e),
        ei(t, e)
    } else {
        if (Jn(t, r))
            return;
        kS.set(r),
        n.uniformMatrix3fv(this.addr, !1, kS),
        ei(t, r)
    }
}
function F3(n, e) {
    const t = this.cache
      , r = e.elements;
    if (r === void 0) {
        if (Jn(t, e))
            return;
        n.uniformMatrix4fv(this.addr, !1, e),
        ei(t, e)
    } else {
        if (Jn(t, r))
            return;
        zS.set(r),
        n.uniformMatrix4fv(this.addr, !1, zS),
        ei(t, r)
    }
}
function B3(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1i(this.addr, e),
    t[0] = e)
}
function V3(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2i(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (Jn(t, e))
            return;
        n.uniform2iv(this.addr, e),
        ei(t, e)
    }
}
function H3(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3i(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (Jn(t, e))
            return;
        n.uniform3iv(this.addr, e),
        ei(t, e)
    }
}
function G3(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (Jn(t, e))
            return;
        n.uniform4iv(this.addr, e),
        ei(t, e)
    }
}
function j3(n, e) {
    const t = this.cache;
    t[0] !== e && (n.uniform1ui(this.addr, e),
    t[0] = e)
}
function W3(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (n.uniform2ui(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (Jn(t, e))
            return;
        n.uniform2uiv(this.addr, e),
        ei(t, e)
    }
}
function X3(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3ui(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (Jn(t, e))
            return;
        n.uniform3uiv(this.addr, e),
        ei(t, e)
    }
}
function q3(n, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (Jn(t, e))
            return;
        n.uniform4uiv(this.addr, e),
        ei(t, e)
    }
}
function Y3(n, e, t) {
    const r = this.cache
      , s = t.allocateTextureUnit();
    r[0] !== s && (n.uniform1i(this.addr, s),
    r[0] = s);
    let o;
    this.type === n.SAMPLER_2D_SHADOW ? (OS.compareFunction = ZM,
    o = OS) : o = uw,
    t.setTexture2D(e || o, s)
}
function Z3(n, e, t) {
    const r = this.cache
      , s = t.allocateTextureUnit();
    r[0] !== s && (n.uniform1i(this.addr, s),
    r[0] = s),
    t.setTexture3D(e || fw, s)
}
function $3(n, e, t) {
    const r = this.cache
      , s = t.allocateTextureUnit();
    r[0] !== s && (n.uniform1i(this.addr, s),
    r[0] = s),
    t.setTextureCube(e || hw, s)
}
function K3(n, e, t) {
    const r = this.cache
      , s = t.allocateTextureUnit();
    r[0] !== s && (n.uniform1i(this.addr, s),
    r[0] = s),
    t.setTexture2DArray(e || dw, s)
}
function Q3(n) {
    switch (n) {
    case 5126:
        return N3;
    case 35664:
        return O3;
    case 35665:
        return P3;
    case 35666:
        return I3;
    case 35674:
        return z3;
    case 35675:
        return k3;
    case 35676:
        return F3;
    case 5124:
    case 35670:
        return B3;
    case 35667:
    case 35671:
        return V3;
    case 35668:
    case 35672:
        return H3;
    case 35669:
    case 35673:
        return G3;
    case 5125:
        return j3;
    case 36294:
        return W3;
    case 36295:
        return X3;
    case 36296:
        return q3;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return Y3;
    case 35679:
    case 36299:
    case 36307:
        return Z3;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return $3;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return K3
    }
}
function J3(n, e) {
    n.uniform1fv(this.addr, e)
}
function eP(n, e) {
    const t = Tl(e, this.size, 2);
    n.uniform2fv(this.addr, t)
}
function tP(n, e) {
    const t = Tl(e, this.size, 3);
    n.uniform3fv(this.addr, t)
}
function nP(n, e) {
    const t = Tl(e, this.size, 4);
    n.uniform4fv(this.addr, t)
}
function iP(n, e) {
    const t = Tl(e, this.size, 4);
    n.uniformMatrix2fv(this.addr, !1, t)
}
function rP(n, e) {
    const t = Tl(e, this.size, 9);
    n.uniformMatrix3fv(this.addr, !1, t)
}
function aP(n, e) {
    const t = Tl(e, this.size, 16);
    n.uniformMatrix4fv(this.addr, !1, t)
}
function sP(n, e) {
    n.uniform1iv(this.addr, e)
}
function oP(n, e) {
    n.uniform2iv(this.addr, e)
}
function lP(n, e) {
    n.uniform3iv(this.addr, e)
}
function cP(n, e) {
    n.uniform4iv(this.addr, e)
}
function uP(n, e) {
    n.uniform1uiv(this.addr, e)
}
function dP(n, e) {
    n.uniform2uiv(this.addr, e)
}
function fP(n, e) {
    n.uniform3uiv(this.addr, e)
}
function hP(n, e) {
    n.uniform4uiv(this.addr, e)
}
function pP(n, e, t) {
    const r = this.cache
      , s = e.length
      , o = ah(t, s);
    Jn(r, o) || (n.uniform1iv(this.addr, o),
    ei(r, o));
    for (let u = 0; u !== s; ++u)
        t.setTexture2D(e[u] || uw, o[u])
}
function mP(n, e, t) {
    const r = this.cache
      , s = e.length
      , o = ah(t, s);
    Jn(r, o) || (n.uniform1iv(this.addr, o),
    ei(r, o));
    for (let u = 0; u !== s; ++u)
        t.setTexture3D(e[u] || fw, o[u])
}
function gP(n, e, t) {
    const r = this.cache
      , s = e.length
      , o = ah(t, s);
    Jn(r, o) || (n.uniform1iv(this.addr, o),
    ei(r, o));
    for (let u = 0; u !== s; ++u)
        t.setTextureCube(e[u] || hw, o[u])
}
function vP(n, e, t) {
    const r = this.cache
      , s = e.length
      , o = ah(t, s);
    Jn(r, o) || (n.uniform1iv(this.addr, o),
    ei(r, o));
    for (let u = 0; u !== s; ++u)
        t.setTexture2DArray(e[u] || dw, o[u])
}
function _P(n) {
    switch (n) {
    case 5126:
        return J3;
    case 35664:
        return eP;
    case 35665:
        return tP;
    case 35666:
        return nP;
    case 35674:
        return iP;
    case 35675:
        return rP;
    case 35676:
        return aP;
    case 5124:
    case 35670:
        return sP;
    case 35667:
    case 35671:
        return oP;
    case 35668:
    case 35672:
        return lP;
    case 35669:
    case 35673:
        return cP;
    case 5125:
        return uP;
    case 36294:
        return dP;
    case 36295:
        return fP;
    case 36296:
        return hP;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return pP;
    case 35679:
    case 36299:
    case 36307:
        return mP;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return gP;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return vP
    }
}
class yP {
    constructor(e, t, r) {
        this.id = e,
        this.addr = r,
        this.cache = [],
        this.type = t.type,
        this.setValue = Q3(t.type)
    }
}
class xP {
    constructor(e, t, r) {
        this.id = e,
        this.addr = r,
        this.cache = [],
        this.type = t.type,
        this.size = t.size,
        this.setValue = _P(t.type)
    }
}
class bP {
    constructor(e) {
        this.id = e,
        this.seq = [],
        this.map = {}
    }
    setValue(e, t, r) {
        const s = this.seq;
        for (let o = 0, u = s.length; o !== u; ++o) {
            const d = s[o];
            d.setValue(e, t[d.id], r)
        }
    }
}
const hg = /(\w+)(\])?(\[|\.)?/g;
function BS(n, e) {
    n.seq.push(e),
    n.map[e.id] = e
}
function SP(n, e, t) {
    const r = n.name
      , s = r.length;
    for (hg.lastIndex = 0; ; ) {
        const o = hg.exec(r)
          , u = hg.lastIndex;
        let d = o[1];
        const f = o[2] === "]"
          , h = o[3];
        if (f && (d = d | 0),
        h === void 0 || h === "[" && u + 2 === s) {
            BS(t, h === void 0 ? new yP(d,n,e) : new xP(d,n,e));
            break
        } else {
            let g = t.map[d];
            g === void 0 && (g = new bP(d),
            BS(t, g)),
            t = g
        }
    }
}
class _f {
    constructor(e, t) {
        this.seq = [],
        this.map = {};
        const r = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
        for (let s = 0; s < r; ++s) {
            const o = e.getActiveUniform(t, s)
              , u = e.getUniformLocation(t, o.name);
            SP(o, u, this)
        }
    }
    setValue(e, t, r, s) {
        const o = this.map[t];
        o !== void 0 && o.setValue(e, r, s)
    }
    setOptional(e, t, r) {
        const s = t[r];
        s !== void 0 && this.setValue(e, r, s)
    }
    static upload(e, t, r, s) {
        for (let o = 0, u = t.length; o !== u; ++o) {
            const d = t[o]
              , f = r[d.id];
            f.needsUpdate !== !1 && d.setValue(e, f.value, s)
        }
    }
    static seqWithValue(e, t) {
        const r = [];
        for (let s = 0, o = e.length; s !== o; ++s) {
            const u = e[s];
            u.id in t && r.push(u)
        }
        return r
    }
}
function VS(n, e, t) {
    const r = n.createShader(e);
    return n.shaderSource(r, t),
    n.compileShader(r),
    r
}
const EP = 37297;
let MP = 0;
function wP(n, e) {
    const t = n.split(`
`)
      , r = []
      , s = Math.max(e - 6, 0)
      , o = Math.min(e + 6, t.length);
    for (let u = s; u < o; u++) {
        const d = u + 1;
        r.push(`${d === e ? ">" : " "} ${d}: ${t[u]}`)
    }
    return r.join(`
`)
}
const HS = new Vt;
function TP(n) {
    fn._getMatrix(HS, fn.workingColorSpace, n);
    const e = `mat3( ${HS.elements.map(t => t.toFixed(4))} )`;
    switch (fn.getTransfer(n)) {
    case wf:
        return [e, "LinearTransferOETF"];
    case Sn:
        return [e, "sRGBTransferOETF"];
    default:
        return console.warn("THREE.WebGLProgram: Unsupported color space: ", n),
        [e, "LinearTransferOETF"]
    }
}
function GS(n, e, t) {
    const r = n.getShaderParameter(e, n.COMPILE_STATUS)
      , s = n.getShaderInfoLog(e).trim();
    if (r && s === "")
        return "";
    const o = /ERROR: 0:(\d+)/.exec(s);
    if (o) {
        const u = parseInt(o[1]);
        return t.toUpperCase() + `

` + s + `

` + wP(n.getShaderSource(e), u)
    } else
        return s
}
function AP(n, e) {
    const t = TP(e);
    return [`vec4 ${n}( vec4 value ) {`, `	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`, "}"].join(`
`)
}
function RP(n, e) {
    let t;
    switch (e) {
    case AU:
        t = "Linear";
        break;
    case RU:
        t = "Reinhard";
        break;
    case CU:
        t = "Cineon";
        break;
    case DU:
        t = "ACESFilmic";
        break;
    case LU:
        t = "AgX";
        break;
    case NU:
        t = "Neutral";
        break;
    case UU:
        t = "Custom";
        break;
    default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        t = "Linear"
    }
    return "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
}
const rf = new Ee;
function CP() {
    fn.getLuminanceCoefficients(rf);
    const n = rf.x.toFixed(4)
      , e = rf.y.toFixed(4)
      , t = rf.z.toFixed(4);
    return ["float luminance( const in vec3 rgb ) {", `	const vec3 weights = vec3( ${n}, ${e}, ${t} );`, "	return dot( weights, rgb );", "}"].join(`
`)
}
function DP(n) {
    return [n.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", n.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(kc).join(`
`)
}
function UP(n) {
    const e = [];
    for (const t in n) {
        const r = n[t];
        r !== !1 && e.push("#define " + t + " " + r)
    }
    return e.join(`
`)
}
function LP(n, e) {
    const t = {}
      , r = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
    for (let s = 0; s < r; s++) {
        const o = n.getActiveAttrib(e, s)
          , u = o.name;
        let d = 1;
        o.type === n.FLOAT_MAT2 && (d = 2),
        o.type === n.FLOAT_MAT3 && (d = 3),
        o.type === n.FLOAT_MAT4 && (d = 4),
        t[u] = {
            type: o.type,
            location: n.getAttribLocation(e, u),
            locationSize: d
        }
    }
    return t
}
function kc(n) {
    return n !== ""
}
function jS(n, e) {
    const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return n.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}
function WS(n, e) {
    return n.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const NP = /^[ \t]*#include +<([\w\d./]+)>/gm;
function wv(n) {
    return n.replace(NP, PP)
}
const OP = new Map;
function PP(n, e) {
    let t = Ht[e];
    if (t === void 0) {
        const r = OP.get(e);
        if (r !== void 0)
            t = Ht[r],
            console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, r);
        else
            throw new Error("Can not resolve #include <" + e + ">")
    }
    return wv(t)
}
const IP = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function XS(n) {
    return n.replace(IP, zP)
}
function zP(n, e, t, r) {
    let s = "";
    for (let o = parseInt(e); o < parseInt(t); o++)
        s += r.replace(/\[\s*i\s*\]/g, "[ " + o + " ]").replace(/UNROLLED_LOOP_INDEX/g, o);
    return s
}
function qS(n) {
    let e = `precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	precision ${n.precision} sampler3D;
	precision ${n.precision} sampler2DArray;
	precision ${n.precision} sampler2DShadow;
	precision ${n.precision} samplerCubeShadow;
	precision ${n.precision} sampler2DArrayShadow;
	precision ${n.precision} isampler2D;
	precision ${n.precision} isampler3D;
	precision ${n.precision} isamplerCube;
	precision ${n.precision} isampler2DArray;
	precision ${n.precision} usampler2D;
	precision ${n.precision} usampler3D;
	precision ${n.precision} usamplerCube;
	precision ${n.precision} usampler2DArray;
	`;
    return n.precision === "highp" ? e += `
#define HIGH_PRECISION` : n.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : n.precision === "lowp" && (e += `
#define LOW_PRECISION`),
    e
}
function kP(n) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return n.shadowMapType === IM ? e = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === sU ? e = "SHADOWMAP_TYPE_PCF_SOFT" : n.shadowMapType === ua && (e = "SHADOWMAP_TYPE_VSM"),
    e
}
function FP(n) {
    let e = "ENVMAP_TYPE_CUBE";
    if (n.envMap)
        switch (n.envMapMode) {
        case ml:
        case gl:
            e = "ENVMAP_TYPE_CUBE";
            break;
        case nh:
            e = "ENVMAP_TYPE_CUBE_UV";
            break
        }
    return e
}
function BP(n) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (n.envMap)
        switch (n.envMapMode) {
        case gl:
            e = "ENVMAP_MODE_REFRACTION";
            break
        }
    return e
}
function VP(n) {
    let e = "ENVMAP_BLENDING_NONE";
    if (n.envMap)
        switch (n.combine) {
        case zM:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case wU:
            e = "ENVMAP_BLENDING_MIX";
            break;
        case TU:
            e = "ENVMAP_BLENDING_ADD";
            break
        }
    return e
}
function HP(n) {
    const e = n.envMapCubeUVHeight;
    if (e === null)
        return null;
    const t = Math.log2(e) - 2
      , r = 1 / e;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
        texelHeight: r,
        maxMip: t
    }
}
function GP(n, e, t, r) {
    const s = n.getContext()
      , o = t.defines;
    let u = t.vertexShader
      , d = t.fragmentShader;
    const f = kP(t)
      , h = FP(t)
      , m = BP(t)
      , g = VP(t)
      , _ = HP(t)
      , x = DP(t)
      , E = UP(o)
      , M = s.createProgram();
    let b, y, T = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
    t.isRawShaderMaterial ? (b = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, E].filter(kc).join(`
`),
    b.length > 0 && (b += `
`),
    y = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, E].filter(kc).join(`
`),
    y.length > 0 && (y += `
`)) : (b = [qS(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, E, t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", t.batching ? "#define USE_BATCHING" : "", t.batchingColor ? "#define USE_BATCHING_COLOR" : "", t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + m : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + f : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(kc).join(`
`),
    y = [qS(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, E, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + h : "", t.envMap ? "#define " + m : "", t.envMap ? "#define " + g : "", _ ? "#define CUBEUV_TEXEL_WIDTH " + _.texelWidth : "", _ ? "#define CUBEUV_TEXEL_HEIGHT " + _.texelHeight : "", _ ? "#define CUBEUV_MAX_MIP " + _.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.dispersion ? "#define USE_DISPERSION" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor || t.batchingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + f : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== gs ? "#define TONE_MAPPING" : "", t.toneMapping !== gs ? Ht.tonemapping_pars_fragment : "", t.toneMapping !== gs ? RP("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", Ht.colorspace_pars_fragment, AP("linearToOutputTexel", t.outputColorSpace), CP(), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(kc).join(`
`)),
    u = wv(u),
    u = jS(u, t),
    u = WS(u, t),
    d = wv(d),
    d = jS(d, t),
    d = WS(d, t),
    u = XS(u),
    d = XS(d),
    t.isRawShaderMaterial !== !0 && (T = `#version 300 es
`,
    b = [x, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + b,
    y = ["#define varying in", t.glslVersion === nS ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === nS ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + y);
    const D = T + b + u
      , C = T + y + d
      , P = VS(s, s.VERTEX_SHADER, D)
      , A = VS(s, s.FRAGMENT_SHADER, C);
    s.attachShader(M, P),
    s.attachShader(M, A),
    t.index0AttributeName !== void 0 ? s.bindAttribLocation(M, 0, t.index0AttributeName) : t.morphTargets === !0 && s.bindAttribLocation(M, 0, "position"),
    s.linkProgram(M);
    function F(V) {
        if (n.debug.checkShaderErrors) {
            const Q = s.getProgramInfoLog(M).trim()
              , X = s.getShaderInfoLog(P).trim()
              , oe = s.getShaderInfoLog(A).trim();
            let le = !0
              , O = !0;
            if (s.getProgramParameter(M, s.LINK_STATUS) === !1)
                if (le = !1,
                typeof n.debug.onShaderError == "function")
                    n.debug.onShaderError(s, M, P, A);
                else {
                    const W = GS(s, P, "vertex")
                      , H = GS(s, A, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + s.getError() + " - VALIDATE_STATUS " + s.getProgramParameter(M, s.VALIDATE_STATUS) + `

Material Name: ` + V.name + `
Material Type: ` + V.type + `

Program Info Log: ` + Q + `
` + W + `
` + H)
                }
            else
                Q !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", Q) : (X === "" || oe === "") && (O = !1);
            O && (V.diagnostics = {
                runnable: le,
                programLog: Q,
                vertexShader: {
                    log: X,
                    prefix: b
                },
                fragmentShader: {
                    log: oe,
                    prefix: y
                }
            })
        }
        s.deleteShader(P),
        s.deleteShader(A),
        z = new _f(s,M),
        U = LP(s, M)
    }
    let z;
    this.getUniforms = function() {
        return z === void 0 && F(this),
        z
    }
    ;
    let U;
    this.getAttributes = function() {
        return U === void 0 && F(this),
        U
    }
    ;
    let R = t.rendererExtensionParallelShaderCompile === !1;
    return this.isReady = function() {
        return R === !1 && (R = s.getProgramParameter(M, EP)),
        R
    }
    ,
    this.destroy = function() {
        r.releaseStatesOfProgram(this),
        s.deleteProgram(M),
        this.program = void 0
    }
    ,
    this.type = t.shaderType,
    this.name = t.shaderName,
    this.id = MP++,
    this.cacheKey = e,
    this.usedTimes = 1,
    this.program = M,
    this.vertexShader = P,
    this.fragmentShader = A,
    this
}
let jP = 0;
class WP {
    constructor() {
        this.shaderCache = new Map,
        this.materialCache = new Map
    }
    update(e) {
        const t = e.vertexShader
          , r = e.fragmentShader
          , s = this._getShaderStage(t)
          , o = this._getShaderStage(r)
          , u = this._getShaderCacheForMaterial(e);
        return u.has(s) === !1 && (u.add(s),
        s.usedTimes++),
        u.has(o) === !1 && (u.add(o),
        o.usedTimes++),
        this
    }
    remove(e) {
        const t = this.materialCache.get(e);
        for (const r of t)
            r.usedTimes--,
            r.usedTimes === 0 && this.shaderCache.delete(r.code);
        return this.materialCache.delete(e),
        this
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(),
        this.materialCache.clear()
    }
    _getShaderCacheForMaterial(e) {
        const t = this.materialCache;
        let r = t.get(e);
        return r === void 0 && (r = new Set,
        t.set(e, r)),
        r
    }
    _getShaderStage(e) {
        const t = this.shaderCache;
        let r = t.get(e);
        return r === void 0 && (r = new XP(e),
        t.set(e, r)),
        r
    }
}
class XP {
    constructor(e) {
        this.id = jP++,
        this.code = e,
        this.usedTimes = 0
    }
}
function qP(n, e, t, r, s, o, u) {
    const d = new JM
      , f = new WP
      , h = new Set
      , m = []
      , g = s.logarithmicDepthBuffer
      , _ = s.vertexTextures;
    let x = s.precision;
    const E = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    function M(U) {
        return h.add(U),
        U === 0 ? "uv" : `uv${U}`
    }
    function b(U, R, V, Q, X) {
        const oe = Q.fog
          , le = X.geometry
          , O = U.isMeshStandardMaterial ? Q.environment : null
          , W = (U.isMeshStandardMaterial ? t : e).get(U.envMap || O)
          , H = W && W.mapping === nh ? W.image.height : null
          , Me = E[U.type];
        U.precision !== null && (x = s.getMaxPrecision(U.precision),
        x !== U.precision && console.warn("THREE.WebGLProgram.getParameters:", U.precision, "not supported, using", x, "instead."));
        const k = le.morphAttributes.position || le.morphAttributes.normal || le.morphAttributes.color
          , ee = k !== void 0 ? k.length : 0;
        let ge = 0;
        le.morphAttributes.position !== void 0 && (ge = 1),
        le.morphAttributes.normal !== void 0 && (ge = 2),
        le.morphAttributes.color !== void 0 && (ge = 3);
        let pe, te, we, Se;
        if (Me) {
            const j = Dr[Me];
            pe = j.vertexShader,
            te = j.fragmentShader
        } else
            pe = U.vertexShader,
            te = U.fragmentShader,
            f.update(U),
            we = f.getVertexShaderID(U),
            Se = f.getFragmentShaderID(U);
        const De = n.getRenderTarget()
          , Ve = n.state.buffers.depth.getReversed()
          , _t = X.isInstancedMesh === !0
          , He = X.isBatchedMesh === !0
          , Pt = !!U.map
          , kt = !!U.matcap
          , nt = !!W
          , G = !!U.aoMap
          , Zt = !!U.lightMap
          , ot = !!U.bumpMap
          , it = !!U.normalMap
          , rt = !!U.displacementMap
          , pt = !!U.emissiveMap
          , Xe = !!U.metalnessMap
          , B = !!U.roughnessMap
          , S = U.anisotropy > 0
          , I = U.clearcoat > 0
          , q = U.dispersion > 0
          , se = U.iridescence > 0
          , J = U.sheen > 0
          , de = U.transmission > 0
          , _e = S && !!U.anisotropyMap
          , Ae = I && !!U.clearcoatMap
          , lt = I && !!U.clearcoatNormalMap
          , Le = I && !!U.clearcoatRoughnessMap
          , $e = se && !!U.iridescenceMap
          , ht = se && !!U.iridescenceThicknessMap
          , yt = J && !!U.sheenColorMap
          , qe = J && !!U.sheenRoughnessMap
          , Lt = !!U.specularMap
          , Tt = !!U.specularColorMap
          , qt = !!U.specularIntensityMap
          , re = de && !!U.transmissionMap
          , Ye = de && !!U.thicknessMap
          , Te = !!U.gradientMap
          , Ne = !!U.alphaMap
          , Ke = U.alphaTest > 0
          , Ce = !!U.alphaHash
          , at = !!U.extensions;
        let zt = gs;
        U.toneMapped && (De === null || De.isXRRenderTarget === !0) && (zt = n.toneMapping);
        const nn = {
            shaderID: Me,
            shaderType: U.type,
            shaderName: U.name,
            vertexShader: pe,
            fragmentShader: te,
            defines: U.defines,
            customVertexShaderID: we,
            customFragmentShaderID: Se,
            isRawShaderMaterial: U.isRawShaderMaterial === !0,
            glslVersion: U.glslVersion,
            precision: x,
            batching: He,
            batchingColor: He && X._colorsTexture !== null,
            instancing: _t,
            instancingColor: _t && X.instanceColor !== null,
            instancingMorph: _t && X.morphTexture !== null,
            supportsVertexTextures: _,
            outputColorSpace: De === null ? n.outputColorSpace : De.isXRRenderTarget === !0 ? De.texture.colorSpace : vl,
            alphaToCoverage: !!U.alphaToCoverage,
            map: Pt,
            matcap: kt,
            envMap: nt,
            envMapMode: nt && W.mapping,
            envMapCubeUVHeight: H,
            aoMap: G,
            lightMap: Zt,
            bumpMap: ot,
            normalMap: it,
            displacementMap: _ && rt,
            emissiveMap: pt,
            normalMapObjectSpace: it && U.normalMapType === kU,
            normalMapTangentSpace: it && U.normalMapType === zU,
            metalnessMap: Xe,
            roughnessMap: B,
            anisotropy: S,
            anisotropyMap: _e,
            clearcoat: I,
            clearcoatMap: Ae,
            clearcoatNormalMap: lt,
            clearcoatRoughnessMap: Le,
            dispersion: q,
            iridescence: se,
            iridescenceMap: $e,
            iridescenceThicknessMap: ht,
            sheen: J,
            sheenColorMap: yt,
            sheenRoughnessMap: qe,
            specularMap: Lt,
            specularColorMap: Tt,
            specularIntensityMap: qt,
            transmission: de,
            transmissionMap: re,
            thicknessMap: Ye,
            gradientMap: Te,
            opaque: U.transparent === !1 && U.blending === ul && U.alphaToCoverage === !1,
            alphaMap: Ne,
            alphaTest: Ke,
            alphaHash: Ce,
            combine: U.combine,
            mapUv: Pt && M(U.map.channel),
            aoMapUv: G && M(U.aoMap.channel),
            lightMapUv: Zt && M(U.lightMap.channel),
            bumpMapUv: ot && M(U.bumpMap.channel),
            normalMapUv: it && M(U.normalMap.channel),
            displacementMapUv: rt && M(U.displacementMap.channel),
            emissiveMapUv: pt && M(U.emissiveMap.channel),
            metalnessMapUv: Xe && M(U.metalnessMap.channel),
            roughnessMapUv: B && M(U.roughnessMap.channel),
            anisotropyMapUv: _e && M(U.anisotropyMap.channel),
            clearcoatMapUv: Ae && M(U.clearcoatMap.channel),
            clearcoatNormalMapUv: lt && M(U.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: Le && M(U.clearcoatRoughnessMap.channel),
            iridescenceMapUv: $e && M(U.iridescenceMap.channel),
            iridescenceThicknessMapUv: ht && M(U.iridescenceThicknessMap.channel),
            sheenColorMapUv: yt && M(U.sheenColorMap.channel),
            sheenRoughnessMapUv: qe && M(U.sheenRoughnessMap.channel),
            specularMapUv: Lt && M(U.specularMap.channel),
            specularColorMapUv: Tt && M(U.specularColorMap.channel),
            specularIntensityMapUv: qt && M(U.specularIntensityMap.channel),
            transmissionMapUv: re && M(U.transmissionMap.channel),
            thicknessMapUv: Ye && M(U.thicknessMap.channel),
            alphaMapUv: Ne && M(U.alphaMap.channel),
            vertexTangents: !!le.attributes.tangent && (it || S),
            vertexColors: U.vertexColors,
            vertexAlphas: U.vertexColors === !0 && !!le.attributes.color && le.attributes.color.itemSize === 4,
            pointsUvs: X.isPoints === !0 && !!le.attributes.uv && (Pt || Ne),
            fog: !!oe,
            useFog: U.fog === !0,
            fogExp2: !!oe && oe.isFogExp2,
            flatShading: U.flatShading === !0,
            sizeAttenuation: U.sizeAttenuation === !0,
            logarithmicDepthBuffer: g,
            reverseDepthBuffer: Ve,
            skinning: X.isSkinnedMesh === !0,
            morphTargets: le.morphAttributes.position !== void 0,
            morphNormals: le.morphAttributes.normal !== void 0,
            morphColors: le.morphAttributes.color !== void 0,
            morphTargetsCount: ee,
            morphTextureStride: ge,
            numDirLights: R.directional.length,
            numPointLights: R.point.length,
            numSpotLights: R.spot.length,
            numSpotLightMaps: R.spotLightMap.length,
            numRectAreaLights: R.rectArea.length,
            numHemiLights: R.hemi.length,
            numDirLightShadows: R.directionalShadowMap.length,
            numPointLightShadows: R.pointShadowMap.length,
            numSpotLightShadows: R.spotShadowMap.length,
            numSpotLightShadowsWithMaps: R.numSpotLightShadowsWithMaps,
            numLightProbes: R.numLightProbes,
            numClippingPlanes: u.numPlanes,
            numClipIntersection: u.numIntersection,
            dithering: U.dithering,
            shadowMapEnabled: n.shadowMap.enabled && V.length > 0,
            shadowMapType: n.shadowMap.type,
            toneMapping: zt,
            decodeVideoTexture: Pt && U.map.isVideoTexture === !0 && fn.getTransfer(U.map.colorSpace) === Sn,
            decodeVideoTextureEmissive: pt && U.emissiveMap.isVideoTexture === !0 && fn.getTransfer(U.emissiveMap.colorSpace) === Sn,
            premultipliedAlpha: U.premultipliedAlpha,
            doubleSided: U.side === _a,
            flipSided: U.side === Ni,
            useDepthPacking: U.depthPacking >= 0,
            depthPacking: U.depthPacking || 0,
            index0AttributeName: U.index0AttributeName,
            extensionClipCullDistance: at && U.extensions.clipCullDistance === !0 && r.has("WEBGL_clip_cull_distance"),
            extensionMultiDraw: (at && U.extensions.multiDraw === !0 || He) && r.has("WEBGL_multi_draw"),
            rendererExtensionParallelShaderCompile: r.has("KHR_parallel_shader_compile"),
            customProgramCacheKey: U.customProgramCacheKey()
        };
        return nn.vertexUv1s = h.has(1),
        nn.vertexUv2s = h.has(2),
        nn.vertexUv3s = h.has(3),
        h.clear(),
        nn
    }
    function y(U) {
        const R = [];
        if (U.shaderID ? R.push(U.shaderID) : (R.push(U.customVertexShaderID),
        R.push(U.customFragmentShaderID)),
        U.defines !== void 0)
            for (const V in U.defines)
                R.push(V),
                R.push(U.defines[V]);
        return U.isRawShaderMaterial === !1 && (T(R, U),
        D(R, U),
        R.push(n.outputColorSpace)),
        R.push(U.customProgramCacheKey),
        R.join()
    }
    function T(U, R) {
        U.push(R.precision),
        U.push(R.outputColorSpace),
        U.push(R.envMapMode),
        U.push(R.envMapCubeUVHeight),
        U.push(R.mapUv),
        U.push(R.alphaMapUv),
        U.push(R.lightMapUv),
        U.push(R.aoMapUv),
        U.push(R.bumpMapUv),
        U.push(R.normalMapUv),
        U.push(R.displacementMapUv),
        U.push(R.emissiveMapUv),
        U.push(R.metalnessMapUv),
        U.push(R.roughnessMapUv),
        U.push(R.anisotropyMapUv),
        U.push(R.clearcoatMapUv),
        U.push(R.clearcoatNormalMapUv),
        U.push(R.clearcoatRoughnessMapUv),
        U.push(R.iridescenceMapUv),
        U.push(R.iridescenceThicknessMapUv),
        U.push(R.sheenColorMapUv),
        U.push(R.sheenRoughnessMapUv),
        U.push(R.specularMapUv),
        U.push(R.specularColorMapUv),
        U.push(R.specularIntensityMapUv),
        U.push(R.transmissionMapUv),
        U.push(R.thicknessMapUv),
        U.push(R.combine),
        U.push(R.fogExp2),
        U.push(R.sizeAttenuation),
        U.push(R.morphTargetsCount),
        U.push(R.morphAttributeCount),
        U.push(R.numDirLights),
        U.push(R.numPointLights),
        U.push(R.numSpotLights),
        U.push(R.numSpotLightMaps),
        U.push(R.numHemiLights),
        U.push(R.numRectAreaLights),
        U.push(R.numDirLightShadows),
        U.push(R.numPointLightShadows),
        U.push(R.numSpotLightShadows),
        U.push(R.numSpotLightShadowsWithMaps),
        U.push(R.numLightProbes),
        U.push(R.shadowMapType),
        U.push(R.toneMapping),
        U.push(R.numClippingPlanes),
        U.push(R.numClipIntersection),
        U.push(R.depthPacking)
    }
    function D(U, R) {
        d.disableAll(),
        R.supportsVertexTextures && d.enable(0),
        R.instancing && d.enable(1),
        R.instancingColor && d.enable(2),
        R.instancingMorph && d.enable(3),
        R.matcap && d.enable(4),
        R.envMap && d.enable(5),
        R.normalMapObjectSpace && d.enable(6),
        R.normalMapTangentSpace && d.enable(7),
        R.clearcoat && d.enable(8),
        R.iridescence && d.enable(9),
        R.alphaTest && d.enable(10),
        R.vertexColors && d.enable(11),
        R.vertexAlphas && d.enable(12),
        R.vertexUv1s && d.enable(13),
        R.vertexUv2s && d.enable(14),
        R.vertexUv3s && d.enable(15),
        R.vertexTangents && d.enable(16),
        R.anisotropy && d.enable(17),
        R.alphaHash && d.enable(18),
        R.batching && d.enable(19),
        R.dispersion && d.enable(20),
        R.batchingColor && d.enable(21),
        U.push(d.mask),
        d.disableAll(),
        R.fog && d.enable(0),
        R.useFog && d.enable(1),
        R.flatShading && d.enable(2),
        R.logarithmicDepthBuffer && d.enable(3),
        R.reverseDepthBuffer && d.enable(4),
        R.skinning && d.enable(5),
        R.morphTargets && d.enable(6),
        R.morphNormals && d.enable(7),
        R.morphColors && d.enable(8),
        R.premultipliedAlpha && d.enable(9),
        R.shadowMapEnabled && d.enable(10),
        R.doubleSided && d.enable(11),
        R.flipSided && d.enable(12),
        R.useDepthPacking && d.enable(13),
        R.dithering && d.enable(14),
        R.transmission && d.enable(15),
        R.sheen && d.enable(16),
        R.opaque && d.enable(17),
        R.pointsUvs && d.enable(18),
        R.decodeVideoTexture && d.enable(19),
        R.decodeVideoTextureEmissive && d.enable(20),
        R.alphaToCoverage && d.enable(21),
        U.push(d.mask)
    }
    function C(U) {
        const R = E[U.type];
        let V;
        if (R) {
            const Q = Dr[R];
            V = mL.clone(Q.uniforms)
        } else
            V = U.uniforms;
        return V
    }
    function P(U, R) {
        let V;
        for (let Q = 0, X = m.length; Q < X; Q++) {
            const oe = m[Q];
            if (oe.cacheKey === R) {
                V = oe,
                ++V.usedTimes;
                break
            }
        }
        return V === void 0 && (V = new GP(n,R,U,o),
        m.push(V)),
        V
    }
    function A(U) {
        if (--U.usedTimes === 0) {
            const R = m.indexOf(U);
            m[R] = m[m.length - 1],
            m.pop(),
            U.destroy()
        }
    }
    function F(U) {
        f.remove(U)
    }
    function z() {
        f.dispose()
    }
    return {
        getParameters: b,
        getProgramCacheKey: y,
        getUniforms: C,
        acquireProgram: P,
        releaseProgram: A,
        releaseShaderCache: F,
        programs: m,
        dispose: z
    }
}
function YP() {
    let n = new WeakMap;
    function e(u) {
        return n.has(u)
    }
    function t(u) {
        let d = n.get(u);
        return d === void 0 && (d = {},
        n.set(u, d)),
        d
    }
    function r(u) {
        n.delete(u)
    }
    function s(u, d, f) {
        n.get(u)[d] = f
    }
    function o() {
        n = new WeakMap
    }
    return {
        has: e,
        get: t,
        remove: r,
        update: s,
        dispose: o
    }
}
function ZP(n, e) {
    return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.material.id !== e.material.id ? n.material.id - e.material.id : n.z !== e.z ? n.z - e.z : n.id - e.id
}
function YS(n, e) {
    return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.z !== e.z ? e.z - n.z : n.id - e.id
}
function ZS() {
    const n = [];
    let e = 0;
    const t = []
      , r = []
      , s = [];
    function o() {
        e = 0,
        t.length = 0,
        r.length = 0,
        s.length = 0
    }
    function u(g, _, x, E, M, b) {
        let y = n[e];
        return y === void 0 ? (y = {
            id: g.id,
            object: g,
            geometry: _,
            material: x,
            groupOrder: E,
            renderOrder: g.renderOrder,
            z: M,
            group: b
        },
        n[e] = y) : (y.id = g.id,
        y.object = g,
        y.geometry = _,
        y.material = x,
        y.groupOrder = E,
        y.renderOrder = g.renderOrder,
        y.z = M,
        y.group = b),
        e++,
        y
    }
    function d(g, _, x, E, M, b) {
        const y = u(g, _, x, E, M, b);
        x.transmission > 0 ? r.push(y) : x.transparent === !0 ? s.push(y) : t.push(y)
    }
    function f(g, _, x, E, M, b) {
        const y = u(g, _, x, E, M, b);
        x.transmission > 0 ? r.unshift(y) : x.transparent === !0 ? s.unshift(y) : t.unshift(y)
    }
    function h(g, _) {
        t.length > 1 && t.sort(g || ZP),
        r.length > 1 && r.sort(_ || YS),
        s.length > 1 && s.sort(_ || YS)
    }
    function m() {
        for (let g = e, _ = n.length; g < _; g++) {
            const x = n[g];
            if (x.id === null)
                break;
            x.id = null,
            x.object = null,
            x.geometry = null,
            x.material = null,
            x.group = null
        }
    }
    return {
        opaque: t,
        transmissive: r,
        transparent: s,
        init: o,
        push: d,
        unshift: f,
        finish: m,
        sort: h
    }
}
function $P() {
    let n = new WeakMap;
    function e(r, s) {
        const o = n.get(r);
        let u;
        return o === void 0 ? (u = new ZS,
        n.set(r, [u])) : s >= o.length ? (u = new ZS,
        o.push(u)) : u = o[s],
        u
    }
    function t() {
        n = new WeakMap
    }
    return {
        get: e,
        dispose: t
    }
}
function KP() {
    const n = {};
    return {
        get: function(e) {
            if (n[e.id] !== void 0)
                return n[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    direction: new Ee,
                    color: new pn
                };
                break;
            case "SpotLight":
                t = {
                    position: new Ee,
                    direction: new Ee,
                    color: new pn,
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                };
                break;
            case "PointLight":
                t = {
                    position: new Ee,
                    color: new pn,
                    distance: 0,
                    decay: 0
                };
                break;
            case "HemisphereLight":
                t = {
                    direction: new Ee,
                    skyColor: new pn,
                    groundColor: new pn
                };
                break;
            case "RectAreaLight":
                t = {
                    color: new pn,
                    position: new Ee,
                    halfWidth: new Ee,
                    halfHeight: new Ee
                };
                break
            }
            return n[e.id] = t,
            t
        }
    }
}
function QP() {
    const n = {};
    return {
        get: function(e) {
            if (n[e.id] !== void 0)
                return n[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new _n
                };
                break;
            case "SpotLight":
                t = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new _n
                };
                break;
            case "PointLight":
                t = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new _n,
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3
                };
                break
            }
            return n[e.id] = t,
            t
        }
    }
}
let JP = 0;
function eI(n, e) {
    return (e.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n.map ? 1 : 0)
}
function tI(n) {
    const e = new KP
      , t = QP()
      , r = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1,
            numLightProbes: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotLightMap: [],
        spotShadow: [],
        spotShadowMap: [],
        spotLightMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numSpotLightShadowsWithMaps: 0,
        numLightProbes: 0
    };
    for (let h = 0; h < 9; h++)
        r.probe.push(new Ee);
    const s = new Ee
      , o = new Ln
      , u = new Ln;
    function d(h) {
        let m = 0
          , g = 0
          , _ = 0;
        for (let U = 0; U < 9; U++)
            r.probe[U].set(0, 0, 0);
        let x = 0
          , E = 0
          , M = 0
          , b = 0
          , y = 0
          , T = 0
          , D = 0
          , C = 0
          , P = 0
          , A = 0
          , F = 0;
        h.sort(eI);
        for (let U = 0, R = h.length; U < R; U++) {
            const V = h[U]
              , Q = V.color
              , X = V.intensity
              , oe = V.distance
              , le = V.shadow && V.shadow.map ? V.shadow.map.texture : null;
            if (V.isAmbientLight)
                m += Q.r * X,
                g += Q.g * X,
                _ += Q.b * X;
            else if (V.isLightProbe) {
                for (let O = 0; O < 9; O++)
                    r.probe[O].addScaledVector(V.sh.coefficients[O], X);
                F++
            } else if (V.isDirectionalLight) {
                const O = e.get(V);
                if (O.color.copy(V.color).multiplyScalar(V.intensity),
                V.castShadow) {
                    const W = V.shadow
                      , H = t.get(V);
                    H.shadowIntensity = W.intensity,
                    H.shadowBias = W.bias,
                    H.shadowNormalBias = W.normalBias,
                    H.shadowRadius = W.radius,
                    H.shadowMapSize = W.mapSize,
                    r.directionalShadow[x] = H,
                    r.directionalShadowMap[x] = le,
                    r.directionalShadowMatrix[x] = V.shadow.matrix,
                    T++
                }
                r.directional[x] = O,
                x++
            } else if (V.isSpotLight) {
                const O = e.get(V);
                O.position.setFromMatrixPosition(V.matrixWorld),
                O.color.copy(Q).multiplyScalar(X),
                O.distance = oe,
                O.coneCos = Math.cos(V.angle),
                O.penumbraCos = Math.cos(V.angle * (1 - V.penumbra)),
                O.decay = V.decay,
                r.spot[M] = O;
                const W = V.shadow;
                if (V.map && (r.spotLightMap[P] = V.map,
                P++,
                W.updateMatrices(V),
                V.castShadow && A++),
                r.spotLightMatrix[M] = W.matrix,
                V.castShadow) {
                    const H = t.get(V);
                    H.shadowIntensity = W.intensity,
                    H.shadowBias = W.bias,
                    H.shadowNormalBias = W.normalBias,
                    H.shadowRadius = W.radius,
                    H.shadowMapSize = W.mapSize,
                    r.spotShadow[M] = H,
                    r.spotShadowMap[M] = le,
                    C++
                }
                M++
            } else if (V.isRectAreaLight) {
                const O = e.get(V);
                O.color.copy(Q).multiplyScalar(X),
                O.halfWidth.set(V.width * .5, 0, 0),
                O.halfHeight.set(0, V.height * .5, 0),
                r.rectArea[b] = O,
                b++
            } else if (V.isPointLight) {
                const O = e.get(V);
                if (O.color.copy(V.color).multiplyScalar(V.intensity),
                O.distance = V.distance,
                O.decay = V.decay,
                V.castShadow) {
                    const W = V.shadow
                      , H = t.get(V);
                    H.shadowIntensity = W.intensity,
                    H.shadowBias = W.bias,
                    H.shadowNormalBias = W.normalBias,
                    H.shadowRadius = W.radius,
                    H.shadowMapSize = W.mapSize,
                    H.shadowCameraNear = W.camera.near,
                    H.shadowCameraFar = W.camera.far,
                    r.pointShadow[E] = H,
                    r.pointShadowMap[E] = le,
                    r.pointShadowMatrix[E] = V.shadow.matrix,
                    D++
                }
                r.point[E] = O,
                E++
            } else if (V.isHemisphereLight) {
                const O = e.get(V);
                O.skyColor.copy(V.color).multiplyScalar(X),
                O.groundColor.copy(V.groundColor).multiplyScalar(X),
                r.hemi[y] = O,
                y++
            }
        }
        b > 0 && (n.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = et.LTC_FLOAT_1,
        r.rectAreaLTC2 = et.LTC_FLOAT_2) : (r.rectAreaLTC1 = et.LTC_HALF_1,
        r.rectAreaLTC2 = et.LTC_HALF_2)),
        r.ambient[0] = m,
        r.ambient[1] = g,
        r.ambient[2] = _;
        const z = r.hash;
        (z.directionalLength !== x || z.pointLength !== E || z.spotLength !== M || z.rectAreaLength !== b || z.hemiLength !== y || z.numDirectionalShadows !== T || z.numPointShadows !== D || z.numSpotShadows !== C || z.numSpotMaps !== P || z.numLightProbes !== F) && (r.directional.length = x,
        r.spot.length = M,
        r.rectArea.length = b,
        r.point.length = E,
        r.hemi.length = y,
        r.directionalShadow.length = T,
        r.directionalShadowMap.length = T,
        r.pointShadow.length = D,
        r.pointShadowMap.length = D,
        r.spotShadow.length = C,
        r.spotShadowMap.length = C,
        r.directionalShadowMatrix.length = T,
        r.pointShadowMatrix.length = D,
        r.spotLightMatrix.length = C + P - A,
        r.spotLightMap.length = P,
        r.numSpotLightShadowsWithMaps = A,
        r.numLightProbes = F,
        z.directionalLength = x,
        z.pointLength = E,
        z.spotLength = M,
        z.rectAreaLength = b,
        z.hemiLength = y,
        z.numDirectionalShadows = T,
        z.numPointShadows = D,
        z.numSpotShadows = C,
        z.numSpotMaps = P,
        z.numLightProbes = F,
        r.version = JP++)
    }
    function f(h, m) {
        let g = 0
          , _ = 0
          , x = 0
          , E = 0
          , M = 0;
        const b = m.matrixWorldInverse;
        for (let y = 0, T = h.length; y < T; y++) {
            const D = h[y];
            if (D.isDirectionalLight) {
                const C = r.directional[g];
                C.direction.setFromMatrixPosition(D.matrixWorld),
                s.setFromMatrixPosition(D.target.matrixWorld),
                C.direction.sub(s),
                C.direction.transformDirection(b),
                g++
            } else if (D.isSpotLight) {
                const C = r.spot[x];
                C.position.setFromMatrixPosition(D.matrixWorld),
                C.position.applyMatrix4(b),
                C.direction.setFromMatrixPosition(D.matrixWorld),
                s.setFromMatrixPosition(D.target.matrixWorld),
                C.direction.sub(s),
                C.direction.transformDirection(b),
                x++
            } else if (D.isRectAreaLight) {
                const C = r.rectArea[E];
                C.position.setFromMatrixPosition(D.matrixWorld),
                C.position.applyMatrix4(b),
                u.identity(),
                o.copy(D.matrixWorld),
                o.premultiply(b),
                u.extractRotation(o),
                C.halfWidth.set(D.width * .5, 0, 0),
                C.halfHeight.set(0, D.height * .5, 0),
                C.halfWidth.applyMatrix4(u),
                C.halfHeight.applyMatrix4(u),
                E++
            } else if (D.isPointLight) {
                const C = r.point[_];
                C.position.setFromMatrixPosition(D.matrixWorld),
                C.position.applyMatrix4(b),
                _++
            } else if (D.isHemisphereLight) {
                const C = r.hemi[M];
                C.direction.setFromMatrixPosition(D.matrixWorld),
                C.direction.transformDirection(b),
                M++
            }
        }
    }
    return {
        setup: d,
        setupView: f,
        state: r
    }
}
function $S(n) {
    const e = new tI(n)
      , t = []
      , r = [];
    function s(m) {
        h.camera = m,
        t.length = 0,
        r.length = 0
    }
    function o(m) {
        t.push(m)
    }
    function u(m) {
        r.push(m)
    }
    function d() {
        e.setup(t)
    }
    function f(m) {
        e.setupView(t, m)
    }
    const h = {
        lightsArray: t,
        shadowsArray: r,
        camera: null,
        lights: e,
        transmissionRenderTarget: {}
    };
    return {
        init: s,
        state: h,
        setupLights: d,
        setupLightsView: f,
        pushLight: o,
        pushShadow: u
    }
}
function nI(n) {
    let e = new WeakMap;
    function t(s, o=0) {
        const u = e.get(s);
        let d;
        return u === void 0 ? (d = new $S(n),
        e.set(s, [d])) : o >= u.length ? (d = new $S(n),
        u.push(d)) : d = u[o],
        d
    }
    function r() {
        e = new WeakMap
    }
    return {
        get: t,
        dispose: r
    }
}
const iI = `void main() {
	gl_Position = vec4( position, 1.0 );
}`
  , rI = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function aI(n, e, t) {
    let r = new d_;
    const s = new _n
      , o = new _n
      , u = new zn
      , d = new ML({
        depthPacking: IU
    })
      , f = new wL
      , h = {}
      , m = t.maxTextureSize
      , g = {
        [_s]: Ni,
        [Ni]: _s,
        [_a]: _a
    }
      , _ = new ys({
        defines: {
            VSM_SAMPLES: 8
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new _n
            },
            radius: {
                value: 4
            }
        },
        vertexShader: iI,
        fragmentShader: rI
    })
      , x = _.clone();
    x.defines.HORIZONTAL_PASS = 1;
    const E = new Ir;
    E.setAttribute("position", new ar(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
    const M = new ba(E,_)
      , b = this;
    this.enabled = !1,
    this.autoUpdate = !0,
    this.needsUpdate = !1,
    this.type = IM;
    let y = this.type;
    this.render = function(A, F, z) {
        if (b.enabled === !1 || b.autoUpdate === !1 && b.needsUpdate === !1 || A.length === 0)
            return;
        const U = n.getRenderTarget()
          , R = n.getActiveCubeFace()
          , V = n.getActiveMipmapLevel()
          , Q = n.state;
        Q.setBlending(ms),
        Q.buffers.color.setClear(1, 1, 1, 1),
        Q.buffers.depth.setTest(!0),
        Q.setScissorTest(!1);
        const X = y !== ua && this.type === ua
          , oe = y === ua && this.type !== ua;
        for (let le = 0, O = A.length; le < O; le++) {
            const W = A[le]
              , H = W.shadow;
            if (H === void 0) {
                console.warn("THREE.WebGLShadowMap:", W, "has no shadow.");
                continue
            }
            if (H.autoUpdate === !1 && H.needsUpdate === !1)
                continue;
            s.copy(H.mapSize);
            const Me = H.getFrameExtents();
            if (s.multiply(Me),
            o.copy(H.mapSize),
            (s.x > m || s.y > m) && (s.x > m && (o.x = Math.floor(m / Me.x),
            s.x = o.x * Me.x,
            H.mapSize.x = o.x),
            s.y > m && (o.y = Math.floor(m / Me.y),
            s.y = o.y * Me.y,
            H.mapSize.y = o.y)),
            H.map === null || X === !0 || oe === !0) {
                const ee = this.type !== ua ? {
                    minFilter: xr,
                    magFilter: xr
                } : {};
                H.map !== null && H.map.dispose(),
                H.map = new io(s.x,s.y,ee),
                H.map.texture.name = W.name + ".shadowMap",
                H.camera.updateProjectionMatrix()
            }
            n.setRenderTarget(H.map),
            n.clear();
            const k = H.getViewportCount();
            for (let ee = 0; ee < k; ee++) {
                const ge = H.getViewport(ee);
                u.set(o.x * ge.x, o.y * ge.y, o.x * ge.z, o.y * ge.w),
                Q.viewport(u),
                H.updateMatrices(W, ee),
                r = H.getFrustum(),
                C(F, z, H.camera, W, this.type)
            }
            H.isPointLightShadow !== !0 && this.type === ua && T(H, z),
            H.needsUpdate = !1
        }
        y = this.type,
        b.needsUpdate = !1,
        n.setRenderTarget(U, R, V)
    }
    ;
    function T(A, F) {
        const z = e.update(M);
        _.defines.VSM_SAMPLES !== A.blurSamples && (_.defines.VSM_SAMPLES = A.blurSamples,
        x.defines.VSM_SAMPLES = A.blurSamples,
        _.needsUpdate = !0,
        x.needsUpdate = !0),
        A.mapPass === null && (A.mapPass = new io(s.x,s.y)),
        _.uniforms.shadow_pass.value = A.map.texture,
        _.uniforms.resolution.value = A.mapSize,
        _.uniforms.radius.value = A.radius,
        n.setRenderTarget(A.mapPass),
        n.clear(),
        n.renderBufferDirect(F, null, z, _, M, null),
        x.uniforms.shadow_pass.value = A.mapPass.texture,
        x.uniforms.resolution.value = A.mapSize,
        x.uniforms.radius.value = A.radius,
        n.setRenderTarget(A.map),
        n.clear(),
        n.renderBufferDirect(F, null, z, x, M, null)
    }
    function D(A, F, z, U) {
        let R = null;
        const V = z.isPointLight === !0 ? A.customDistanceMaterial : A.customDepthMaterial;
        if (V !== void 0)
            R = V;
        else if (R = z.isPointLight === !0 ? f : d,
        n.localClippingEnabled && F.clipShadows === !0 && Array.isArray(F.clippingPlanes) && F.clippingPlanes.length !== 0 || F.displacementMap && F.displacementScale !== 0 || F.alphaMap && F.alphaTest > 0 || F.map && F.alphaTest > 0) {
            const Q = R.uuid
              , X = F.uuid;
            let oe = h[Q];
            oe === void 0 && (oe = {},
            h[Q] = oe);
            let le = oe[X];
            le === void 0 && (le = R.clone(),
            oe[X] = le,
            F.addEventListener("dispose", P)),
            R = le
        }
        if (R.visible = F.visible,
        R.wireframe = F.wireframe,
        U === ua ? R.side = F.shadowSide !== null ? F.shadowSide : F.side : R.side = F.shadowSide !== null ? F.shadowSide : g[F.side],
        R.alphaMap = F.alphaMap,
        R.alphaTest = F.alphaTest,
        R.map = F.map,
        R.clipShadows = F.clipShadows,
        R.clippingPlanes = F.clippingPlanes,
        R.clipIntersection = F.clipIntersection,
        R.displacementMap = F.displacementMap,
        R.displacementScale = F.displacementScale,
        R.displacementBias = F.displacementBias,
        R.wireframeLinewidth = F.wireframeLinewidth,
        R.linewidth = F.linewidth,
        z.isPointLight === !0 && R.isMeshDistanceMaterial === !0) {
            const Q = n.properties.get(R);
            Q.light = z
        }
        return R
    }
    function C(A, F, z, U, R) {
        if (A.visible === !1)
            return;
        if (A.layers.test(F.layers) && (A.isMesh || A.isLine || A.isPoints) && (A.castShadow || A.receiveShadow && R === ua) && (!A.frustumCulled || r.intersectsObject(A))) {
            A.modelViewMatrix.multiplyMatrices(z.matrixWorldInverse, A.matrixWorld);
            const X = e.update(A)
              , oe = A.material;
            if (Array.isArray(oe)) {
                const le = X.groups;
                for (let O = 0, W = le.length; O < W; O++) {
                    const H = le[O]
                      , Me = oe[H.materialIndex];
                    if (Me && Me.visible) {
                        const k = D(A, Me, U, R);
                        A.onBeforeShadow(n, A, F, z, X, k, H),
                        n.renderBufferDirect(z, null, X, k, A, H),
                        A.onAfterShadow(n, A, F, z, X, k, H)
                    }
                }
            } else if (oe.visible) {
                const le = D(A, oe, U, R);
                A.onBeforeShadow(n, A, F, z, X, le, null),
                n.renderBufferDirect(z, null, X, le, A, null),
                A.onAfterShadow(n, A, F, z, X, le, null)
            }
        }
        const Q = A.children;
        for (let X = 0, oe = Q.length; X < oe; X++)
            C(Q[X], F, z, U, R)
    }
    function P(A) {
        A.target.removeEventListener("dispose", P);
        for (const z in h) {
            const U = h[z]
              , R = A.target.uuid;
            R in U && (U[R].dispose(),
            delete U[R])
        }
    }
}
const sI = {
    [Fg]: Bg,
    [Vg]: jg,
    [Hg]: Wg,
    [pl]: Gg,
    [Bg]: Fg,
    [jg]: Vg,
    [Wg]: Hg,
    [Gg]: pl
};
function oI(n, e) {
    function t() {
        let re = !1;
        const Ye = new zn;
        let Te = null;
        const Ne = new zn(0,0,0,0);
        return {
            setMask: function(Ke) {
                Te !== Ke && !re && (n.colorMask(Ke, Ke, Ke, Ke),
                Te = Ke)
            },
            setLocked: function(Ke) {
                re = Ke
            },
            setClear: function(Ke, Ce, at, zt, nn) {
                nn === !0 && (Ke *= zt,
                Ce *= zt,
                at *= zt),
                Ye.set(Ke, Ce, at, zt),
                Ne.equals(Ye) === !1 && (n.clearColor(Ke, Ce, at, zt),
                Ne.copy(Ye))
            },
            reset: function() {
                re = !1,
                Te = null,
                Ne.set(-1, 0, 0, 0)
            }
        }
    }
    function r() {
        let re = !1
          , Ye = !1
          , Te = null
          , Ne = null
          , Ke = null;
        return {
            setReversed: function(Ce) {
                if (Ye !== Ce) {
                    const at = e.get("EXT_clip_control");
                    Ce ? at.clipControlEXT(at.LOWER_LEFT_EXT, at.ZERO_TO_ONE_EXT) : at.clipControlEXT(at.LOWER_LEFT_EXT, at.NEGATIVE_ONE_TO_ONE_EXT),
                    Ye = Ce;
                    const zt = Ke;
                    Ke = null,
                    this.setClear(zt)
                }
            },
            getReversed: function() {
                return Ye
            },
            setTest: function(Ce) {
                Ce ? De(n.DEPTH_TEST) : Ve(n.DEPTH_TEST)
            },
            setMask: function(Ce) {
                Te !== Ce && !re && (n.depthMask(Ce),
                Te = Ce)
            },
            setFunc: function(Ce) {
                if (Ye && (Ce = sI[Ce]),
                Ne !== Ce) {
                    switch (Ce) {
                    case Fg:
                        n.depthFunc(n.NEVER);
                        break;
                    case Bg:
                        n.depthFunc(n.ALWAYS);
                        break;
                    case Vg:
                        n.depthFunc(n.LESS);
                        break;
                    case pl:
                        n.depthFunc(n.LEQUAL);
                        break;
                    case Hg:
                        n.depthFunc(n.EQUAL);
                        break;
                    case Gg:
                        n.depthFunc(n.GEQUAL);
                        break;
                    case jg:
                        n.depthFunc(n.GREATER);
                        break;
                    case Wg:
                        n.depthFunc(n.NOTEQUAL);
                        break;
                    default:
                        n.depthFunc(n.LEQUAL)
                    }
                    Ne = Ce
                }
            },
            setLocked: function(Ce) {
                re = Ce
            },
            setClear: function(Ce) {
                Ke !== Ce && (Ye && (Ce = 1 - Ce),
                n.clearDepth(Ce),
                Ke = Ce)
            },
            reset: function() {
                re = !1,
                Te = null,
                Ne = null,
                Ke = null,
                Ye = !1
            }
        }
    }
    function s() {
        let re = !1
          , Ye = null
          , Te = null
          , Ne = null
          , Ke = null
          , Ce = null
          , at = null
          , zt = null
          , nn = null;
        return {
            setTest: function(j) {
                re || (j ? De(n.STENCIL_TEST) : Ve(n.STENCIL_TEST))
            },
            setMask: function(j) {
                Ye !== j && !re && (n.stencilMask(j),
                Ye = j)
            },
            setFunc: function(j, ie, fe) {
                (Te !== j || Ne !== ie || Ke !== fe) && (n.stencilFunc(j, ie, fe),
                Te = j,
                Ne = ie,
                Ke = fe)
            },
            setOp: function(j, ie, fe) {
                (Ce !== j || at !== ie || zt !== fe) && (n.stencilOp(j, ie, fe),
                Ce = j,
                at = ie,
                zt = fe)
            },
            setLocked: function(j) {
                re = j
            },
            setClear: function(j) {
                nn !== j && (n.clearStencil(j),
                nn = j)
            },
            reset: function() {
                re = !1,
                Ye = null,
                Te = null,
                Ne = null,
                Ke = null,
                Ce = null,
                at = null,
                zt = null,
                nn = null
            }
        }
    }
    const o = new t
      , u = new r
      , d = new s
      , f = new WeakMap
      , h = new WeakMap;
    let m = {}
      , g = {}
      , _ = new WeakMap
      , x = []
      , E = null
      , M = !1
      , b = null
      , y = null
      , T = null
      , D = null
      , C = null
      , P = null
      , A = null
      , F = new pn(0,0,0)
      , z = 0
      , U = !1
      , R = null
      , V = null
      , Q = null
      , X = null
      , oe = null;
    const le = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let O = !1
      , W = 0;
    const H = n.getParameter(n.VERSION);
    H.indexOf("WebGL") !== -1 ? (W = parseFloat(/^WebGL (\d)/.exec(H)[1]),
    O = W >= 1) : H.indexOf("OpenGL ES") !== -1 && (W = parseFloat(/^OpenGL ES (\d)/.exec(H)[1]),
    O = W >= 2);
    let Me = null
      , k = {};
    const ee = n.getParameter(n.SCISSOR_BOX)
      , ge = n.getParameter(n.VIEWPORT)
      , pe = new zn().fromArray(ee)
      , te = new zn().fromArray(ge);
    function we(re, Ye, Te, Ne) {
        const Ke = new Uint8Array(4)
          , Ce = n.createTexture();
        n.bindTexture(re, Ce),
        n.texParameteri(re, n.TEXTURE_MIN_FILTER, n.NEAREST),
        n.texParameteri(re, n.TEXTURE_MAG_FILTER, n.NEAREST);
        for (let at = 0; at < Te; at++)
            re === n.TEXTURE_3D || re === n.TEXTURE_2D_ARRAY ? n.texImage3D(Ye, 0, n.RGBA, 1, 1, Ne, 0, n.RGBA, n.UNSIGNED_BYTE, Ke) : n.texImage2D(Ye + at, 0, n.RGBA, 1, 1, 0, n.RGBA, n.UNSIGNED_BYTE, Ke);
        return Ce
    }
    const Se = {};
    Se[n.TEXTURE_2D] = we(n.TEXTURE_2D, n.TEXTURE_2D, 1),
    Se[n.TEXTURE_CUBE_MAP] = we(n.TEXTURE_CUBE_MAP, n.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
    Se[n.TEXTURE_2D_ARRAY] = we(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1),
    Se[n.TEXTURE_3D] = we(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1),
    o.setClear(0, 0, 0, 1),
    u.setClear(1),
    d.setClear(0),
    De(n.DEPTH_TEST),
    u.setFunc(pl),
    ot(!1),
    it($b),
    De(n.CULL_FACE),
    G(ms);
    function De(re) {
        m[re] !== !0 && (n.enable(re),
        m[re] = !0)
    }
    function Ve(re) {
        m[re] !== !1 && (n.disable(re),
        m[re] = !1)
    }
    function _t(re, Ye) {
        return g[re] !== Ye ? (n.bindFramebuffer(re, Ye),
        g[re] = Ye,
        re === n.DRAW_FRAMEBUFFER && (g[n.FRAMEBUFFER] = Ye),
        re === n.FRAMEBUFFER && (g[n.DRAW_FRAMEBUFFER] = Ye),
        !0) : !1
    }
    function He(re, Ye) {
        let Te = x
          , Ne = !1;
        if (re) {
            Te = _.get(Ye),
            Te === void 0 && (Te = [],
            _.set(Ye, Te));
            const Ke = re.textures;
            if (Te.length !== Ke.length || Te[0] !== n.COLOR_ATTACHMENT0) {
                for (let Ce = 0, at = Ke.length; Ce < at; Ce++)
                    Te[Ce] = n.COLOR_ATTACHMENT0 + Ce;
                Te.length = Ke.length,
                Ne = !0
            }
        } else
            Te[0] !== n.BACK && (Te[0] = n.BACK,
            Ne = !0);
        Ne && n.drawBuffers(Te)
    }
    function Pt(re) {
        return E !== re ? (n.useProgram(re),
        E = re,
        !0) : !1
    }
    const kt = {
        [Ys]: n.FUNC_ADD,
        [lU]: n.FUNC_SUBTRACT,
        [cU]: n.FUNC_REVERSE_SUBTRACT
    };
    kt[uU] = n.MIN,
    kt[dU] = n.MAX;
    const nt = {
        [fU]: n.ZERO,
        [hU]: n.ONE,
        [pU]: n.SRC_COLOR,
        [zg]: n.SRC_ALPHA,
        [xU]: n.SRC_ALPHA_SATURATE,
        [_U]: n.DST_COLOR,
        [gU]: n.DST_ALPHA,
        [mU]: n.ONE_MINUS_SRC_COLOR,
        [kg]: n.ONE_MINUS_SRC_ALPHA,
        [yU]: n.ONE_MINUS_DST_COLOR,
        [vU]: n.ONE_MINUS_DST_ALPHA,
        [bU]: n.CONSTANT_COLOR,
        [SU]: n.ONE_MINUS_CONSTANT_COLOR,
        [EU]: n.CONSTANT_ALPHA,
        [MU]: n.ONE_MINUS_CONSTANT_ALPHA
    };
    function G(re, Ye, Te, Ne, Ke, Ce, at, zt, nn, j) {
        if (re === ms) {
            M === !0 && (Ve(n.BLEND),
            M = !1);
            return
        }
        if (M === !1 && (De(n.BLEND),
        M = !0),
        re !== oU) {
            if (re !== b || j !== U) {
                if ((y !== Ys || C !== Ys) && (n.blendEquation(n.FUNC_ADD),
                y = Ys,
                C = Ys),
                j)
                    switch (re) {
                    case ul:
                        n.blendFuncSeparate(n.ONE, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
                        break;
                    case Kb:
                        n.blendFunc(n.ONE, n.ONE);
                        break;
                    case Qb:
                        n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
                        break;
                    case Jb:
                        n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", re);
                        break
                    }
                else
                    switch (re) {
                    case ul:
                        n.blendFuncSeparate(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
                        break;
                    case Kb:
                        n.blendFunc(n.SRC_ALPHA, n.ONE);
                        break;
                    case Qb:
                        n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
                        break;
                    case Jb:
                        n.blendFunc(n.ZERO, n.SRC_COLOR);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", re);
                        break
                    }
                T = null,
                D = null,
                P = null,
                A = null,
                F.set(0, 0, 0),
                z = 0,
                b = re,
                U = j
            }
            return
        }
        Ke = Ke || Ye,
        Ce = Ce || Te,
        at = at || Ne,
        (Ye !== y || Ke !== C) && (n.blendEquationSeparate(kt[Ye], kt[Ke]),
        y = Ye,
        C = Ke),
        (Te !== T || Ne !== D || Ce !== P || at !== A) && (n.blendFuncSeparate(nt[Te], nt[Ne], nt[Ce], nt[at]),
        T = Te,
        D = Ne,
        P = Ce,
        A = at),
        (zt.equals(F) === !1 || nn !== z) && (n.blendColor(zt.r, zt.g, zt.b, nn),
        F.copy(zt),
        z = nn),
        b = re,
        U = !1
    }
    function Zt(re, Ye) {
        re.side === _a ? Ve(n.CULL_FACE) : De(n.CULL_FACE);
        let Te = re.side === Ni;
        Ye && (Te = !Te),
        ot(Te),
        re.blending === ul && re.transparent === !1 ? G(ms) : G(re.blending, re.blendEquation, re.blendSrc, re.blendDst, re.blendEquationAlpha, re.blendSrcAlpha, re.blendDstAlpha, re.blendColor, re.blendAlpha, re.premultipliedAlpha),
        u.setFunc(re.depthFunc),
        u.setTest(re.depthTest),
        u.setMask(re.depthWrite),
        o.setMask(re.colorWrite);
        const Ne = re.stencilWrite;
        d.setTest(Ne),
        Ne && (d.setMask(re.stencilWriteMask),
        d.setFunc(re.stencilFunc, re.stencilRef, re.stencilFuncMask),
        d.setOp(re.stencilFail, re.stencilZFail, re.stencilZPass)),
        pt(re.polygonOffset, re.polygonOffsetFactor, re.polygonOffsetUnits),
        re.alphaToCoverage === !0 ? De(n.SAMPLE_ALPHA_TO_COVERAGE) : Ve(n.SAMPLE_ALPHA_TO_COVERAGE)
    }
    function ot(re) {
        R !== re && (re ? n.frontFace(n.CW) : n.frontFace(n.CCW),
        R = re)
    }
    function it(re) {
        re !== rU ? (De(n.CULL_FACE),
        re !== V && (re === $b ? n.cullFace(n.BACK) : re === aU ? n.cullFace(n.FRONT) : n.cullFace(n.FRONT_AND_BACK))) : Ve(n.CULL_FACE),
        V = re
    }
    function rt(re) {
        re !== Q && (O && n.lineWidth(re),
        Q = re)
    }
    function pt(re, Ye, Te) {
        re ? (De(n.POLYGON_OFFSET_FILL),
        (X !== Ye || oe !== Te) && (n.polygonOffset(Ye, Te),
        X = Ye,
        oe = Te)) : Ve(n.POLYGON_OFFSET_FILL)
    }
    function Xe(re) {
        re ? De(n.SCISSOR_TEST) : Ve(n.SCISSOR_TEST)
    }
    function B(re) {
        re === void 0 && (re = n.TEXTURE0 + le - 1),
        Me !== re && (n.activeTexture(re),
        Me = re)
    }
    function S(re, Ye, Te) {
        Te === void 0 && (Me === null ? Te = n.TEXTURE0 + le - 1 : Te = Me);
        let Ne = k[Te];
        Ne === void 0 && (Ne = {
            type: void 0,
            texture: void 0
        },
        k[Te] = Ne),
        (Ne.type !== re || Ne.texture !== Ye) && (Me !== Te && (n.activeTexture(Te),
        Me = Te),
        n.bindTexture(re, Ye || Se[re]),
        Ne.type = re,
        Ne.texture = Ye)
    }
    function I() {
        const re = k[Me];
        re !== void 0 && re.type !== void 0 && (n.bindTexture(re.type, null),
        re.type = void 0,
        re.texture = void 0)
    }
    function q() {
        try {
            n.compressedTexImage2D(...arguments)
        } catch (re) {
            console.error("THREE.WebGLState:", re)
        }
    }
    function se() {
        try {
            n.compressedTexImage3D(...arguments)
        } catch (re) {
            console.error("THREE.WebGLState:", re)
        }
    }
    function J() {
        try {
            n.texSubImage2D(...arguments)
        } catch (re) {
            console.error("THREE.WebGLState:", re)
        }
    }
    function de() {
        try {
            n.texSubImage3D(...arguments)
        } catch (re) {
            console.error("THREE.WebGLState:", re)
        }
    }
    function _e() {
        try {
            n.compressedTexSubImage2D(...arguments)
        } catch (re) {
            console.error("THREE.WebGLState:", re)
        }
    }
    function Ae() {
        try {
            n.compressedTexSubImage3D(...arguments)
        } catch (re) {
            console.error("THREE.WebGLState:", re)
        }
    }
    function lt() {
        try {
            n.texStorage2D(...arguments)
        } catch (re) {
            console.error("THREE.WebGLState:", re)
        }
    }
    function Le() {
        try {
            n.texStorage3D(...arguments)
        } catch (re) {
            console.error("THREE.WebGLState:", re)
        }
    }
    function $e() {
        try {
            n.texImage2D(...arguments)
        } catch (re) {
            console.error("THREE.WebGLState:", re)
        }
    }
    function ht() {
        try {
            n.texImage3D(...arguments)
        } catch (re) {
            console.error("THREE.WebGLState:", re)
        }
    }
    function yt(re) {
        pe.equals(re) === !1 && (n.scissor(re.x, re.y, re.z, re.w),
        pe.copy(re))
    }
    function qe(re) {
        te.equals(re) === !1 && (n.viewport(re.x, re.y, re.z, re.w),
        te.copy(re))
    }
    function Lt(re, Ye) {
        let Te = h.get(Ye);
        Te === void 0 && (Te = new WeakMap,
        h.set(Ye, Te));
        let Ne = Te.get(re);
        Ne === void 0 && (Ne = n.getUniformBlockIndex(Ye, re.name),
        Te.set(re, Ne))
    }
    function Tt(re, Ye) {
        const Ne = h.get(Ye).get(re);
        f.get(Ye) !== Ne && (n.uniformBlockBinding(Ye, Ne, re.__bindingPointIndex),
        f.set(Ye, Ne))
    }
    function qt() {
        n.disable(n.BLEND),
        n.disable(n.CULL_FACE),
        n.disable(n.DEPTH_TEST),
        n.disable(n.POLYGON_OFFSET_FILL),
        n.disable(n.SCISSOR_TEST),
        n.disable(n.STENCIL_TEST),
        n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),
        n.blendEquation(n.FUNC_ADD),
        n.blendFunc(n.ONE, n.ZERO),
        n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO),
        n.blendColor(0, 0, 0, 0),
        n.colorMask(!0, !0, !0, !0),
        n.clearColor(0, 0, 0, 0),
        n.depthMask(!0),
        n.depthFunc(n.LESS),
        u.setReversed(!1),
        n.clearDepth(1),
        n.stencilMask(4294967295),
        n.stencilFunc(n.ALWAYS, 0, 4294967295),
        n.stencilOp(n.KEEP, n.KEEP, n.KEEP),
        n.clearStencil(0),
        n.cullFace(n.BACK),
        n.frontFace(n.CCW),
        n.polygonOffset(0, 0),
        n.activeTexture(n.TEXTURE0),
        n.bindFramebuffer(n.FRAMEBUFFER, null),
        n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
        n.bindFramebuffer(n.READ_FRAMEBUFFER, null),
        n.useProgram(null),
        n.lineWidth(1),
        n.scissor(0, 0, n.canvas.width, n.canvas.height),
        n.viewport(0, 0, n.canvas.width, n.canvas.height),
        m = {},
        Me = null,
        k = {},
        g = {},
        _ = new WeakMap,
        x = [],
        E = null,
        M = !1,
        b = null,
        y = null,
        T = null,
        D = null,
        C = null,
        P = null,
        A = null,
        F = new pn(0,0,0),
        z = 0,
        U = !1,
        R = null,
        V = null,
        Q = null,
        X = null,
        oe = null,
        pe.set(0, 0, n.canvas.width, n.canvas.height),
        te.set(0, 0, n.canvas.width, n.canvas.height),
        o.reset(),
        u.reset(),
        d.reset()
    }
    return {
        buffers: {
            color: o,
            depth: u,
            stencil: d
        },
        enable: De,
        disable: Ve,
        bindFramebuffer: _t,
        drawBuffers: He,
        useProgram: Pt,
        setBlending: G,
        setMaterial: Zt,
        setFlipSided: ot,
        setCullFace: it,
        setLineWidth: rt,
        setPolygonOffset: pt,
        setScissorTest: Xe,
        activeTexture: B,
        bindTexture: S,
        unbindTexture: I,
        compressedTexImage2D: q,
        compressedTexImage3D: se,
        texImage2D: $e,
        texImage3D: ht,
        updateUBOMapping: Lt,
        uniformBlockBinding: Tt,
        texStorage2D: lt,
        texStorage3D: Le,
        texSubImage2D: J,
        texSubImage3D: de,
        compressedTexSubImage2D: _e,
        compressedTexSubImage3D: Ae,
        scissor: yt,
        viewport: qe,
        reset: qt
    }
}
function lI(n, e, t, r, s, o, u) {
    const d = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null
      , f = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent)
      , h = new _n
      , m = new WeakMap;
    let g;
    const _ = new WeakMap;
    let x = !1;
    try {
        x = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") !== null
    } catch {}
    function E(B, S) {
        return x ? new OffscreenCanvas(B,S) : nu("canvas")
    }
    function M(B, S, I) {
        let q = 1;
        const se = Xe(B);
        if ((se.width > I || se.height > I) && (q = I / Math.max(se.width, se.height)),
        q < 1)
            if (typeof HTMLImageElement < "u" && B instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && B instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && B instanceof ImageBitmap || typeof VideoFrame < "u" && B instanceof VideoFrame) {
                const J = Math.floor(q * se.width)
                  , de = Math.floor(q * se.height);
                g === void 0 && (g = E(J, de));
                const _e = S ? E(J, de) : g;
                return _e.width = J,
                _e.height = de,
                _e.getContext("2d").drawImage(B, 0, 0, J, de),
                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + se.width + "x" + se.height + ") to (" + J + "x" + de + ")."),
                _e
            } else
                return "data"in B && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + se.width + "x" + se.height + ")."),
                B;
        return B
    }
    function b(B) {
        return B.generateMipmaps
    }
    function y(B) {
        n.generateMipmap(B)
    }
    function T(B) {
        return B.isWebGLCubeRenderTarget ? n.TEXTURE_CUBE_MAP : B.isWebGL3DRenderTarget ? n.TEXTURE_3D : B.isWebGLArrayRenderTarget || B.isCompressedArrayTexture ? n.TEXTURE_2D_ARRAY : n.TEXTURE_2D
    }
    function D(B, S, I, q, se=!1) {
        if (B !== null) {
            if (n[B] !== void 0)
                return n[B];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + B + "'")
        }
        let J = S;
        if (S === n.RED && (I === n.FLOAT && (J = n.R32F),
        I === n.HALF_FLOAT && (J = n.R16F),
        I === n.UNSIGNED_BYTE && (J = n.R8)),
        S === n.RED_INTEGER && (I === n.UNSIGNED_BYTE && (J = n.R8UI),
        I === n.UNSIGNED_SHORT && (J = n.R16UI),
        I === n.UNSIGNED_INT && (J = n.R32UI),
        I === n.BYTE && (J = n.R8I),
        I === n.SHORT && (J = n.R16I),
        I === n.INT && (J = n.R32I)),
        S === n.RG && (I === n.FLOAT && (J = n.RG32F),
        I === n.HALF_FLOAT && (J = n.RG16F),
        I === n.UNSIGNED_BYTE && (J = n.RG8)),
        S === n.RG_INTEGER && (I === n.UNSIGNED_BYTE && (J = n.RG8UI),
        I === n.UNSIGNED_SHORT && (J = n.RG16UI),
        I === n.UNSIGNED_INT && (J = n.RG32UI),
        I === n.BYTE && (J = n.RG8I),
        I === n.SHORT && (J = n.RG16I),
        I === n.INT && (J = n.RG32I)),
        S === n.RGB_INTEGER && (I === n.UNSIGNED_BYTE && (J = n.RGB8UI),
        I === n.UNSIGNED_SHORT && (J = n.RGB16UI),
        I === n.UNSIGNED_INT && (J = n.RGB32UI),
        I === n.BYTE && (J = n.RGB8I),
        I === n.SHORT && (J = n.RGB16I),
        I === n.INT && (J = n.RGB32I)),
        S === n.RGBA_INTEGER && (I === n.UNSIGNED_BYTE && (J = n.RGBA8UI),
        I === n.UNSIGNED_SHORT && (J = n.RGBA16UI),
        I === n.UNSIGNED_INT && (J = n.RGBA32UI),
        I === n.BYTE && (J = n.RGBA8I),
        I === n.SHORT && (J = n.RGBA16I),
        I === n.INT && (J = n.RGBA32I)),
        S === n.RGB && I === n.UNSIGNED_INT_5_9_9_9_REV && (J = n.RGB9_E5),
        S === n.RGBA) {
            const de = se ? wf : fn.getTransfer(q);
            I === n.FLOAT && (J = n.RGBA32F),
            I === n.HALF_FLOAT && (J = n.RGBA16F),
            I === n.UNSIGNED_BYTE && (J = de === Sn ? n.SRGB8_ALPHA8 : n.RGBA8),
            I === n.UNSIGNED_SHORT_4_4_4_4 && (J = n.RGBA4),
            I === n.UNSIGNED_SHORT_5_5_5_1 && (J = n.RGB5_A1)
        }
        return (J === n.R16F || J === n.R32F || J === n.RG16F || J === n.RG32F || J === n.RGBA16F || J === n.RGBA32F) && e.get("EXT_color_buffer_float"),
        J
    }
    function C(B, S) {
        let I;
        return B ? S === null || S === no || S === Jc ? I = n.DEPTH24_STENCIL8 : S === ya ? I = n.DEPTH32F_STENCIL8 : S === Qc && (I = n.DEPTH24_STENCIL8,
        console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : S === null || S === no || S === Jc ? I = n.DEPTH_COMPONENT24 : S === ya ? I = n.DEPTH_COMPONENT32F : S === Qc && (I = n.DEPTH_COMPONENT16),
        I
    }
    function P(B, S) {
        return b(B) === !0 || B.isFramebufferTexture && B.minFilter !== xr && B.minFilter !== Ur ? Math.log2(Math.max(S.width, S.height)) + 1 : B.mipmaps !== void 0 && B.mipmaps.length > 0 ? B.mipmaps.length : B.isCompressedTexture && Array.isArray(B.image) ? S.mipmaps.length : 1
    }
    function A(B) {
        const S = B.target;
        S.removeEventListener("dispose", A),
        z(S),
        S.isVideoTexture && m.delete(S)
    }
    function F(B) {
        const S = B.target;
        S.removeEventListener("dispose", F),
        R(S)
    }
    function z(B) {
        const S = r.get(B);
        if (S.__webglInit === void 0)
            return;
        const I = B.source
          , q = _.get(I);
        if (q) {
            const se = q[S.__cacheKey];
            se.usedTimes--,
            se.usedTimes === 0 && U(B),
            Object.keys(q).length === 0 && _.delete(I)
        }
        r.remove(B)
    }
    function U(B) {
        const S = r.get(B);
        n.deleteTexture(S.__webglTexture);
        const I = B.source
          , q = _.get(I);
        delete q[S.__cacheKey],
        u.memory.textures--
    }
    function R(B) {
        const S = r.get(B);
        if (B.depthTexture && (B.depthTexture.dispose(),
        r.remove(B.depthTexture)),
        B.isWebGLCubeRenderTarget)
            for (let q = 0; q < 6; q++) {
                if (Array.isArray(S.__webglFramebuffer[q]))
                    for (let se = 0; se < S.__webglFramebuffer[q].length; se++)
                        n.deleteFramebuffer(S.__webglFramebuffer[q][se]);
                else
                    n.deleteFramebuffer(S.__webglFramebuffer[q]);
                S.__webglDepthbuffer && n.deleteRenderbuffer(S.__webglDepthbuffer[q])
            }
        else {
            if (Array.isArray(S.__webglFramebuffer))
                for (let q = 0; q < S.__webglFramebuffer.length; q++)
                    n.deleteFramebuffer(S.__webglFramebuffer[q]);
            else
                n.deleteFramebuffer(S.__webglFramebuffer);
            if (S.__webglDepthbuffer && n.deleteRenderbuffer(S.__webglDepthbuffer),
            S.__webglMultisampledFramebuffer && n.deleteFramebuffer(S.__webglMultisampledFramebuffer),
            S.__webglColorRenderbuffer)
                for (let q = 0; q < S.__webglColorRenderbuffer.length; q++)
                    S.__webglColorRenderbuffer[q] && n.deleteRenderbuffer(S.__webglColorRenderbuffer[q]);
            S.__webglDepthRenderbuffer && n.deleteRenderbuffer(S.__webglDepthRenderbuffer)
        }
        const I = B.textures;
        for (let q = 0, se = I.length; q < se; q++) {
            const J = r.get(I[q]);
            J.__webglTexture && (n.deleteTexture(J.__webglTexture),
            u.memory.textures--),
            r.remove(I[q])
        }
        r.remove(B)
    }
    let V = 0;
    function Q() {
        V = 0
    }
    function X() {
        const B = V;
        return B >= s.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + B + " texture units while this GPU supports only " + s.maxTextures),
        V += 1,
        B
    }
    function oe(B) {
        const S = [];
        return S.push(B.wrapS),
        S.push(B.wrapT),
        S.push(B.wrapR || 0),
        S.push(B.magFilter),
        S.push(B.minFilter),
        S.push(B.anisotropy),
        S.push(B.internalFormat),
        S.push(B.format),
        S.push(B.type),
        S.push(B.generateMipmaps),
        S.push(B.premultiplyAlpha),
        S.push(B.flipY),
        S.push(B.unpackAlignment),
        S.push(B.colorSpace),
        S.join()
    }
    function le(B, S) {
        const I = r.get(B);
        if (B.isVideoTexture && rt(B),
        B.isRenderTargetTexture === !1 && B.version > 0 && I.__version !== B.version) {
            const q = B.image;
            if (q === null)
                console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (q.complete === !1)
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                te(I, B, S);
                return
            }
        }
        t.bindTexture(n.TEXTURE_2D, I.__webglTexture, n.TEXTURE0 + S)
    }
    function O(B, S) {
        const I = r.get(B);
        if (B.version > 0 && I.__version !== B.version) {
            te(I, B, S);
            return
        }
        t.bindTexture(n.TEXTURE_2D_ARRAY, I.__webglTexture, n.TEXTURE0 + S)
    }
    function W(B, S) {
        const I = r.get(B);
        if (B.version > 0 && I.__version !== B.version) {
            te(I, B, S);
            return
        }
        t.bindTexture(n.TEXTURE_3D, I.__webglTexture, n.TEXTURE0 + S)
    }
    function H(B, S) {
        const I = r.get(B);
        if (B.version > 0 && I.__version !== B.version) {
            we(I, B, S);
            return
        }
        t.bindTexture(n.TEXTURE_CUBE_MAP, I.__webglTexture, n.TEXTURE0 + S)
    }
    const Me = {
        [Yg]: n.REPEAT,
        [Ks]: n.CLAMP_TO_EDGE,
        [Zg]: n.MIRRORED_REPEAT
    }
      , k = {
        [xr]: n.NEAREST,
        [OU]: n.NEAREST_MIPMAP_NEAREST,
        [Od]: n.NEAREST_MIPMAP_LINEAR,
        [Ur]: n.LINEAR,
        [zm]: n.LINEAR_MIPMAP_NEAREST,
        [Qs]: n.LINEAR_MIPMAP_LINEAR
    }
      , ee = {
        [FU]: n.NEVER,
        [WU]: n.ALWAYS,
        [BU]: n.LESS,
        [ZM]: n.LEQUAL,
        [VU]: n.EQUAL,
        [jU]: n.GEQUAL,
        [HU]: n.GREATER,
        [GU]: n.NOTEQUAL
    };
    function ge(B, S) {
        if (S.type === ya && e.has("OES_texture_float_linear") === !1 && (S.magFilter === Ur || S.magFilter === zm || S.magFilter === Od || S.magFilter === Qs || S.minFilter === Ur || S.minFilter === zm || S.minFilter === Od || S.minFilter === Qs) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),
        n.texParameteri(B, n.TEXTURE_WRAP_S, Me[S.wrapS]),
        n.texParameteri(B, n.TEXTURE_WRAP_T, Me[S.wrapT]),
        (B === n.TEXTURE_3D || B === n.TEXTURE_2D_ARRAY) && n.texParameteri(B, n.TEXTURE_WRAP_R, Me[S.wrapR]),
        n.texParameteri(B, n.TEXTURE_MAG_FILTER, k[S.magFilter]),
        n.texParameteri(B, n.TEXTURE_MIN_FILTER, k[S.minFilter]),
        S.compareFunction && (n.texParameteri(B, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE),
        n.texParameteri(B, n.TEXTURE_COMPARE_FUNC, ee[S.compareFunction])),
        e.has("EXT_texture_filter_anisotropic") === !0) {
            if (S.magFilter === xr || S.minFilter !== Od && S.minFilter !== Qs || S.type === ya && e.has("OES_texture_float_linear") === !1)
                return;
            if (S.anisotropy > 1 || r.get(S).__currentAnisotropy) {
                const I = e.get("EXT_texture_filter_anisotropic");
                n.texParameterf(B, I.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(S.anisotropy, s.getMaxAnisotropy())),
                r.get(S).__currentAnisotropy = S.anisotropy
            }
        }
    }
    function pe(B, S) {
        let I = !1;
        B.__webglInit === void 0 && (B.__webglInit = !0,
        S.addEventListener("dispose", A));
        const q = S.source;
        let se = _.get(q);
        se === void 0 && (se = {},
        _.set(q, se));
        const J = oe(S);
        if (J !== B.__cacheKey) {
            se[J] === void 0 && (se[J] = {
                texture: n.createTexture(),
                usedTimes: 0
            },
            u.memory.textures++,
            I = !0),
            se[J].usedTimes++;
            const de = se[B.__cacheKey];
            de !== void 0 && (se[B.__cacheKey].usedTimes--,
            de.usedTimes === 0 && U(S)),
            B.__cacheKey = J,
            B.__webglTexture = se[J].texture
        }
        return I
    }
    function te(B, S, I) {
        let q = n.TEXTURE_2D;
        (S.isDataArrayTexture || S.isCompressedArrayTexture) && (q = n.TEXTURE_2D_ARRAY),
        S.isData3DTexture && (q = n.TEXTURE_3D);
        const se = pe(B, S)
          , J = S.source;
        t.bindTexture(q, B.__webglTexture, n.TEXTURE0 + I);
        const de = r.get(J);
        if (J.version !== de.__version || se === !0) {
            t.activeTexture(n.TEXTURE0 + I);
            const _e = fn.getPrimaries(fn.workingColorSpace)
              , Ae = S.colorSpace === fs ? null : fn.getPrimaries(S.colorSpace)
              , lt = S.colorSpace === fs || _e === Ae ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, S.flipY),
            n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, S.premultiplyAlpha),
            n.pixelStorei(n.UNPACK_ALIGNMENT, S.unpackAlignment),
            n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, lt);
            let Le = M(S.image, !1, s.maxTextureSize);
            Le = pt(S, Le);
            const $e = o.convert(S.format, S.colorSpace)
              , ht = o.convert(S.type);
            let yt = D(S.internalFormat, $e, ht, S.colorSpace, S.isVideoTexture);
            ge(q, S);
            let qe;
            const Lt = S.mipmaps
              , Tt = S.isVideoTexture !== !0
              , qt = de.__version === void 0 || se === !0
              , re = J.dataReady
              , Ye = P(S, Le);
            if (S.isDepthTexture)
                yt = C(S.format === tu, S.type),
                qt && (Tt ? t.texStorage2D(n.TEXTURE_2D, 1, yt, Le.width, Le.height) : t.texImage2D(n.TEXTURE_2D, 0, yt, Le.width, Le.height, 0, $e, ht, null));
            else if (S.isDataTexture)
                if (Lt.length > 0) {
                    Tt && qt && t.texStorage2D(n.TEXTURE_2D, Ye, yt, Lt[0].width, Lt[0].height);
                    for (let Te = 0, Ne = Lt.length; Te < Ne; Te++)
                        qe = Lt[Te],
                        Tt ? re && t.texSubImage2D(n.TEXTURE_2D, Te, 0, 0, qe.width, qe.height, $e, ht, qe.data) : t.texImage2D(n.TEXTURE_2D, Te, yt, qe.width, qe.height, 0, $e, ht, qe.data);
                    S.generateMipmaps = !1
                } else
                    Tt ? (qt && t.texStorage2D(n.TEXTURE_2D, Ye, yt, Le.width, Le.height),
                    re && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, Le.width, Le.height, $e, ht, Le.data)) : t.texImage2D(n.TEXTURE_2D, 0, yt, Le.width, Le.height, 0, $e, ht, Le.data);
            else if (S.isCompressedTexture)
                if (S.isCompressedArrayTexture) {
                    Tt && qt && t.texStorage3D(n.TEXTURE_2D_ARRAY, Ye, yt, Lt[0].width, Lt[0].height, Le.depth);
                    for (let Te = 0, Ne = Lt.length; Te < Ne; Te++)
                        if (qe = Lt[Te],
                        S.format !== yr)
                            if ($e !== null)
                                if (Tt) {
                                    if (re)
                                        if (S.layerUpdates.size > 0) {
                                            const Ke = TS(qe.width, qe.height, S.format, S.type);
                                            for (const Ce of S.layerUpdates) {
                                                const at = qe.data.subarray(Ce * Ke / qe.data.BYTES_PER_ELEMENT, (Ce + 1) * Ke / qe.data.BYTES_PER_ELEMENT);
                                                t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, Te, 0, 0, Ce, qe.width, qe.height, 1, $e, at)
                                            }
                                            S.clearLayerUpdates()
                                        } else
                                            t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, Te, 0, 0, 0, qe.width, qe.height, Le.depth, $e, qe.data)
                                } else
                                    t.compressedTexImage3D(n.TEXTURE_2D_ARRAY, Te, yt, qe.width, qe.height, Le.depth, 0, qe.data, 0, 0);
                            else
                                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                        else
                            Tt ? re && t.texSubImage3D(n.TEXTURE_2D_ARRAY, Te, 0, 0, 0, qe.width, qe.height, Le.depth, $e, ht, qe.data) : t.texImage3D(n.TEXTURE_2D_ARRAY, Te, yt, qe.width, qe.height, Le.depth, 0, $e, ht, qe.data)
                } else {
                    Tt && qt && t.texStorage2D(n.TEXTURE_2D, Ye, yt, Lt[0].width, Lt[0].height);
                    for (let Te = 0, Ne = Lt.length; Te < Ne; Te++)
                        qe = Lt[Te],
                        S.format !== yr ? $e !== null ? Tt ? re && t.compressedTexSubImage2D(n.TEXTURE_2D, Te, 0, 0, qe.width, qe.height, $e, qe.data) : t.compressedTexImage2D(n.TEXTURE_2D, Te, yt, qe.width, qe.height, 0, qe.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Tt ? re && t.texSubImage2D(n.TEXTURE_2D, Te, 0, 0, qe.width, qe.height, $e, ht, qe.data) : t.texImage2D(n.TEXTURE_2D, Te, yt, qe.width, qe.height, 0, $e, ht, qe.data)
                }
            else if (S.isDataArrayTexture)
                if (Tt) {
                    if (qt && t.texStorage3D(n.TEXTURE_2D_ARRAY, Ye, yt, Le.width, Le.height, Le.depth),
                    re)
                        if (S.layerUpdates.size > 0) {
                            const Te = TS(Le.width, Le.height, S.format, S.type);
                            for (const Ne of S.layerUpdates) {
                                const Ke = Le.data.subarray(Ne * Te / Le.data.BYTES_PER_ELEMENT, (Ne + 1) * Te / Le.data.BYTES_PER_ELEMENT);
                                t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, Ne, Le.width, Le.height, 1, $e, ht, Ke)
                            }
                            S.clearLayerUpdates()
                        } else
                            t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, 0, Le.width, Le.height, Le.depth, $e, ht, Le.data)
                } else
                    t.texImage3D(n.TEXTURE_2D_ARRAY, 0, yt, Le.width, Le.height, Le.depth, 0, $e, ht, Le.data);
            else if (S.isData3DTexture)
                Tt ? (qt && t.texStorage3D(n.TEXTURE_3D, Ye, yt, Le.width, Le.height, Le.depth),
                re && t.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, Le.width, Le.height, Le.depth, $e, ht, Le.data)) : t.texImage3D(n.TEXTURE_3D, 0, yt, Le.width, Le.height, Le.depth, 0, $e, ht, Le.data);
            else if (S.isFramebufferTexture) {
                if (qt)
                    if (Tt)
                        t.texStorage2D(n.TEXTURE_2D, Ye, yt, Le.width, Le.height);
                    else {
                        let Te = Le.width
                          , Ne = Le.height;
                        for (let Ke = 0; Ke < Ye; Ke++)
                            t.texImage2D(n.TEXTURE_2D, Ke, yt, Te, Ne, 0, $e, ht, null),
                            Te >>= 1,
                            Ne >>= 1
                    }
            } else if (Lt.length > 0) {
                if (Tt && qt) {
                    const Te = Xe(Lt[0]);
                    t.texStorage2D(n.TEXTURE_2D, Ye, yt, Te.width, Te.height)
                }
                for (let Te = 0, Ne = Lt.length; Te < Ne; Te++)
                    qe = Lt[Te],
                    Tt ? re && t.texSubImage2D(n.TEXTURE_2D, Te, 0, 0, $e, ht, qe) : t.texImage2D(n.TEXTURE_2D, Te, yt, $e, ht, qe);
                S.generateMipmaps = !1
            } else if (Tt) {
                if (qt) {
                    const Te = Xe(Le);
                    t.texStorage2D(n.TEXTURE_2D, Ye, yt, Te.width, Te.height)
                }
                re && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, $e, ht, Le)
            } else
                t.texImage2D(n.TEXTURE_2D, 0, yt, $e, ht, Le);
            b(S) && y(q),
            de.__version = J.version,
            S.onUpdate && S.onUpdate(S)
        }
        B.__version = S.version
    }
    function we(B, S, I) {
        if (S.image.length !== 6)
            return;
        const q = pe(B, S)
          , se = S.source;
        t.bindTexture(n.TEXTURE_CUBE_MAP, B.__webglTexture, n.TEXTURE0 + I);
        const J = r.get(se);
        if (se.version !== J.__version || q === !0) {
            t.activeTexture(n.TEXTURE0 + I);
            const de = fn.getPrimaries(fn.workingColorSpace)
              , _e = S.colorSpace === fs ? null : fn.getPrimaries(S.colorSpace)
              , Ae = S.colorSpace === fs || de === _e ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, S.flipY),
            n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, S.premultiplyAlpha),
            n.pixelStorei(n.UNPACK_ALIGNMENT, S.unpackAlignment),
            n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ae);
            const lt = S.isCompressedTexture || S.image[0].isCompressedTexture
              , Le = S.image[0] && S.image[0].isDataTexture
              , $e = [];
            for (let Ne = 0; Ne < 6; Ne++)
                !lt && !Le ? $e[Ne] = M(S.image[Ne], !0, s.maxCubemapSize) : $e[Ne] = Le ? S.image[Ne].image : S.image[Ne],
                $e[Ne] = pt(S, $e[Ne]);
            const ht = $e[0]
              , yt = o.convert(S.format, S.colorSpace)
              , qe = o.convert(S.type)
              , Lt = D(S.internalFormat, yt, qe, S.colorSpace)
              , Tt = S.isVideoTexture !== !0
              , qt = J.__version === void 0 || q === !0
              , re = se.dataReady;
            let Ye = P(S, ht);
            ge(n.TEXTURE_CUBE_MAP, S);
            let Te;
            if (lt) {
                Tt && qt && t.texStorage2D(n.TEXTURE_CUBE_MAP, Ye, Lt, ht.width, ht.height);
                for (let Ne = 0; Ne < 6; Ne++) {
                    Te = $e[Ne].mipmaps;
                    for (let Ke = 0; Ke < Te.length; Ke++) {
                        const Ce = Te[Ke];
                        S.format !== yr ? yt !== null ? Tt ? re && t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ne, Ke, 0, 0, Ce.width, Ce.height, yt, Ce.data) : t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ne, Ke, Lt, Ce.width, Ce.height, 0, Ce.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Tt ? re && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ne, Ke, 0, 0, Ce.width, Ce.height, yt, qe, Ce.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ne, Ke, Lt, Ce.width, Ce.height, 0, yt, qe, Ce.data)
                    }
                }
            } else {
                if (Te = S.mipmaps,
                Tt && qt) {
                    Te.length > 0 && Ye++;
                    const Ne = Xe($e[0]);
                    t.texStorage2D(n.TEXTURE_CUBE_MAP, Ye, Lt, Ne.width, Ne.height)
                }
                for (let Ne = 0; Ne < 6; Ne++)
                    if (Le) {
                        Tt ? re && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ne, 0, 0, 0, $e[Ne].width, $e[Ne].height, yt, qe, $e[Ne].data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ne, 0, Lt, $e[Ne].width, $e[Ne].height, 0, yt, qe, $e[Ne].data);
                        for (let Ke = 0; Ke < Te.length; Ke++) {
                            const at = Te[Ke].image[Ne].image;
                            Tt ? re && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ne, Ke + 1, 0, 0, at.width, at.height, yt, qe, at.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ne, Ke + 1, Lt, at.width, at.height, 0, yt, qe, at.data)
                        }
                    } else {
                        Tt ? re && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ne, 0, 0, 0, yt, qe, $e[Ne]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ne, 0, Lt, yt, qe, $e[Ne]);
                        for (let Ke = 0; Ke < Te.length; Ke++) {
                            const Ce = Te[Ke];
                            Tt ? re && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ne, Ke + 1, 0, 0, yt, qe, Ce.image[Ne]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ne, Ke + 1, Lt, yt, qe, Ce.image[Ne])
                        }
                    }
            }
            b(S) && y(n.TEXTURE_CUBE_MAP),
            J.__version = se.version,
            S.onUpdate && S.onUpdate(S)
        }
        B.__version = S.version
    }
    function Se(B, S, I, q, se, J) {
        const de = o.convert(I.format, I.colorSpace)
          , _e = o.convert(I.type)
          , Ae = D(I.internalFormat, de, _e, I.colorSpace)
          , lt = r.get(S)
          , Le = r.get(I);
        if (Le.__renderTarget = S,
        !lt.__hasExternalTextures) {
            const $e = Math.max(1, S.width >> J)
              , ht = Math.max(1, S.height >> J);
            se === n.TEXTURE_3D || se === n.TEXTURE_2D_ARRAY ? t.texImage3D(se, J, Ae, $e, ht, S.depth, 0, de, _e, null) : t.texImage2D(se, J, Ae, $e, ht, 0, de, _e, null)
        }
        t.bindFramebuffer(n.FRAMEBUFFER, B),
        it(S) ? d.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, q, se, Le.__webglTexture, 0, ot(S)) : (se === n.TEXTURE_2D || se >= n.TEXTURE_CUBE_MAP_POSITIVE_X && se <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z) && n.framebufferTexture2D(n.FRAMEBUFFER, q, se, Le.__webglTexture, J),
        t.bindFramebuffer(n.FRAMEBUFFER, null)
    }
    function De(B, S, I) {
        if (n.bindRenderbuffer(n.RENDERBUFFER, B),
        S.depthBuffer) {
            const q = S.depthTexture
              , se = q && q.isDepthTexture ? q.type : null
              , J = C(S.stencilBuffer, se)
              , de = S.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT
              , _e = ot(S);
            it(S) ? d.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, _e, J, S.width, S.height) : I ? n.renderbufferStorageMultisample(n.RENDERBUFFER, _e, J, S.width, S.height) : n.renderbufferStorage(n.RENDERBUFFER, J, S.width, S.height),
            n.framebufferRenderbuffer(n.FRAMEBUFFER, de, n.RENDERBUFFER, B)
        } else {
            const q = S.textures;
            for (let se = 0; se < q.length; se++) {
                const J = q[se]
                  , de = o.convert(J.format, J.colorSpace)
                  , _e = o.convert(J.type)
                  , Ae = D(J.internalFormat, de, _e, J.colorSpace)
                  , lt = ot(S);
                I && it(S) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, lt, Ae, S.width, S.height) : it(S) ? d.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, lt, Ae, S.width, S.height) : n.renderbufferStorage(n.RENDERBUFFER, Ae, S.width, S.height)
            }
        }
        n.bindRenderbuffer(n.RENDERBUFFER, null)
    }
    function Ve(B, S) {
        if (S && S.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
        if (t.bindFramebuffer(n.FRAMEBUFFER, B),
        !(S.depthTexture && S.depthTexture.isDepthTexture))
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        const q = r.get(S.depthTexture);
        q.__renderTarget = S,
        (!q.__webglTexture || S.depthTexture.image.width !== S.width || S.depthTexture.image.height !== S.height) && (S.depthTexture.image.width = S.width,
        S.depthTexture.image.height = S.height,
        S.depthTexture.needsUpdate = !0),
        le(S.depthTexture, 0);
        const se = q.__webglTexture
          , J = ot(S);
        if (S.depthTexture.format === eu)
            it(S) ? d.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, se, 0, J) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, se, 0);
        else if (S.depthTexture.format === tu)
            it(S) ? d.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, se, 0, J) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, se, 0);
        else
            throw new Error("Unknown depthTexture format")
    }
    function _t(B) {
        const S = r.get(B)
          , I = B.isWebGLCubeRenderTarget === !0;
        if (S.__boundDepthTexture !== B.depthTexture) {
            const q = B.depthTexture;
            if (S.__depthDisposeCallback && S.__depthDisposeCallback(),
            q) {
                const se = () => {
                    delete S.__boundDepthTexture,
                    delete S.__depthDisposeCallback,
                    q.removeEventListener("dispose", se)
                }
                ;
                q.addEventListener("dispose", se),
                S.__depthDisposeCallback = se
            }
            S.__boundDepthTexture = q
        }
        if (B.depthTexture && !S.__autoAllocateDepthBuffer) {
            if (I)
                throw new Error("target.depthTexture not supported in Cube render targets");
            Ve(S.__webglFramebuffer, B)
        } else if (I) {
            S.__webglDepthbuffer = [];
            for (let q = 0; q < 6; q++)
                if (t.bindFramebuffer(n.FRAMEBUFFER, S.__webglFramebuffer[q]),
                S.__webglDepthbuffer[q] === void 0)
                    S.__webglDepthbuffer[q] = n.createRenderbuffer(),
                    De(S.__webglDepthbuffer[q], B, !1);
                else {
                    const se = B.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT
                      , J = S.__webglDepthbuffer[q];
                    n.bindRenderbuffer(n.RENDERBUFFER, J),
                    n.framebufferRenderbuffer(n.FRAMEBUFFER, se, n.RENDERBUFFER, J)
                }
        } else if (t.bindFramebuffer(n.FRAMEBUFFER, S.__webglFramebuffer),
        S.__webglDepthbuffer === void 0)
            S.__webglDepthbuffer = n.createRenderbuffer(),
            De(S.__webglDepthbuffer, B, !1);
        else {
            const q = B.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT
              , se = S.__webglDepthbuffer;
            n.bindRenderbuffer(n.RENDERBUFFER, se),
            n.framebufferRenderbuffer(n.FRAMEBUFFER, q, n.RENDERBUFFER, se)
        }
        t.bindFramebuffer(n.FRAMEBUFFER, null)
    }
    function He(B, S, I) {
        const q = r.get(B);
        S !== void 0 && Se(q.__webglFramebuffer, B, B.texture, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, 0),
        I !== void 0 && _t(B)
    }
    function Pt(B) {
        const S = B.texture
          , I = r.get(B)
          , q = r.get(S);
        B.addEventListener("dispose", F);
        const se = B.textures
          , J = B.isWebGLCubeRenderTarget === !0
          , de = se.length > 1;
        if (de || (q.__webglTexture === void 0 && (q.__webglTexture = n.createTexture()),
        q.__version = S.version,
        u.memory.textures++),
        J) {
            I.__webglFramebuffer = [];
            for (let _e = 0; _e < 6; _e++)
                if (S.mipmaps && S.mipmaps.length > 0) {
                    I.__webglFramebuffer[_e] = [];
                    for (let Ae = 0; Ae < S.mipmaps.length; Ae++)
                        I.__webglFramebuffer[_e][Ae] = n.createFramebuffer()
                } else
                    I.__webglFramebuffer[_e] = n.createFramebuffer()
        } else {
            if (S.mipmaps && S.mipmaps.length > 0) {
                I.__webglFramebuffer = [];
                for (let _e = 0; _e < S.mipmaps.length; _e++)
                    I.__webglFramebuffer[_e] = n.createFramebuffer()
            } else
                I.__webglFramebuffer = n.createFramebuffer();
            if (de)
                for (let _e = 0, Ae = se.length; _e < Ae; _e++) {
                    const lt = r.get(se[_e]);
                    lt.__webglTexture === void 0 && (lt.__webglTexture = n.createTexture(),
                    u.memory.textures++)
                }
            if (B.samples > 0 && it(B) === !1) {
                I.__webglMultisampledFramebuffer = n.createFramebuffer(),
                I.__webglColorRenderbuffer = [],
                t.bindFramebuffer(n.FRAMEBUFFER, I.__webglMultisampledFramebuffer);
                for (let _e = 0; _e < se.length; _e++) {
                    const Ae = se[_e];
                    I.__webglColorRenderbuffer[_e] = n.createRenderbuffer(),
                    n.bindRenderbuffer(n.RENDERBUFFER, I.__webglColorRenderbuffer[_e]);
                    const lt = o.convert(Ae.format, Ae.colorSpace)
                      , Le = o.convert(Ae.type)
                      , $e = D(Ae.internalFormat, lt, Le, Ae.colorSpace, B.isXRRenderTarget === !0)
                      , ht = ot(B);
                    n.renderbufferStorageMultisample(n.RENDERBUFFER, ht, $e, B.width, B.height),
                    n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + _e, n.RENDERBUFFER, I.__webglColorRenderbuffer[_e])
                }
                n.bindRenderbuffer(n.RENDERBUFFER, null),
                B.depthBuffer && (I.__webglDepthRenderbuffer = n.createRenderbuffer(),
                De(I.__webglDepthRenderbuffer, B, !0)),
                t.bindFramebuffer(n.FRAMEBUFFER, null)
            }
        }
        if (J) {
            t.bindTexture(n.TEXTURE_CUBE_MAP, q.__webglTexture),
            ge(n.TEXTURE_CUBE_MAP, S);
            for (let _e = 0; _e < 6; _e++)
                if (S.mipmaps && S.mipmaps.length > 0)
                    for (let Ae = 0; Ae < S.mipmaps.length; Ae++)
                        Se(I.__webglFramebuffer[_e][Ae], B, S, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + _e, Ae);
                else
                    Se(I.__webglFramebuffer[_e], B, S, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + _e, 0);
            b(S) && y(n.TEXTURE_CUBE_MAP),
            t.unbindTexture()
        } else if (de) {
            for (let _e = 0, Ae = se.length; _e < Ae; _e++) {
                const lt = se[_e]
                  , Le = r.get(lt);
                t.bindTexture(n.TEXTURE_2D, Le.__webglTexture),
                ge(n.TEXTURE_2D, lt),
                Se(I.__webglFramebuffer, B, lt, n.COLOR_ATTACHMENT0 + _e, n.TEXTURE_2D, 0),
                b(lt) && y(n.TEXTURE_2D)
            }
            t.unbindTexture()
        } else {
            let _e = n.TEXTURE_2D;
            if ((B.isWebGL3DRenderTarget || B.isWebGLArrayRenderTarget) && (_e = B.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY),
            t.bindTexture(_e, q.__webglTexture),
            ge(_e, S),
            S.mipmaps && S.mipmaps.length > 0)
                for (let Ae = 0; Ae < S.mipmaps.length; Ae++)
                    Se(I.__webglFramebuffer[Ae], B, S, n.COLOR_ATTACHMENT0, _e, Ae);
            else
                Se(I.__webglFramebuffer, B, S, n.COLOR_ATTACHMENT0, _e, 0);
            b(S) && y(_e),
            t.unbindTexture()
        }
        B.depthBuffer && _t(B)
    }
    function kt(B) {
        const S = B.textures;
        for (let I = 0, q = S.length; I < q; I++) {
            const se = S[I];
            if (b(se)) {
                const J = T(B)
                  , de = r.get(se).__webglTexture;
                t.bindTexture(J, de),
                y(J),
                t.unbindTexture()
            }
        }
    }
    const nt = []
      , G = [];
    function Zt(B) {
        if (B.samples > 0) {
            if (it(B) === !1) {
                const S = B.textures
                  , I = B.width
                  , q = B.height;
                let se = n.COLOR_BUFFER_BIT;
                const J = B.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT
                  , de = r.get(B)
                  , _e = S.length > 1;
                if (_e)
                    for (let Ae = 0; Ae < S.length; Ae++)
                        t.bindFramebuffer(n.FRAMEBUFFER, de.__webglMultisampledFramebuffer),
                        n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Ae, n.RENDERBUFFER, null),
                        t.bindFramebuffer(n.FRAMEBUFFER, de.__webglFramebuffer),
                        n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Ae, n.TEXTURE_2D, null, 0);
                t.bindFramebuffer(n.READ_FRAMEBUFFER, de.__webglMultisampledFramebuffer),
                t.bindFramebuffer(n.DRAW_FRAMEBUFFER, de.__webglFramebuffer);
                for (let Ae = 0; Ae < S.length; Ae++) {
                    if (B.resolveDepthBuffer && (B.depthBuffer && (se |= n.DEPTH_BUFFER_BIT),
                    B.stencilBuffer && B.resolveStencilBuffer && (se |= n.STENCIL_BUFFER_BIT)),
                    _e) {
                        n.framebufferRenderbuffer(n.READ_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, de.__webglColorRenderbuffer[Ae]);
                        const lt = r.get(S[Ae]).__webglTexture;
                        n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, lt, 0)
                    }
                    n.blitFramebuffer(0, 0, I, q, 0, 0, I, q, se, n.NEAREST),
                    f === !0 && (nt.length = 0,
                    G.length = 0,
                    nt.push(n.COLOR_ATTACHMENT0 + Ae),
                    B.depthBuffer && B.resolveDepthBuffer === !1 && (nt.push(J),
                    G.push(J),
                    n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, G)),
                    n.invalidateFramebuffer(n.READ_FRAMEBUFFER, nt))
                }
                if (t.bindFramebuffer(n.READ_FRAMEBUFFER, null),
                t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null),
                _e)
                    for (let Ae = 0; Ae < S.length; Ae++) {
                        t.bindFramebuffer(n.FRAMEBUFFER, de.__webglMultisampledFramebuffer),
                        n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Ae, n.RENDERBUFFER, de.__webglColorRenderbuffer[Ae]);
                        const lt = r.get(S[Ae]).__webglTexture;
                        t.bindFramebuffer(n.FRAMEBUFFER, de.__webglFramebuffer),
                        n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Ae, n.TEXTURE_2D, lt, 0)
                    }
                t.bindFramebuffer(n.DRAW_FRAMEBUFFER, de.__webglMultisampledFramebuffer)
            } else if (B.depthBuffer && B.resolveDepthBuffer === !1 && f) {
                const S = B.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT;
                n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [S])
            }
        }
    }
    function ot(B) {
        return Math.min(s.maxSamples, B.samples)
    }
    function it(B) {
        const S = r.get(B);
        return B.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && S.__useRenderToTexture !== !1
    }
    function rt(B) {
        const S = u.render.frame;
        m.get(B) !== S && (m.set(B, S),
        B.update())
    }
    function pt(B, S) {
        const I = B.colorSpace
          , q = B.format
          , se = B.type;
        return B.isCompressedTexture === !0 || B.isVideoTexture === !0 || I !== vl && I !== fs && (fn.getTransfer(I) === Sn ? (q !== yr || se !== Ta) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", I)),
        S
    }
    function Xe(B) {
        return typeof HTMLImageElement < "u" && B instanceof HTMLImageElement ? (h.width = B.naturalWidth || B.width,
        h.height = B.naturalHeight || B.height) : typeof VideoFrame < "u" && B instanceof VideoFrame ? (h.width = B.displayWidth,
        h.height = B.displayHeight) : (h.width = B.width,
        h.height = B.height),
        h
    }
    this.allocateTextureUnit = X,
    this.resetTextureUnits = Q,
    this.setTexture2D = le,
    this.setTexture2DArray = O,
    this.setTexture3D = W,
    this.setTextureCube = H,
    this.rebindTextures = He,
    this.setupRenderTarget = Pt,
    this.updateRenderTargetMipmap = kt,
    this.updateMultisampleRenderTarget = Zt,
    this.setupDepthRenderbuffer = _t,
    this.setupFrameBufferTexture = Se,
    this.useMultisampledRTT = it
}
function cI(n, e) {
    function t(r, s=fs) {
        let o;
        const u = fn.getTransfer(s);
        if (r === Ta)
            return n.UNSIGNED_BYTE;
        if (r === a_)
            return n.UNSIGNED_SHORT_4_4_4_4;
        if (r === s_)
            return n.UNSIGNED_SHORT_5_5_5_1;
        if (r === VM)
            return n.UNSIGNED_INT_5_9_9_9_REV;
        if (r === FM)
            return n.BYTE;
        if (r === BM)
            return n.SHORT;
        if (r === Qc)
            return n.UNSIGNED_SHORT;
        if (r === r_)
            return n.INT;
        if (r === no)
            return n.UNSIGNED_INT;
        if (r === ya)
            return n.FLOAT;
        if (r === hu)
            return n.HALF_FLOAT;
        if (r === HM)
            return n.ALPHA;
        if (r === GM)
            return n.RGB;
        if (r === yr)
            return n.RGBA;
        if (r === jM)
            return n.LUMINANCE;
        if (r === WM)
            return n.LUMINANCE_ALPHA;
        if (r === eu)
            return n.DEPTH_COMPONENT;
        if (r === tu)
            return n.DEPTH_STENCIL;
        if (r === XM)
            return n.RED;
        if (r === o_)
            return n.RED_INTEGER;
        if (r === qM)
            return n.RG;
        if (r === l_)
            return n.RG_INTEGER;
        if (r === c_)
            return n.RGBA_INTEGER;
        if (r === ff || r === hf || r === pf || r === mf)
            if (u === Sn)
                if (o = e.get("WEBGL_compressed_texture_s3tc_srgb"),
                o !== null) {
                    if (r === ff)
                        return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (r === hf)
                        return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (r === pf)
                        return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (r === mf)
                        return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else
                    return null;
            else if (o = e.get("WEBGL_compressed_texture_s3tc"),
            o !== null) {
                if (r === ff)
                    return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (r === hf)
                    return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (r === pf)
                    return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (r === mf)
                    return o.COMPRESSED_RGBA_S3TC_DXT5_EXT
            } else
                return null;
        if (r === $g || r === Kg || r === Qg || r === Jg)
            if (o = e.get("WEBGL_compressed_texture_pvrtc"),
            o !== null) {
                if (r === $g)
                    return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (r === Kg)
                    return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (r === Qg)
                    return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (r === Jg)
                    return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else
                return null;
        if (r === ev || r === tv || r === nv)
            if (o = e.get("WEBGL_compressed_texture_etc"),
            o !== null) {
                if (r === ev || r === tv)
                    return u === Sn ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
                if (r === nv)
                    return u === Sn ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : o.COMPRESSED_RGBA8_ETC2_EAC
            } else
                return null;
        if (r === iv || r === rv || r === av || r === sv || r === ov || r === lv || r === cv || r === uv || r === dv || r === fv || r === hv || r === pv || r === mv || r === gv)
            if (o = e.get("WEBGL_compressed_texture_astc"),
            o !== null) {
                if (r === iv)
                    return u === Sn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (r === rv)
                    return u === Sn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (r === av)
                    return u === Sn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (r === sv)
                    return u === Sn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (r === ov)
                    return u === Sn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (r === lv)
                    return u === Sn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (r === cv)
                    return u === Sn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (r === uv)
                    return u === Sn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (r === dv)
                    return u === Sn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (r === fv)
                    return u === Sn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (r === hv)
                    return u === Sn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (r === pv)
                    return u === Sn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (r === mv)
                    return u === Sn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (r === gv)
                    return u === Sn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : o.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else
                return null;
        if (r === gf || r === vv || r === _v)
            if (o = e.get("EXT_texture_compression_bptc"),
            o !== null) {
                if (r === gf)
                    return u === Sn ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (r === vv)
                    return o.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (r === _v)
                    return o.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
            } else
                return null;
        if (r === YM || r === yv || r === xv || r === bv)
            if (o = e.get("EXT_texture_compression_rgtc"),
            o !== null) {
                if (r === gf)
                    return o.COMPRESSED_RED_RGTC1_EXT;
                if (r === yv)
                    return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (r === xv)
                    return o.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (r === bv)
                    return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            } else
                return null;
        return r === Jc ? n.UNSIGNED_INT_24_8 : n[r] !== void 0 ? n[r] : null
    }
    return {
        convert: t
    }
}
const uI = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`
  , dI = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class fI {
    constructor() {
        this.texture = null,
        this.mesh = null,
        this.depthNear = 0,
        this.depthFar = 0
    }
    init(e, t, r) {
        if (this.texture === null) {
            const s = new wi
              , o = e.properties.get(s);
            o.__webglTexture = t.texture,
            (t.depthNear !== r.depthNear || t.depthFar !== r.depthFar) && (this.depthNear = t.depthNear,
            this.depthFar = t.depthFar),
            this.texture = s
        }
    }
    getMesh(e) {
        if (this.texture !== null && this.mesh === null) {
            const t = e.cameras[0].viewport
              , r = new ys({
                vertexShader: uI,
                fragmentShader: dI,
                uniforms: {
                    depthColor: {
                        value: this.texture
                    },
                    depthWidth: {
                        value: t.z
                    },
                    depthHeight: {
                        value: t.w
                    }
                }
            });
            this.mesh = new ba(new rh(20,20),r)
        }
        return this.mesh
    }
    reset() {
        this.texture = null,
        this.mesh = null
    }
    getDepthTexture() {
        return this.texture
    }
}
class hI extends wl {
    constructor(e, t) {
        super();
        const r = this;
        let s = null
          , o = 1
          , u = null
          , d = "local-floor"
          , f = 1
          , h = null
          , m = null
          , g = null
          , _ = null
          , x = null
          , E = null;
        const M = new fI
          , b = t.getContextAttributes();
        let y = null
          , T = null;
        const D = []
          , C = []
          , P = new _n;
        let A = null;
        const F = new ir;
        F.viewport = new zn;
        const z = new ir;
        z.viewport = new zn;
        const U = [F, z]
          , R = new OL;
        let V = null
          , Q = null;
        this.cameraAutoUpdate = !0,
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function(te) {
            let we = D[te];
            return we === void 0 && (we = new ag,
            D[te] = we),
            we.getTargetRaySpace()
        }
        ,
        this.getControllerGrip = function(te) {
            let we = D[te];
            return we === void 0 && (we = new ag,
            D[te] = we),
            we.getGripSpace()
        }
        ,
        this.getHand = function(te) {
            let we = D[te];
            return we === void 0 && (we = new ag,
            D[te] = we),
            we.getHandSpace()
        }
        ;
        function X(te) {
            const we = C.indexOf(te.inputSource);
            if (we === -1)
                return;
            const Se = D[we];
            Se !== void 0 && (Se.update(te.inputSource, te.frame, h || u),
            Se.dispatchEvent({
                type: te.type,
                data: te.inputSource
            }))
        }
        function oe() {
            s.removeEventListener("select", X),
            s.removeEventListener("selectstart", X),
            s.removeEventListener("selectend", X),
            s.removeEventListener("squeeze", X),
            s.removeEventListener("squeezestart", X),
            s.removeEventListener("squeezeend", X),
            s.removeEventListener("end", oe),
            s.removeEventListener("inputsourceschange", le);
            for (let te = 0; te < D.length; te++) {
                const we = C[te];
                we !== null && (C[te] = null,
                D[te].disconnect(we))
            }
            V = null,
            Q = null,
            M.reset(),
            e.setRenderTarget(y),
            x = null,
            _ = null,
            g = null,
            s = null,
            T = null,
            pe.stop(),
            r.isPresenting = !1,
            e.setPixelRatio(A),
            e.setSize(P.width, P.height, !1),
            r.dispatchEvent({
                type: "sessionend"
            })
        }
        this.setFramebufferScaleFactor = function(te) {
            o = te,
            r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }
        ,
        this.setReferenceSpaceType = function(te) {
            d = te,
            r.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }
        ,
        this.getReferenceSpace = function() {
            return h || u
        }
        ,
        this.setReferenceSpace = function(te) {
            h = te
        }
        ,
        this.getBaseLayer = function() {
            return _ !== null ? _ : x
        }
        ,
        this.getBinding = function() {
            return g
        }
        ,
        this.getFrame = function() {
            return E
        }
        ,
        this.getSession = function() {
            return s
        }
        ,
        this.setSession = async function(te) {
            if (s = te,
            s !== null) {
                if (y = e.getRenderTarget(),
                s.addEventListener("select", X),
                s.addEventListener("selectstart", X),
                s.addEventListener("selectend", X),
                s.addEventListener("squeeze", X),
                s.addEventListener("squeezestart", X),
                s.addEventListener("squeezeend", X),
                s.addEventListener("end", oe),
                s.addEventListener("inputsourceschange", le),
                b.xrCompatible !== !0 && await t.makeXRCompatible(),
                A = e.getPixelRatio(),
                e.getSize(P),
                typeof XRWebGLBinding < "u" && "createProjectionLayer"in XRWebGLBinding.prototype) {
                    let Se = null
                      , De = null
                      , Ve = null;
                    b.depth && (Ve = b.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24,
                    Se = b.stencil ? tu : eu,
                    De = b.stencil ? Jc : no);
                    const _t = {
                        colorFormat: t.RGBA8,
                        depthFormat: Ve,
                        scaleFactor: o
                    };
                    g = new XRWebGLBinding(s,t),
                    _ = g.createProjectionLayer(_t),
                    s.updateRenderState({
                        layers: [_]
                    }),
                    e.setPixelRatio(1),
                    e.setSize(_.textureWidth, _.textureHeight, !1),
                    T = new io(_.textureWidth,_.textureHeight,{
                        format: yr,
                        type: Ta,
                        depthTexture: new ow(_.textureWidth,_.textureHeight,De,void 0,void 0,void 0,void 0,void 0,void 0,Se),
                        stencilBuffer: b.stencil,
                        colorSpace: e.outputColorSpace,
                        samples: b.antialias ? 4 : 0,
                        resolveDepthBuffer: _.ignoreDepthValues === !1,
                        resolveStencilBuffer: _.ignoreDepthValues === !1
                    })
                } else {
                    const Se = {
                        antialias: b.antialias,
                        alpha: !0,
                        depth: b.depth,
                        stencil: b.stencil,
                        framebufferScaleFactor: o
                    };
                    x = new XRWebGLLayer(s,t,Se),
                    s.updateRenderState({
                        baseLayer: x
                    }),
                    e.setPixelRatio(1),
                    e.setSize(x.framebufferWidth, x.framebufferHeight, !1),
                    T = new io(x.framebufferWidth,x.framebufferHeight,{
                        format: yr,
                        type: Ta,
                        colorSpace: e.outputColorSpace,
                        stencilBuffer: b.stencil,
                        resolveDepthBuffer: x.ignoreDepthValues === !1,
                        resolveStencilBuffer: x.ignoreDepthValues === !1
                    })
                }
                T.isXRRenderTarget = !0,
                this.setFoveation(f),
                h = null,
                u = await s.requestReferenceSpace(d),
                pe.setContext(s),
                pe.start(),
                r.isPresenting = !0,
                r.dispatchEvent({
                    type: "sessionstart"
                })
            }
        }
        ,
        this.getEnvironmentBlendMode = function() {
            if (s !== null)
                return s.environmentBlendMode
        }
        ,
        this.getDepthTexture = function() {
            return M.getDepthTexture()
        }
        ;
        function le(te) {
            for (let we = 0; we < te.removed.length; we++) {
                const Se = te.removed[we]
                  , De = C.indexOf(Se);
                De >= 0 && (C[De] = null,
                D[De].disconnect(Se))
            }
            for (let we = 0; we < te.added.length; we++) {
                const Se = te.added[we];
                let De = C.indexOf(Se);
                if (De === -1) {
                    for (let _t = 0; _t < D.length; _t++)
                        if (_t >= C.length) {
                            C.push(Se),
                            De = _t;
                            break
                        } else if (C[_t] === null) {
                            C[_t] = Se,
                            De = _t;
                            break
                        }
                    if (De === -1)
                        break
                }
                const Ve = D[De];
                Ve && Ve.connect(Se)
            }
        }
        const O = new Ee
          , W = new Ee;
        function H(te, we, Se) {
            O.setFromMatrixPosition(we.matrixWorld),
            W.setFromMatrixPosition(Se.matrixWorld);
            const De = O.distanceTo(W)
              , Ve = we.projectionMatrix.elements
              , _t = Se.projectionMatrix.elements
              , He = Ve[14] / (Ve[10] - 1)
              , Pt = Ve[14] / (Ve[10] + 1)
              , kt = (Ve[9] + 1) / Ve[5]
              , nt = (Ve[9] - 1) / Ve[5]
              , G = (Ve[8] - 1) / Ve[0]
              , Zt = (_t[8] + 1) / _t[0]
              , ot = He * G
              , it = He * Zt
              , rt = De / (-G + Zt)
              , pt = rt * -G;
            if (we.matrixWorld.decompose(te.position, te.quaternion, te.scale),
            te.translateX(pt),
            te.translateZ(rt),
            te.matrixWorld.compose(te.position, te.quaternion, te.scale),
            te.matrixWorldInverse.copy(te.matrixWorld).invert(),
            Ve[10] === -1)
                te.projectionMatrix.copy(we.projectionMatrix),
                te.projectionMatrixInverse.copy(we.projectionMatrixInverse);
            else {
                const Xe = He + rt
                  , B = Pt + rt
                  , S = ot - pt
                  , I = it + (De - pt)
                  , q = kt * Pt / B * Xe
                  , se = nt * Pt / B * Xe;
                te.projectionMatrix.makePerspective(S, I, q, se, Xe, B),
                te.projectionMatrixInverse.copy(te.projectionMatrix).invert()
            }
        }
        function Me(te, we) {
            we === null ? te.matrixWorld.copy(te.matrix) : te.matrixWorld.multiplyMatrices(we.matrixWorld, te.matrix),
            te.matrixWorldInverse.copy(te.matrixWorld).invert()
        }
        this.updateCamera = function(te) {
            if (s === null)
                return;
            let we = te.near
              , Se = te.far;
            M.texture !== null && (M.depthNear > 0 && (we = M.depthNear),
            M.depthFar > 0 && (Se = M.depthFar)),
            R.near = z.near = F.near = we,
            R.far = z.far = F.far = Se,
            (V !== R.near || Q !== R.far) && (s.updateRenderState({
                depthNear: R.near,
                depthFar: R.far
            }),
            V = R.near,
            Q = R.far),
            F.layers.mask = te.layers.mask | 2,
            z.layers.mask = te.layers.mask | 4,
            R.layers.mask = F.layers.mask | z.layers.mask;
            const De = te.parent
              , Ve = R.cameras;
            Me(R, De);
            for (let _t = 0; _t < Ve.length; _t++)
                Me(Ve[_t], De);
            Ve.length === 2 ? H(R, F, z) : R.projectionMatrix.copy(F.projectionMatrix),
            k(te, R, De)
        }
        ;
        function k(te, we, Se) {
            Se === null ? te.matrix.copy(we.matrixWorld) : (te.matrix.copy(Se.matrixWorld),
            te.matrix.invert(),
            te.matrix.multiply(we.matrixWorld)),
            te.matrix.decompose(te.position, te.quaternion, te.scale),
            te.updateMatrixWorld(!0),
            te.projectionMatrix.copy(we.projectionMatrix),
            te.projectionMatrixInverse.copy(we.projectionMatrixInverse),
            te.isPerspectiveCamera && (te.fov = Sv * 2 * Math.atan(1 / te.projectionMatrix.elements[5]),
            te.zoom = 1)
        }
        this.getCamera = function() {
            return R
        }
        ,
        this.getFoveation = function() {
            if (!(_ === null && x === null))
                return f
        }
        ,
        this.setFoveation = function(te) {
            f = te,
            _ !== null && (_.fixedFoveation = te),
            x !== null && x.fixedFoveation !== void 0 && (x.fixedFoveation = te)
        }
        ,
        this.hasDepthSensing = function() {
            return M.texture !== null
        }
        ,
        this.getDepthSensingMesh = function() {
            return M.getMesh(R)
        }
        ;
        let ee = null;
        function ge(te, we) {
            if (m = we.getViewerPose(h || u),
            E = we,
            m !== null) {
                const Se = m.views;
                x !== null && (e.setRenderTargetFramebuffer(T, x.framebuffer),
                e.setRenderTarget(T));
                let De = !1;
                Se.length !== R.cameras.length && (R.cameras.length = 0,
                De = !0);
                for (let He = 0; He < Se.length; He++) {
                    const Pt = Se[He];
                    let kt = null;
                    if (x !== null)
                        kt = x.getViewport(Pt);
                    else {
                        const G = g.getViewSubImage(_, Pt);
                        kt = G.viewport,
                        He === 0 && (e.setRenderTargetTextures(T, G.colorTexture, G.depthStencilTexture),
                        e.setRenderTarget(T))
                    }
                    let nt = U[He];
                    nt === void 0 && (nt = new ir,
                    nt.layers.enable(He),
                    nt.viewport = new zn,
                    U[He] = nt),
                    nt.matrix.fromArray(Pt.transform.matrix),
                    nt.matrix.decompose(nt.position, nt.quaternion, nt.scale),
                    nt.projectionMatrix.fromArray(Pt.projectionMatrix),
                    nt.projectionMatrixInverse.copy(nt.projectionMatrix).invert(),
                    nt.viewport.set(kt.x, kt.y, kt.width, kt.height),
                    He === 0 && (R.matrix.copy(nt.matrix),
                    R.matrix.decompose(R.position, R.quaternion, R.scale)),
                    De === !0 && R.cameras.push(nt)
                }
                const Ve = s.enabledFeatures;
                if (Ve && Ve.includes("depth-sensing") && s.depthUsage == "gpu-optimized" && g) {
                    const He = g.getDepthInformation(Se[0]);
                    He && He.isValid && He.texture && M.init(e, He, s.renderState)
                }
            }
            for (let Se = 0; Se < D.length; Se++) {
                const De = C[Se]
                  , Ve = D[Se];
                De !== null && Ve !== void 0 && Ve.update(De, we, h || u)
            }
            ee && ee(te, we),
            we.detectedPlanes && r.dispatchEvent({
                type: "planesdetected",
                data: we
            }),
            E = null
        }
        const pe = new cw;
        pe.setAnimationLoop(ge),
        this.setAnimationLoop = function(te) {
            ee = te
        }
        ,
        this.dispose = function() {}
    }
}
const Gs = new Aa
  , pI = new Ln;
function mI(n, e) {
    function t(b, y) {
        b.matrixAutoUpdate === !0 && b.updateMatrix(),
        y.value.copy(b.matrix)
    }
    function r(b, y) {
        y.color.getRGB(b.fogColor.value, rw(n)),
        y.isFog ? (b.fogNear.value = y.near,
        b.fogFar.value = y.far) : y.isFogExp2 && (b.fogDensity.value = y.density)
    }
    function s(b, y, T, D, C) {
        y.isMeshBasicMaterial || y.isMeshLambertMaterial ? o(b, y) : y.isMeshToonMaterial ? (o(b, y),
        g(b, y)) : y.isMeshPhongMaterial ? (o(b, y),
        m(b, y)) : y.isMeshStandardMaterial ? (o(b, y),
        _(b, y),
        y.isMeshPhysicalMaterial && x(b, y, C)) : y.isMeshMatcapMaterial ? (o(b, y),
        E(b, y)) : y.isMeshDepthMaterial ? o(b, y) : y.isMeshDistanceMaterial ? (o(b, y),
        M(b, y)) : y.isMeshNormalMaterial ? o(b, y) : y.isLineBasicMaterial ? (u(b, y),
        y.isLineDashedMaterial && d(b, y)) : y.isPointsMaterial ? f(b, y, T, D) : y.isSpriteMaterial ? h(b, y) : y.isShadowMaterial ? (b.color.value.copy(y.color),
        b.opacity.value = y.opacity) : y.isShaderMaterial && (y.uniformsNeedUpdate = !1)
    }
    function o(b, y) {
        b.opacity.value = y.opacity,
        y.color && b.diffuse.value.copy(y.color),
        y.emissive && b.emissive.value.copy(y.emissive).multiplyScalar(y.emissiveIntensity),
        y.map && (b.map.value = y.map,
        t(y.map, b.mapTransform)),
        y.alphaMap && (b.alphaMap.value = y.alphaMap,
        t(y.alphaMap, b.alphaMapTransform)),
        y.bumpMap && (b.bumpMap.value = y.bumpMap,
        t(y.bumpMap, b.bumpMapTransform),
        b.bumpScale.value = y.bumpScale,
        y.side === Ni && (b.bumpScale.value *= -1)),
        y.normalMap && (b.normalMap.value = y.normalMap,
        t(y.normalMap, b.normalMapTransform),
        b.normalScale.value.copy(y.normalScale),
        y.side === Ni && b.normalScale.value.negate()),
        y.displacementMap && (b.displacementMap.value = y.displacementMap,
        t(y.displacementMap, b.displacementMapTransform),
        b.displacementScale.value = y.displacementScale,
        b.displacementBias.value = y.displacementBias),
        y.emissiveMap && (b.emissiveMap.value = y.emissiveMap,
        t(y.emissiveMap, b.emissiveMapTransform)),
        y.specularMap && (b.specularMap.value = y.specularMap,
        t(y.specularMap, b.specularMapTransform)),
        y.alphaTest > 0 && (b.alphaTest.value = y.alphaTest);
        const T = e.get(y)
          , D = T.envMap
          , C = T.envMapRotation;
        D && (b.envMap.value = D,
        Gs.copy(C),
        Gs.x *= -1,
        Gs.y *= -1,
        Gs.z *= -1,
        D.isCubeTexture && D.isRenderTargetTexture === !1 && (Gs.y *= -1,
        Gs.z *= -1),
        b.envMapRotation.value.setFromMatrix4(pI.makeRotationFromEuler(Gs)),
        b.flipEnvMap.value = D.isCubeTexture && D.isRenderTargetTexture === !1 ? -1 : 1,
        b.reflectivity.value = y.reflectivity,
        b.ior.value = y.ior,
        b.refractionRatio.value = y.refractionRatio),
        y.lightMap && (b.lightMap.value = y.lightMap,
        b.lightMapIntensity.value = y.lightMapIntensity,
        t(y.lightMap, b.lightMapTransform)),
        y.aoMap && (b.aoMap.value = y.aoMap,
        b.aoMapIntensity.value = y.aoMapIntensity,
        t(y.aoMap, b.aoMapTransform))
    }
    function u(b, y) {
        b.diffuse.value.copy(y.color),
        b.opacity.value = y.opacity,
        y.map && (b.map.value = y.map,
        t(y.map, b.mapTransform))
    }
    function d(b, y) {
        b.dashSize.value = y.dashSize,
        b.totalSize.value = y.dashSize + y.gapSize,
        b.scale.value = y.scale
    }
    function f(b, y, T, D) {
        b.diffuse.value.copy(y.color),
        b.opacity.value = y.opacity,
        b.size.value = y.size * T,
        b.scale.value = D * .5,
        y.map && (b.map.value = y.map,
        t(y.map, b.uvTransform)),
        y.alphaMap && (b.alphaMap.value = y.alphaMap,
        t(y.alphaMap, b.alphaMapTransform)),
        y.alphaTest > 0 && (b.alphaTest.value = y.alphaTest)
    }
    function h(b, y) {
        b.diffuse.value.copy(y.color),
        b.opacity.value = y.opacity,
        b.rotation.value = y.rotation,
        y.map && (b.map.value = y.map,
        t(y.map, b.mapTransform)),
        y.alphaMap && (b.alphaMap.value = y.alphaMap,
        t(y.alphaMap, b.alphaMapTransform)),
        y.alphaTest > 0 && (b.alphaTest.value = y.alphaTest)
    }
    function m(b, y) {
        b.specular.value.copy(y.specular),
        b.shininess.value = Math.max(y.shininess, 1e-4)
    }
    function g(b, y) {
        y.gradientMap && (b.gradientMap.value = y.gradientMap)
    }
    function _(b, y) {
        b.metalness.value = y.metalness,
        y.metalnessMap && (b.metalnessMap.value = y.metalnessMap,
        t(y.metalnessMap, b.metalnessMapTransform)),
        b.roughness.value = y.roughness,
        y.roughnessMap && (b.roughnessMap.value = y.roughnessMap,
        t(y.roughnessMap, b.roughnessMapTransform)),
        y.envMap && (b.envMapIntensity.value = y.envMapIntensity)
    }
    function x(b, y, T) {
        b.ior.value = y.ior,
        y.sheen > 0 && (b.sheenColor.value.copy(y.sheenColor).multiplyScalar(y.sheen),
        b.sheenRoughness.value = y.sheenRoughness,
        y.sheenColorMap && (b.sheenColorMap.value = y.sheenColorMap,
        t(y.sheenColorMap, b.sheenColorMapTransform)),
        y.sheenRoughnessMap && (b.sheenRoughnessMap.value = y.sheenRoughnessMap,
        t(y.sheenRoughnessMap, b.sheenRoughnessMapTransform))),
        y.clearcoat > 0 && (b.clearcoat.value = y.clearcoat,
        b.clearcoatRoughness.value = y.clearcoatRoughness,
        y.clearcoatMap && (b.clearcoatMap.value = y.clearcoatMap,
        t(y.clearcoatMap, b.clearcoatMapTransform)),
        y.clearcoatRoughnessMap && (b.clearcoatRoughnessMap.value = y.clearcoatRoughnessMap,
        t(y.clearcoatRoughnessMap, b.clearcoatRoughnessMapTransform)),
        y.clearcoatNormalMap && (b.clearcoatNormalMap.value = y.clearcoatNormalMap,
        t(y.clearcoatNormalMap, b.clearcoatNormalMapTransform),
        b.clearcoatNormalScale.value.copy(y.clearcoatNormalScale),
        y.side === Ni && b.clearcoatNormalScale.value.negate())),
        y.dispersion > 0 && (b.dispersion.value = y.dispersion),
        y.iridescence > 0 && (b.iridescence.value = y.iridescence,
        b.iridescenceIOR.value = y.iridescenceIOR,
        b.iridescenceThicknessMinimum.value = y.iridescenceThicknessRange[0],
        b.iridescenceThicknessMaximum.value = y.iridescenceThicknessRange[1],
        y.iridescenceMap && (b.iridescenceMap.value = y.iridescenceMap,
        t(y.iridescenceMap, b.iridescenceMapTransform)),
        y.iridescenceThicknessMap && (b.iridescenceThicknessMap.value = y.iridescenceThicknessMap,
        t(y.iridescenceThicknessMap, b.iridescenceThicknessMapTransform))),
        y.transmission > 0 && (b.transmission.value = y.transmission,
        b.transmissionSamplerMap.value = T.texture,
        b.transmissionSamplerSize.value.set(T.width, T.height),
        y.transmissionMap && (b.transmissionMap.value = y.transmissionMap,
        t(y.transmissionMap, b.transmissionMapTransform)),
        b.thickness.value = y.thickness,
        y.thicknessMap && (b.thicknessMap.value = y.thicknessMap,
        t(y.thicknessMap, b.thicknessMapTransform)),
        b.attenuationDistance.value = y.attenuationDistance,
        b.attenuationColor.value.copy(y.attenuationColor)),
        y.anisotropy > 0 && (b.anisotropyVector.value.set(y.anisotropy * Math.cos(y.anisotropyRotation), y.anisotropy * Math.sin(y.anisotropyRotation)),
        y.anisotropyMap && (b.anisotropyMap.value = y.anisotropyMap,
        t(y.anisotropyMap, b.anisotropyMapTransform))),
        b.specularIntensity.value = y.specularIntensity,
        b.specularColor.value.copy(y.specularColor),
        y.specularColorMap && (b.specularColorMap.value = y.specularColorMap,
        t(y.specularColorMap, b.specularColorMapTransform)),
        y.specularIntensityMap && (b.specularIntensityMap.value = y.specularIntensityMap,
        t(y.specularIntensityMap, b.specularIntensityMapTransform))
    }
    function E(b, y) {
        y.matcap && (b.matcap.value = y.matcap)
    }
    function M(b, y) {
        const T = e.get(y).light;
        b.referencePosition.value.setFromMatrixPosition(T.matrixWorld),
        b.nearDistance.value = T.shadow.camera.near,
        b.farDistance.value = T.shadow.camera.far
    }
    return {
        refreshFogUniforms: r,
        refreshMaterialUniforms: s
    }
}
function gI(n, e, t, r) {
    let s = {}
      , o = {}
      , u = [];
    const d = n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS);
    function f(T, D) {
        const C = D.program;
        r.uniformBlockBinding(T, C)
    }
    function h(T, D) {
        let C = s[T.id];
        C === void 0 && (E(T),
        C = m(T),
        s[T.id] = C,
        T.addEventListener("dispose", b));
        const P = D.program;
        r.updateUBOMapping(T, P);
        const A = e.render.frame;
        o[T.id] !== A && (_(T),
        o[T.id] = A)
    }
    function m(T) {
        const D = g();
        T.__bindingPointIndex = D;
        const C = n.createBuffer()
          , P = T.__size
          , A = T.usage;
        return n.bindBuffer(n.UNIFORM_BUFFER, C),
        n.bufferData(n.UNIFORM_BUFFER, P, A),
        n.bindBuffer(n.UNIFORM_BUFFER, null),
        n.bindBufferBase(n.UNIFORM_BUFFER, D, C),
        C
    }
    function g() {
        for (let T = 0; T < d; T++)
            if (u.indexOf(T) === -1)
                return u.push(T),
                T;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
        0
    }
    function _(T) {
        const D = s[T.id]
          , C = T.uniforms
          , P = T.__cache;
        n.bindBuffer(n.UNIFORM_BUFFER, D);
        for (let A = 0, F = C.length; A < F; A++) {
            const z = Array.isArray(C[A]) ? C[A] : [C[A]];
            for (let U = 0, R = z.length; U < R; U++) {
                const V = z[U];
                if (x(V, A, U, P) === !0) {
                    const Q = V.__offset
                      , X = Array.isArray(V.value) ? V.value : [V.value];
                    let oe = 0;
                    for (let le = 0; le < X.length; le++) {
                        const O = X[le]
                          , W = M(O);
                        typeof O == "number" || typeof O == "boolean" ? (V.__data[0] = O,
                        n.bufferSubData(n.UNIFORM_BUFFER, Q + oe, V.__data)) : O.isMatrix3 ? (V.__data[0] = O.elements[0],
                        V.__data[1] = O.elements[1],
                        V.__data[2] = O.elements[2],
                        V.__data[3] = 0,
                        V.__data[4] = O.elements[3],
                        V.__data[5] = O.elements[4],
                        V.__data[6] = O.elements[5],
                        V.__data[7] = 0,
                        V.__data[8] = O.elements[6],
                        V.__data[9] = O.elements[7],
                        V.__data[10] = O.elements[8],
                        V.__data[11] = 0) : (O.toArray(V.__data, oe),
                        oe += W.storage / Float32Array.BYTES_PER_ELEMENT)
                    }
                    n.bufferSubData(n.UNIFORM_BUFFER, Q, V.__data)
                }
            }
        }
        n.bindBuffer(n.UNIFORM_BUFFER, null)
    }
    function x(T, D, C, P) {
        const A = T.value
          , F = D + "_" + C;
        if (P[F] === void 0)
            return typeof A == "number" || typeof A == "boolean" ? P[F] = A : P[F] = A.clone(),
            !0;
        {
            const z = P[F];
            if (typeof A == "number" || typeof A == "boolean") {
                if (z !== A)
                    return P[F] = A,
                    !0
            } else if (z.equals(A) === !1)
                return z.copy(A),
                !0
        }
        return !1
    }
    function E(T) {
        const D = T.uniforms;
        let C = 0;
        const P = 16;
        for (let F = 0, z = D.length; F < z; F++) {
            const U = Array.isArray(D[F]) ? D[F] : [D[F]];
            for (let R = 0, V = U.length; R < V; R++) {
                const Q = U[R]
                  , X = Array.isArray(Q.value) ? Q.value : [Q.value];
                for (let oe = 0, le = X.length; oe < le; oe++) {
                    const O = X[oe]
                      , W = M(O)
                      , H = C % P
                      , Me = H % W.boundary
                      , k = H + Me;
                    C += Me,
                    k !== 0 && P - k < W.storage && (C += P - k),
                    Q.__data = new Float32Array(W.storage / Float32Array.BYTES_PER_ELEMENT),
                    Q.__offset = C,
                    C += W.storage
                }
            }
        }
        const A = C % P;
        return A > 0 && (C += P - A),
        T.__size = C,
        T.__cache = {},
        this
    }
    function M(T) {
        const D = {
            boundary: 0,
            storage: 0
        };
        return typeof T == "number" || typeof T == "boolean" ? (D.boundary = 4,
        D.storage = 4) : T.isVector2 ? (D.boundary = 8,
        D.storage = 8) : T.isVector3 || T.isColor ? (D.boundary = 16,
        D.storage = 12) : T.isVector4 ? (D.boundary = 16,
        D.storage = 16) : T.isMatrix3 ? (D.boundary = 48,
        D.storage = 48) : T.isMatrix4 ? (D.boundary = 64,
        D.storage = 64) : T.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", T),
        D
    }
    function b(T) {
        const D = T.target;
        D.removeEventListener("dispose", b);
        const C = u.indexOf(D.__bindingPointIndex);
        u.splice(C, 1),
        n.deleteBuffer(s[D.id]),
        delete s[D.id],
        delete o[D.id]
    }
    function y() {
        for (const T in s)
            n.deleteBuffer(s[T]);
        u = [],
        s = {},
        o = {}
    }
    return {
        bind: f,
        update: h,
        dispose: y
    }
}
class vI {
    constructor(e={}) {
        const {canvas: t=qU(), context: r=null, depth: s=!0, stencil: o=!1, alpha: u=!1, antialias: d=!1, premultipliedAlpha: f=!0, preserveDrawingBuffer: h=!1, powerPreference: m="default", failIfMajorPerformanceCaveat: g=!1, reverseDepthBuffer: _=!1} = e;
        this.isWebGLRenderer = !0;
        let x;
        if (r !== null) {
            if (typeof WebGLRenderingContext < "u" && r instanceof WebGLRenderingContext)
                throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
            x = r.getContextAttributes().alpha
        } else
            x = u;
        const E = new Uint32Array(4)
          , M = new Int32Array(4);
        let b = null
          , y = null;
        const T = []
          , D = [];
        this.domElement = t,
        this.debug = {
            checkShaderErrors: !0,
            onShaderError: null
        },
        this.autoClear = !0,
        this.autoClearColor = !0,
        this.autoClearDepth = !0,
        this.autoClearStencil = !0,
        this.sortObjects = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this.toneMapping = gs,
        this.toneMappingExposure = 1,
        this.transmissionResolutionScale = 1;
        const C = this;
        let P = !1;
        this._outputColorSpace = Xi;
        let A = 0
          , F = 0
          , z = null
          , U = -1
          , R = null;
        const V = new zn
          , Q = new zn;
        let X = null;
        const oe = new pn(0);
        let le = 0
          , O = t.width
          , W = t.height
          , H = 1
          , Me = null
          , k = null;
        const ee = new zn(0,0,O,W)
          , ge = new zn(0,0,O,W);
        let pe = !1;
        const te = new d_;
        let we = !1
          , Se = !1;
        const De = new Ln
          , Ve = new Ln
          , _t = new Ee
          , He = new zn
          , Pt = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0
        };
        let kt = !1;
        function nt() {
            return z === null ? H : 1
        }
        let G = r;
        function Zt(N, ae) {
            return t.getContext(N, ae)
        }
        try {
            const N = {
                alpha: !0,
                depth: s,
                stencil: o,
                antialias: d,
                premultipliedAlpha: f,
                preserveDrawingBuffer: h,
                powerPreference: m,
                failIfMajorPerformanceCaveat: g
            };
            if ("setAttribute"in t && t.setAttribute("data-engine", `three.js r${i_}`),
            t.addEventListener("webglcontextlost", Ne, !1),
            t.addEventListener("webglcontextrestored", Ke, !1),
            t.addEventListener("webglcontextcreationerror", Ce, !1),
            G === null) {
                const ae = "webgl2";
                if (G = Zt(ae, N),
                G === null)
                    throw Zt(ae) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
        } catch (N) {
            throw console.error("THREE.WebGLRenderer: " + N.message),
            N
        }
        let ot, it, rt, pt, Xe, B, S, I, q, se, J, de, _e, Ae, lt, Le, $e, ht, yt, qe, Lt, Tt, qt, re;
        function Ye() {
            ot = new A3(G),
            ot.init(),
            Tt = new cI(G,ot),
            it = new x3(G,ot,e,Tt),
            rt = new oI(G,ot),
            it.reverseDepthBuffer && _ && rt.buffers.depth.setReversed(!0),
            pt = new D3(G),
            Xe = new YP,
            B = new lI(G,ot,rt,Xe,it,Tt,pt),
            S = new S3(C),
            I = new T3(C),
            q = new IL(G),
            qt = new _3(G,q),
            se = new R3(G,q,pt,qt),
            J = new L3(G,se,q,pt),
            yt = new U3(G,it,B),
            Le = new b3(Xe),
            de = new qP(C,S,I,ot,it,qt,Le),
            _e = new mI(C,Xe),
            Ae = new $P,
            lt = new nI(ot),
            ht = new v3(C,S,I,rt,J,x,f),
            $e = new aI(C,J,it),
            re = new gI(G,pt,it,rt),
            qe = new y3(G,ot,pt),
            Lt = new C3(G,ot,pt),
            pt.programs = de.programs,
            C.capabilities = it,
            C.extensions = ot,
            C.properties = Xe,
            C.renderLists = Ae,
            C.shadowMap = $e,
            C.state = rt,
            C.info = pt
        }
        Ye();
        const Te = new hI(C,G);
        this.xr = Te,
        this.getContext = function() {
            return G
        }
        ,
        this.getContextAttributes = function() {
            return G.getContextAttributes()
        }
        ,
        this.forceContextLoss = function() {
            const N = ot.get("WEBGL_lose_context");
            N && N.loseContext()
        }
        ,
        this.forceContextRestore = function() {
            const N = ot.get("WEBGL_lose_context");
            N && N.restoreContext()
        }
        ,
        this.getPixelRatio = function() {
            return H
        }
        ,
        this.setPixelRatio = function(N) {
            N !== void 0 && (H = N,
            this.setSize(O, W, !1))
        }
        ,
        this.getSize = function(N) {
            return N.set(O, W)
        }
        ,
        this.setSize = function(N, ae, ye=!0) {
            if (Te.isPresenting) {
                console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                return
            }
            O = N,
            W = ae,
            t.width = Math.floor(N * H),
            t.height = Math.floor(ae * H),
            ye === !0 && (t.style.width = N + "px",
            t.style.height = ae + "px"),
            this.setViewport(0, 0, N, ae)
        }
        ,
        this.getDrawingBufferSize = function(N) {
            return N.set(O * H, W * H).floor()
        }
        ,
        this.setDrawingBufferSize = function(N, ae, ye) {
            O = N,
            W = ae,
            H = ye,
            t.width = Math.floor(N * ye),
            t.height = Math.floor(ae * ye),
            this.setViewport(0, 0, N, ae)
        }
        ,
        this.getCurrentViewport = function(N) {
            return N.copy(V)
        }
        ,
        this.getViewport = function(N) {
            return N.copy(ee)
        }
        ,
        this.setViewport = function(N, ae, ye, xe) {
            N.isVector4 ? ee.set(N.x, N.y, N.z, N.w) : ee.set(N, ae, ye, xe),
            rt.viewport(V.copy(ee).multiplyScalar(H).round())
        }
        ,
        this.getScissor = function(N) {
            return N.copy(ge)
        }
        ,
        this.setScissor = function(N, ae, ye, xe) {
            N.isVector4 ? ge.set(N.x, N.y, N.z, N.w) : ge.set(N, ae, ye, xe),
            rt.scissor(Q.copy(ge).multiplyScalar(H).round())
        }
        ,
        this.getScissorTest = function() {
            return pe
        }
        ,
        this.setScissorTest = function(N) {
            rt.setScissorTest(pe = N)
        }
        ,
        this.setOpaqueSort = function(N) {
            Me = N
        }
        ,
        this.setTransparentSort = function(N) {
            k = N
        }
        ,
        this.getClearColor = function(N) {
            return N.copy(ht.getClearColor())
        }
        ,
        this.setClearColor = function() {
            ht.setClearColor(...arguments)
        }
        ,
        this.getClearAlpha = function() {
            return ht.getClearAlpha()
        }
        ,
        this.setClearAlpha = function() {
            ht.setClearAlpha(...arguments)
        }
        ,
        this.clear = function(N=!0, ae=!0, ye=!0) {
            let xe = 0;
            if (N) {
                let ue = !1;
                if (z !== null) {
                    const ke = z.texture.format;
                    ue = ke === c_ || ke === l_ || ke === o_
                }
                if (ue) {
                    const ke = z.texture.type
                      , Ge = ke === Ta || ke === no || ke === Qc || ke === Jc || ke === a_ || ke === s_
                      , Ie = ht.getClearColor()
                      , We = ht.getClearAlpha()
                      , Mt = Ie.r
                      , St = Ie.g
                      , gt = Ie.b;
                    Ge ? (E[0] = Mt,
                    E[1] = St,
                    E[2] = gt,
                    E[3] = We,
                    G.clearBufferuiv(G.COLOR, 0, E)) : (M[0] = Mt,
                    M[1] = St,
                    M[2] = gt,
                    M[3] = We,
                    G.clearBufferiv(G.COLOR, 0, M))
                } else
                    xe |= G.COLOR_BUFFER_BIT
            }
            ae && (xe |= G.DEPTH_BUFFER_BIT),
            ye && (xe |= G.STENCIL_BUFFER_BIT,
            this.state.buffers.stencil.setMask(4294967295)),
            G.clear(xe)
        }
        ,
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        }
        ,
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }
        ,
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }
        ,
        this.dispose = function() {
            t.removeEventListener("webglcontextlost", Ne, !1),
            t.removeEventListener("webglcontextrestored", Ke, !1),
            t.removeEventListener("webglcontextcreationerror", Ce, !1),
            ht.dispose(),
            Ae.dispose(),
            lt.dispose(),
            Xe.dispose(),
            S.dispose(),
            I.dispose(),
            J.dispose(),
            qt.dispose(),
            re.dispose(),
            de.dispose(),
            Te.dispose(),
            Te.removeEventListener("sessionstart", Ue),
            Te.removeEventListener("sessionend", ze),
            je.stop()
        }
        ;
        function Ne(N) {
            N.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            P = !0
        }
        function Ke() {
            console.log("THREE.WebGLRenderer: Context Restored."),
            P = !1;
            const N = pt.autoReset
              , ae = $e.enabled
              , ye = $e.autoUpdate
              , xe = $e.needsUpdate
              , ue = $e.type;
            Ye(),
            pt.autoReset = N,
            $e.enabled = ae,
            $e.autoUpdate = ye,
            $e.needsUpdate = xe,
            $e.type = ue
        }
        function Ce(N) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", N.statusMessage)
        }
        function at(N) {
            const ae = N.target;
            ae.removeEventListener("dispose", at),
            zt(ae)
        }
        function zt(N) {
            nn(N),
            Xe.remove(N)
        }
        function nn(N) {
            const ae = Xe.get(N).programs;
            ae !== void 0 && (ae.forEach(function(ye) {
                de.releaseProgram(ye)
            }),
            N.isShaderMaterial && de.releaseShaderCache(N))
        }
        this.renderBufferDirect = function(N, ae, ye, xe, ue, ke) {
            ae === null && (ae = Pt);
            const Ge = ue.isMesh && ue.matrixWorld.determinant() < 0
              , Ie = En(N, ae, ye, xe, ue);
            rt.setMaterial(xe, Ge);
            let We = ye.index
              , Mt = 1;
            if (xe.wireframe === !0) {
                if (We = se.getWireframeAttribute(ye),
                We === void 0)
                    return;
                Mt = 2
            }
            const St = ye.drawRange
              , gt = ye.attributes.position;
            let Et = St.start * Mt
              , jt = (St.start + St.count) * Mt;
            ke !== null && (Et = Math.max(Et, ke.start * Mt),
            jt = Math.min(jt, (ke.start + ke.count) * Mt)),
            We !== null ? (Et = Math.max(Et, 0),
            jt = Math.min(jt, We.count)) : gt != null && (Et = Math.max(Et, 0),
            jt = Math.min(jt, gt.count));
            const Tn = jt - Et;
            if (Tn < 0 || Tn === 1 / 0)
                return;
            qt.setup(ue, xe, Ie, ye, We);
            let Kt, an = qe;
            if (We !== null && (Kt = q.get(We),
            an = Lt,
            an.setIndex(Kt)),
            ue.isMesh)
                xe.wireframe === !0 ? (rt.setLineWidth(xe.wireframeLinewidth * nt()),
                an.setMode(G.LINES)) : an.setMode(G.TRIANGLES);
            else if (ue.isLine) {
                let At = xe.linewidth;
                At === void 0 && (At = 1),
                rt.setLineWidth(At * nt()),
                ue.isLineSegments ? an.setMode(G.LINES) : ue.isLineLoop ? an.setMode(G.LINE_LOOP) : an.setMode(G.LINE_STRIP)
            } else
                ue.isPoints ? an.setMode(G.POINTS) : ue.isSprite && an.setMode(G.TRIANGLES);
            if (ue.isBatchedMesh)
                if (ue._multiDrawInstances !== null)
                    vf("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."),
                    an.renderMultiDrawInstances(ue._multiDrawStarts, ue._multiDrawCounts, ue._multiDrawCount, ue._multiDrawInstances);
                else if (ot.get("WEBGL_multi_draw"))
                    an.renderMultiDraw(ue._multiDrawStarts, ue._multiDrawCounts, ue._multiDrawCount);
                else {
                    const At = ue._multiDrawStarts
                      , Nn = ue._multiDrawCounts
                      , cn = ue._multiDrawCount
                      , hi = We ? q.get(We).bytesPerElement : 1
                      , Da = Xe.get(xe).currentProgram.getUniforms();
                    for (let An = 0; An < cn; An++)
                        Da.setValue(G, "_gl_DrawID", An),
                        an.render(At[An] / hi, Nn[An])
                }
            else if (ue.isInstancedMesh)
                an.renderInstances(Et, Tn, ue.count);
            else if (ye.isInstancedBufferGeometry) {
                const At = ye._maxInstanceCount !== void 0 ? ye._maxInstanceCount : 1 / 0
                  , Nn = Math.min(ye.instanceCount, At);
                an.renderInstances(Et, Tn, Nn)
            } else
                an.render(Et, Tn)
        }
        ;
        function j(N, ae, ye) {
            N.transparent === !0 && N.side === _a && N.forceSinglePass === !1 ? (N.side = Ni,
            N.needsUpdate = !0,
            ft(N, ae, ye),
            N.side = _s,
            N.needsUpdate = !0,
            ft(N, ae, ye),
            N.side = _a) : ft(N, ae, ye)
        }
        this.compile = function(N, ae, ye=null) {
            ye === null && (ye = N),
            y = lt.get(ye),
            y.init(ae),
            D.push(y),
            ye.traverseVisible(function(ue) {
                ue.isLight && ue.layers.test(ae.layers) && (y.pushLight(ue),
                ue.castShadow && y.pushShadow(ue))
            }),
            N !== ye && N.traverseVisible(function(ue) {
                ue.isLight && ue.layers.test(ae.layers) && (y.pushLight(ue),
                ue.castShadow && y.pushShadow(ue))
            }),
            y.setupLights();
            const xe = new Set;
            return N.traverse(function(ue) {
                if (!(ue.isMesh || ue.isPoints || ue.isLine || ue.isSprite))
                    return;
                const ke = ue.material;
                if (ke)
                    if (Array.isArray(ke))
                        for (let Ge = 0; Ge < ke.length; Ge++) {
                            const Ie = ke[Ge];
                            j(Ie, ye, ue),
                            xe.add(Ie)
                        }
                    else
                        j(ke, ye, ue),
                        xe.add(ke)
            }),
            y = D.pop(),
            xe
        }
        ,
        this.compileAsync = function(N, ae, ye=null) {
            const xe = this.compile(N, ae, ye);
            return new Promise(ue => {
                function ke() {
                    if (xe.forEach(function(Ge) {
                        Xe.get(Ge).currentProgram.isReady() && xe.delete(Ge)
                    }),
                    xe.size === 0) {
                        ue(N);
                        return
                    }
                    setTimeout(ke, 10)
                }
                ot.get("KHR_parallel_shader_compile") !== null ? ke() : setTimeout(ke, 10)
            }
            )
        }
        ;
        let ie = null;
        function fe(N) {
            ie && ie(N)
        }
        function Ue() {
            je.stop()
        }
        function ze() {
            je.start()
        }
        const je = new cw;
        je.setAnimationLoop(fe),
        typeof self < "u" && je.setContext(self),
        this.setAnimationLoop = function(N) {
            ie = N,
            Te.setAnimationLoop(N),
            N === null ? je.stop() : je.start()
        }
        ,
        Te.addEventListener("sessionstart", Ue),
        Te.addEventListener("sessionend", ze),
        this.render = function(N, ae) {
            if (ae !== void 0 && ae.isCamera !== !0) {
                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                return
            }
            if (P === !0)
                return;
            if (N.matrixWorldAutoUpdate === !0 && N.updateMatrixWorld(),
            ae.parent === null && ae.matrixWorldAutoUpdate === !0 && ae.updateMatrixWorld(),
            Te.enabled === !0 && Te.isPresenting === !0 && (Te.cameraAutoUpdate === !0 && Te.updateCamera(ae),
            ae = Te.getCamera()),
            N.isScene === !0 && N.onBeforeRender(C, N, ae, z),
            y = lt.get(N, D.length),
            y.init(ae),
            D.push(y),
            Ve.multiplyMatrices(ae.projectionMatrix, ae.matrixWorldInverse),
            te.setFromProjectionMatrix(Ve),
            Se = this.localClippingEnabled,
            we = Le.init(this.clippingPlanes, Se),
            b = Ae.get(N, T.length),
            b.init(),
            T.push(b),
            Te.enabled === !0 && Te.isPresenting === !0) {
                const ke = C.xr.getDepthSensingMesh();
                ke !== null && bt(ke, ae, -1 / 0, C.sortObjects)
            }
            bt(N, ae, 0, C.sortObjects),
            b.finish(),
            C.sortObjects === !0 && b.sort(Me, k),
            kt = Te.enabled === !1 || Te.isPresenting === !1 || Te.hasDepthSensing() === !1,
            kt && ht.addToRenderList(b, N),
            this.info.render.frame++,
            we === !0 && Le.beginShadows();
            const ye = y.state.shadowsArray;
            $e.render(ye, N, ae),
            we === !0 && Le.endShadows(),
            this.info.autoReset === !0 && this.info.reset();
            const xe = b.opaque
              , ue = b.transmissive;
            if (y.setupLights(),
            ae.isArrayCamera) {
                const ke = ae.cameras;
                if (ue.length > 0)
                    for (let Ge = 0, Ie = ke.length; Ge < Ie; Ge++) {
                        const We = ke[Ge];
                        xt(xe, ue, N, We)
                    }
                kt && ht.render(N);
                for (let Ge = 0, Ie = ke.length; Ge < Ie; Ge++) {
                    const We = ke[Ge];
                    Qe(b, N, We, We.viewport)
                }
            } else
                ue.length > 0 && xt(xe, ue, N, ae),
                kt && ht.render(N),
                Qe(b, N, ae);
            z !== null && F === 0 && (B.updateMultisampleRenderTarget(z),
            B.updateRenderTargetMipmap(z)),
            N.isScene === !0 && N.onAfterRender(C, N, ae),
            qt.resetDefaultState(),
            U = -1,
            R = null,
            D.pop(),
            D.length > 0 ? (y = D[D.length - 1],
            we === !0 && Le.setGlobalState(C.clippingPlanes, y.state.camera)) : y = null,
            T.pop(),
            T.length > 0 ? b = T[T.length - 1] : b = null
        }
        ;
        function bt(N, ae, ye, xe) {
            if (N.visible === !1)
                return;
            if (N.layers.test(ae.layers)) {
                if (N.isGroup)
                    ye = N.renderOrder;
                else if (N.isLOD)
                    N.autoUpdate === !0 && N.update(ae);
                else if (N.isLight)
                    y.pushLight(N),
                    N.castShadow && y.pushShadow(N);
                else if (N.isSprite) {
                    if (!N.frustumCulled || te.intersectsSprite(N)) {
                        xe && He.setFromMatrixPosition(N.matrixWorld).applyMatrix4(Ve);
                        const Ge = J.update(N)
                          , Ie = N.material;
                        Ie.visible && b.push(N, Ge, Ie, ye, He.z, null)
                    }
                } else if ((N.isMesh || N.isLine || N.isPoints) && (!N.frustumCulled || te.intersectsObject(N))) {
                    const Ge = J.update(N)
                      , Ie = N.material;
                    if (xe && (N.boundingSphere !== void 0 ? (N.boundingSphere === null && N.computeBoundingSphere(),
                    He.copy(N.boundingSphere.center)) : (Ge.boundingSphere === null && Ge.computeBoundingSphere(),
                    He.copy(Ge.boundingSphere.center)),
                    He.applyMatrix4(N.matrixWorld).applyMatrix4(Ve)),
                    Array.isArray(Ie)) {
                        const We = Ge.groups;
                        for (let Mt = 0, St = We.length; Mt < St; Mt++) {
                            const gt = We[Mt]
                              , Et = Ie[gt.materialIndex];
                            Et && Et.visible && b.push(N, Ge, Et, ye, He.z, gt)
                        }
                    } else
                        Ie.visible && b.push(N, Ge, Ie, ye, He.z, null)
                }
            }
            const ke = N.children;
            for (let Ge = 0, Ie = ke.length; Ge < Ie; Ge++)
                bt(ke[Ge], ae, ye, xe)
        }
        function Qe(N, ae, ye, xe) {
            const ue = N.opaque
              , ke = N.transmissive
              , Ge = N.transparent;
            y.setupLightsView(ye),
            we === !0 && Le.setGlobalState(C.clippingPlanes, ye),
            xe && rt.viewport(V.copy(xe)),
            ue.length > 0 && mt(ue, ae, ye),
            ke.length > 0 && mt(ke, ae, ye),
            Ge.length > 0 && mt(Ge, ae, ye),
            rt.buffers.depth.setTest(!0),
            rt.buffers.depth.setMask(!0),
            rt.buffers.color.setMask(!0),
            rt.setPolygonOffset(!1)
        }
        function xt(N, ae, ye, xe) {
            if ((ye.isScene === !0 ? ye.overrideMaterial : null) !== null)
                return;
            y.state.transmissionRenderTarget[xe.id] === void 0 && (y.state.transmissionRenderTarget[xe.id] = new io(1,1,{
                generateMipmaps: !0,
                type: ot.has("EXT_color_buffer_half_float") || ot.has("EXT_color_buffer_float") ? hu : Ta,
                minFilter: Qs,
                samples: 4,
                stencilBuffer: o,
                resolveDepthBuffer: !1,
                resolveStencilBuffer: !1,
                colorSpace: fn.workingColorSpace
            }));
            const ke = y.state.transmissionRenderTarget[xe.id]
              , Ge = xe.viewport || V;
            ke.setSize(Ge.z * C.transmissionResolutionScale, Ge.w * C.transmissionResolutionScale);
            const Ie = C.getRenderTarget();
            C.setRenderTarget(ke),
            C.getClearColor(oe),
            le = C.getClearAlpha(),
            le < 1 && C.setClearColor(16777215, .5),
            C.clear(),
            kt && ht.render(ye);
            const We = C.toneMapping;
            C.toneMapping = gs;
            const Mt = xe.viewport;
            if (xe.viewport !== void 0 && (xe.viewport = void 0),
            y.setupLightsView(xe),
            we === !0 && Le.setGlobalState(C.clippingPlanes, xe),
            mt(N, ye, xe),
            B.updateMultisampleRenderTarget(ke),
            B.updateRenderTargetMipmap(ke),
            ot.has("WEBGL_multisampled_render_to_texture") === !1) {
                let St = !1;
                for (let gt = 0, Et = ae.length; gt < Et; gt++) {
                    const jt = ae[gt]
                      , Tn = jt.object
                      , Kt = jt.geometry
                      , an = jt.material
                      , At = jt.group;
                    if (an.side === _a && Tn.layers.test(xe.layers)) {
                        const Nn = an.side;
                        an.side = Ni,
                        an.needsUpdate = !0,
                        Rt(Tn, ye, xe, Kt, an, At),
                        an.side = Nn,
                        an.needsUpdate = !0,
                        St = !0
                    }
                }
                St === !0 && (B.updateMultisampleRenderTarget(ke),
                B.updateRenderTargetMipmap(ke))
            }
            C.setRenderTarget(Ie),
            C.setClearColor(oe, le),
            Mt !== void 0 && (xe.viewport = Mt),
            C.toneMapping = We
        }
        function mt(N, ae, ye) {
            const xe = ae.isScene === !0 ? ae.overrideMaterial : null;
            for (let ue = 0, ke = N.length; ue < ke; ue++) {
                const Ge = N[ue]
                  , Ie = Ge.object
                  , We = Ge.geometry
                  , Mt = Ge.group;
                let St = Ge.material;
                St.allowOverride === !0 && xe !== null && (St = xe),
                Ie.layers.test(ye.layers) && Rt(Ie, ae, ye, We, St, Mt)
            }
        }
        function Rt(N, ae, ye, xe, ue, ke) {
            N.onBeforeRender(C, ae, ye, xe, ue, ke),
            N.modelViewMatrix.multiplyMatrices(ye.matrixWorldInverse, N.matrixWorld),
            N.normalMatrix.getNormalMatrix(N.modelViewMatrix),
            ue.onBeforeRender(C, ae, ye, xe, N, ke),
            ue.transparent === !0 && ue.side === _a && ue.forceSinglePass === !1 ? (ue.side = Ni,
            ue.needsUpdate = !0,
            C.renderBufferDirect(ye, ae, xe, ue, N, ke),
            ue.side = _s,
            ue.needsUpdate = !0,
            C.renderBufferDirect(ye, ae, xe, ue, N, ke),
            ue.side = _a) : C.renderBufferDirect(ye, ae, xe, ue, N, ke),
            N.onAfterRender(C, ae, ye, xe, ue, ke)
        }
        function ft(N, ae, ye) {
            ae.isScene !== !0 && (ae = Pt);
            const xe = Xe.get(N)
              , ue = y.state.lights
              , ke = y.state.shadowsArray
              , Ge = ue.state.version
              , Ie = de.getParameters(N, ue.state, ke, ae, ye)
              , We = de.getProgramCacheKey(Ie);
            let Mt = xe.programs;
            xe.environment = N.isMeshStandardMaterial ? ae.environment : null,
            xe.fog = ae.fog,
            xe.envMap = (N.isMeshStandardMaterial ? I : S).get(N.envMap || xe.environment),
            xe.envMapRotation = xe.environment !== null && N.envMap === null ? ae.environmentRotation : N.envMapRotation,
            Mt === void 0 && (N.addEventListener("dispose", at),
            Mt = new Map,
            xe.programs = Mt);
            let St = Mt.get(We);
            if (St !== void 0) {
                if (xe.currentProgram === St && xe.lightsStateVersion === Ge)
                    return rn(N, Ie),
                    St
            } else
                Ie.uniforms = de.getUniforms(N),
                N.onBeforeCompile(Ie, C),
                St = de.acquireProgram(Ie, We),
                Mt.set(We, St),
                xe.uniforms = Ie.uniforms;
            const gt = xe.uniforms;
            return (!N.isShaderMaterial && !N.isRawShaderMaterial || N.clipping === !0) && (gt.clippingPlanes = Le.uniform),
            rn(N, Ie),
            xe.needsLights = on(N),
            xe.lightsStateVersion = Ge,
            xe.needsLights && (gt.ambientLightColor.value = ue.state.ambient,
            gt.lightProbe.value = ue.state.probe,
            gt.directionalLights.value = ue.state.directional,
            gt.directionalLightShadows.value = ue.state.directionalShadow,
            gt.spotLights.value = ue.state.spot,
            gt.spotLightShadows.value = ue.state.spotShadow,
            gt.rectAreaLights.value = ue.state.rectArea,
            gt.ltc_1.value = ue.state.rectAreaLTC1,
            gt.ltc_2.value = ue.state.rectAreaLTC2,
            gt.pointLights.value = ue.state.point,
            gt.pointLightShadows.value = ue.state.pointShadow,
            gt.hemisphereLights.value = ue.state.hemi,
            gt.directionalShadowMap.value = ue.state.directionalShadowMap,
            gt.directionalShadowMatrix.value = ue.state.directionalShadowMatrix,
            gt.spotShadowMap.value = ue.state.spotShadowMap,
            gt.spotLightMatrix.value = ue.state.spotLightMatrix,
            gt.spotLightMap.value = ue.state.spotLightMap,
            gt.pointShadowMap.value = ue.state.pointShadowMap,
            gt.pointShadowMatrix.value = ue.state.pointShadowMatrix),
            xe.currentProgram = St,
            xe.uniformsList = null,
            St
        }
        function Dt(N) {
            if (N.uniformsList === null) {
                const ae = N.currentProgram.getUniforms();
                N.uniformsList = _f.seqWithValue(ae.seq, N.uniforms)
            }
            return N.uniformsList
        }
        function rn(N, ae) {
            const ye = Xe.get(N);
            ye.outputColorSpace = ae.outputColorSpace,
            ye.batching = ae.batching,
            ye.batchingColor = ae.batchingColor,
            ye.instancing = ae.instancing,
            ye.instancingColor = ae.instancingColor,
            ye.instancingMorph = ae.instancingMorph,
            ye.skinning = ae.skinning,
            ye.morphTargets = ae.morphTargets,
            ye.morphNormals = ae.morphNormals,
            ye.morphColors = ae.morphColors,
            ye.morphTargetsCount = ae.morphTargetsCount,
            ye.numClippingPlanes = ae.numClippingPlanes,
            ye.numIntersection = ae.numClipIntersection,
            ye.vertexAlphas = ae.vertexAlphas,
            ye.vertexTangents = ae.vertexTangents,
            ye.toneMapping = ae.toneMapping
        }
        function En(N, ae, ye, xe, ue) {
            ae.isScene !== !0 && (ae = Pt),
            B.resetTextureUnits();
            const ke = ae.fog
              , Ge = xe.isMeshStandardMaterial ? ae.environment : null
              , Ie = z === null ? C.outputColorSpace : z.isXRRenderTarget === !0 ? z.texture.colorSpace : vl
              , We = (xe.isMeshStandardMaterial ? I : S).get(xe.envMap || Ge)
              , Mt = xe.vertexColors === !0 && !!ye.attributes.color && ye.attributes.color.itemSize === 4
              , St = !!ye.attributes.tangent && (!!xe.normalMap || xe.anisotropy > 0)
              , gt = !!ye.morphAttributes.position
              , Et = !!ye.morphAttributes.normal
              , jt = !!ye.morphAttributes.color;
            let Tn = gs;
            xe.toneMapped && (z === null || z.isXRRenderTarget === !0) && (Tn = C.toneMapping);
            const Kt = ye.morphAttributes.position || ye.morphAttributes.normal || ye.morphAttributes.color
              , an = Kt !== void 0 ? Kt.length : 0
              , At = Xe.get(xe)
              , Nn = y.state.lights;
            if (we === !0 && (Se === !0 || N !== R)) {
                const ti = N === R && xe.id === U;
                Le.setState(xe, N, ti)
            }
            let cn = !1;
            xe.version === At.__version ? (At.needsLights && At.lightsStateVersion !== Nn.state.version || At.outputColorSpace !== Ie || ue.isBatchedMesh && At.batching === !1 || !ue.isBatchedMesh && At.batching === !0 || ue.isBatchedMesh && At.batchingColor === !0 && ue.colorTexture === null || ue.isBatchedMesh && At.batchingColor === !1 && ue.colorTexture !== null || ue.isInstancedMesh && At.instancing === !1 || !ue.isInstancedMesh && At.instancing === !0 || ue.isSkinnedMesh && At.skinning === !1 || !ue.isSkinnedMesh && At.skinning === !0 || ue.isInstancedMesh && At.instancingColor === !0 && ue.instanceColor === null || ue.isInstancedMesh && At.instancingColor === !1 && ue.instanceColor !== null || ue.isInstancedMesh && At.instancingMorph === !0 && ue.morphTexture === null || ue.isInstancedMesh && At.instancingMorph === !1 && ue.morphTexture !== null || At.envMap !== We || xe.fog === !0 && At.fog !== ke || At.numClippingPlanes !== void 0 && (At.numClippingPlanes !== Le.numPlanes || At.numIntersection !== Le.numIntersection) || At.vertexAlphas !== Mt || At.vertexTangents !== St || At.morphTargets !== gt || At.morphNormals !== Et || At.morphColors !== jt || At.toneMapping !== Tn || At.morphTargetsCount !== an) && (cn = !0) : (cn = !0,
            At.__version = xe.version);
            let hi = At.currentProgram;
            cn === !0 && (hi = ft(xe, ae, ue));
            let Da = !1
              , An = !1
              , Vr = !1;
            const Mn = hi.getUniforms()
              , pi = At.uniforms;
            if (rt.useProgram(hi.program) && (Da = !0,
            An = !0,
            Vr = !0),
            xe.id !== U && (U = xe.id,
            An = !0),
            Da || R !== N) {
                rt.buffers.depth.getReversed() ? (De.copy(N.projectionMatrix),
                ZU(De),
                $U(De),
                Mn.setValue(G, "projectionMatrix", De)) : Mn.setValue(G, "projectionMatrix", N.projectionMatrix),
                Mn.setValue(G, "viewMatrix", N.matrixWorldInverse);
                const oi = Mn.map.cameraPosition;
                oi !== void 0 && oi.setValue(G, _t.setFromMatrixPosition(N.matrixWorld)),
                it.logarithmicDepthBuffer && Mn.setValue(G, "logDepthBufFC", 2 / (Math.log(N.far + 1) / Math.LN2)),
                (xe.isMeshPhongMaterial || xe.isMeshToonMaterial || xe.isMeshLambertMaterial || xe.isMeshBasicMaterial || xe.isMeshStandardMaterial || xe.isShaderMaterial) && Mn.setValue(G, "isOrthographic", N.isOrthographicCamera === !0),
                R !== N && (R = N,
                An = !0,
                Vr = !0)
            }
            if (ue.isSkinnedMesh) {
                Mn.setOptional(G, ue, "bindMatrix"),
                Mn.setOptional(G, ue, "bindMatrixInverse");
                const ti = ue.skeleton;
                ti && (ti.boneTexture === null && ti.computeBoneTexture(),
                Mn.setValue(G, "boneTexture", ti.boneTexture, B))
            }
            ue.isBatchedMesh && (Mn.setOptional(G, ue, "batchingTexture"),
            Mn.setValue(G, "batchingTexture", ue._matricesTexture, B),
            Mn.setOptional(G, ue, "batchingIdTexture"),
            Mn.setValue(G, "batchingIdTexture", ue._indirectTexture, B),
            Mn.setOptional(G, ue, "batchingColorTexture"),
            ue._colorsTexture !== null && Mn.setValue(G, "batchingColorTexture", ue._colorsTexture, B));
            const qn = ye.morphAttributes;
            if ((qn.position !== void 0 || qn.normal !== void 0 || qn.color !== void 0) && yt.update(ue, ye, hi),
            (An || At.receiveShadow !== ue.receiveShadow) && (At.receiveShadow = ue.receiveShadow,
            Mn.setValue(G, "receiveShadow", ue.receiveShadow)),
            xe.isMeshGouraudMaterial && xe.envMap !== null && (pi.envMap.value = We,
            pi.flipEnvMap.value = We.isCubeTexture && We.isRenderTargetTexture === !1 ? -1 : 1),
            xe.isMeshStandardMaterial && xe.envMap === null && ae.environment !== null && (pi.envMapIntensity.value = ae.environmentIntensity),
            An && (Mn.setValue(G, "toneMappingExposure", C.toneMappingExposure),
            At.needsLights && Cn(pi, Vr),
            ke && xe.fog === !0 && _e.refreshFogUniforms(pi, ke),
            _e.refreshMaterialUniforms(pi, xe, H, W, y.state.transmissionRenderTarget[N.id]),
            _f.upload(G, Dt(At), pi, B)),
            xe.isShaderMaterial && xe.uniformsNeedUpdate === !0 && (_f.upload(G, Dt(At), pi, B),
            xe.uniformsNeedUpdate = !1),
            xe.isSpriteMaterial && Mn.setValue(G, "center", ue.center),
            Mn.setValue(G, "modelViewMatrix", ue.modelViewMatrix),
            Mn.setValue(G, "normalMatrix", ue.normalMatrix),
            Mn.setValue(G, "modelMatrix", ue.matrixWorld),
            xe.isShaderMaterial || xe.isRawShaderMaterial) {
                const ti = xe.uniformsGroups;
                for (let oi = 0, Sr = ti.length; oi < Sr; oi++) {
                    const Hr = ti[oi];
                    re.update(Hr, hi),
                    re.bind(Hr, hi)
                }
            }
            return hi
        }
        function Cn(N, ae) {
            N.ambientLightColor.needsUpdate = ae,
            N.lightProbe.needsUpdate = ae,
            N.directionalLights.needsUpdate = ae,
            N.directionalLightShadows.needsUpdate = ae,
            N.pointLights.needsUpdate = ae,
            N.pointLightShadows.needsUpdate = ae,
            N.spotLights.needsUpdate = ae,
            N.spotLightShadows.needsUpdate = ae,
            N.rectAreaLights.needsUpdate = ae,
            N.hemisphereLights.needsUpdate = ae
        }
        function on(N) {
            return N.isMeshLambertMaterial || N.isMeshToonMaterial || N.isMeshPhongMaterial || N.isMeshStandardMaterial || N.isShadowMaterial || N.isShaderMaterial && N.lights === !0
        }
        this.getActiveCubeFace = function() {
            return A
        }
        ,
        this.getActiveMipmapLevel = function() {
            return F
        }
        ,
        this.getRenderTarget = function() {
            return z
        }
        ,
        this.setRenderTargetTextures = function(N, ae, ye) {
            const xe = Xe.get(N);
            xe.__autoAllocateDepthBuffer = N.resolveDepthBuffer === !1,
            xe.__autoAllocateDepthBuffer === !1 && (xe.__useRenderToTexture = !1),
            Xe.get(N.texture).__webglTexture = ae,
            Xe.get(N.depthTexture).__webglTexture = xe.__autoAllocateDepthBuffer ? void 0 : ye,
            xe.__hasExternalTextures = !0
        }
        ,
        this.setRenderTargetFramebuffer = function(N, ae) {
            const ye = Xe.get(N);
            ye.__webglFramebuffer = ae,
            ye.__useDefaultFramebuffer = ae === void 0
        }
        ;
        const $t = G.createFramebuffer();
        this.setRenderTarget = function(N, ae=0, ye=0) {
            z = N,
            A = ae,
            F = ye;
            let xe = !0
              , ue = null
              , ke = !1
              , Ge = !1;
            if (N) {
                const We = Xe.get(N);
                if (We.__useDefaultFramebuffer !== void 0)
                    rt.bindFramebuffer(G.FRAMEBUFFER, null),
                    xe = !1;
                else if (We.__webglFramebuffer === void 0)
                    B.setupRenderTarget(N);
                else if (We.__hasExternalTextures)
                    B.rebindTextures(N, Xe.get(N.texture).__webglTexture, Xe.get(N.depthTexture).__webglTexture);
                else if (N.depthBuffer) {
                    const gt = N.depthTexture;
                    if (We.__boundDepthTexture !== gt) {
                        if (gt !== null && Xe.has(gt) && (N.width !== gt.image.width || N.height !== gt.image.height))
                            throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                        B.setupDepthRenderbuffer(N)
                    }
                }
                const Mt = N.texture;
                (Mt.isData3DTexture || Mt.isDataArrayTexture || Mt.isCompressedArrayTexture) && (Ge = !0);
                const St = Xe.get(N).__webglFramebuffer;
                N.isWebGLCubeRenderTarget ? (Array.isArray(St[ae]) ? ue = St[ae][ye] : ue = St[ae],
                ke = !0) : N.samples > 0 && B.useMultisampledRTT(N) === !1 ? ue = Xe.get(N).__webglMultisampledFramebuffer : Array.isArray(St) ? ue = St[ye] : ue = St,
                V.copy(N.viewport),
                Q.copy(N.scissor),
                X = N.scissorTest
            } else
                V.copy(ee).multiplyScalar(H).floor(),
                Q.copy(ge).multiplyScalar(H).floor(),
                X = pe;
            if (ye !== 0 && (ue = $t),
            rt.bindFramebuffer(G.FRAMEBUFFER, ue) && xe && rt.drawBuffers(N, ue),
            rt.viewport(V),
            rt.scissor(Q),
            rt.setScissorTest(X),
            ke) {
                const We = Xe.get(N.texture);
                G.framebufferTexture2D(G.FRAMEBUFFER, G.COLOR_ATTACHMENT0, G.TEXTURE_CUBE_MAP_POSITIVE_X + ae, We.__webglTexture, ye)
            } else if (Ge) {
                const We = Xe.get(N.texture)
                  , Mt = ae;
                G.framebufferTextureLayer(G.FRAMEBUFFER, G.COLOR_ATTACHMENT0, We.__webglTexture, ye, Mt)
            } else if (N !== null && ye !== 0) {
                const We = Xe.get(N.texture);
                G.framebufferTexture2D(G.FRAMEBUFFER, G.COLOR_ATTACHMENT0, G.TEXTURE_2D, We.__webglTexture, ye)
            }
            U = -1
        }
        ,
        this.readRenderTargetPixels = function(N, ae, ye, xe, ue, ke, Ge) {
            if (!(N && N.isWebGLRenderTarget)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                return
            }
            let Ie = Xe.get(N).__webglFramebuffer;
            if (N.isWebGLCubeRenderTarget && Ge !== void 0 && (Ie = Ie[Ge]),
            Ie) {
                rt.bindFramebuffer(G.FRAMEBUFFER, Ie);
                try {
                    const We = N.texture
                      , Mt = We.format
                      , St = We.type;
                    if (!it.textureFormatReadable(Mt)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        return
                    }
                    if (!it.textureTypeReadable(St)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        return
                    }
                    ae >= 0 && ae <= N.width - xe && ye >= 0 && ye <= N.height - ue && G.readPixels(ae, ye, xe, ue, Tt.convert(Mt), Tt.convert(St), ke)
                } finally {
                    const We = z !== null ? Xe.get(z).__webglFramebuffer : null;
                    rt.bindFramebuffer(G.FRAMEBUFFER, We)
                }
            }
        }
        ,
        this.readRenderTargetPixelsAsync = async function(N, ae, ye, xe, ue, ke, Ge) {
            if (!(N && N.isWebGLRenderTarget))
                throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            let Ie = Xe.get(N).__webglFramebuffer;
            if (N.isWebGLCubeRenderTarget && Ge !== void 0 && (Ie = Ie[Ge]),
            Ie)
                if (ae >= 0 && ae <= N.width - xe && ye >= 0 && ye <= N.height - ue) {
                    rt.bindFramebuffer(G.FRAMEBUFFER, Ie);
                    const We = N.texture
                      , Mt = We.format
                      , St = We.type;
                    if (!it.textureFormatReadable(Mt))
                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                    if (!it.textureTypeReadable(St))
                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                    const gt = G.createBuffer();
                    G.bindBuffer(G.PIXEL_PACK_BUFFER, gt),
                    G.bufferData(G.PIXEL_PACK_BUFFER, ke.byteLength, G.STREAM_READ),
                    G.readPixels(ae, ye, xe, ue, Tt.convert(Mt), Tt.convert(St), 0);
                    const Et = z !== null ? Xe.get(z).__webglFramebuffer : null;
                    rt.bindFramebuffer(G.FRAMEBUFFER, Et);
                    const jt = G.fenceSync(G.SYNC_GPU_COMMANDS_COMPLETE, 0);
                    return G.flush(),
                    await YU(G, jt, 4),
                    G.bindBuffer(G.PIXEL_PACK_BUFFER, gt),
                    G.getBufferSubData(G.PIXEL_PACK_BUFFER, 0, ke),
                    G.deleteBuffer(gt),
                    G.deleteSync(jt),
                    ke
                } else
                    throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")
        }
        ,
        this.copyFramebufferToTexture = function(N, ae=null, ye=0) {
            const xe = Math.pow(2, -ye)
              , ue = Math.floor(N.image.width * xe)
              , ke = Math.floor(N.image.height * xe)
              , Ge = ae !== null ? ae.x : 0
              , Ie = ae !== null ? ae.y : 0;
            B.setTexture2D(N, 0),
            G.copyTexSubImage2D(G.TEXTURE_2D, ye, 0, 0, Ge, Ie, ue, ke),
            rt.unbindTexture()
        }
        ;
        const br = G.createFramebuffer()
          , si = G.createFramebuffer();
        this.copyTextureToTexture = function(N, ae, ye=null, xe=null, ue=0, ke=null) {
            ke === null && (ue !== 0 ? (vf("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."),
            ke = ue,
            ue = 0) : ke = 0);
            let Ge, Ie, We, Mt, St, gt, Et, jt, Tn;
            const Kt = N.isCompressedTexture ? N.mipmaps[ke] : N.image;
            if (ye !== null)
                Ge = ye.max.x - ye.min.x,
                Ie = ye.max.y - ye.min.y,
                We = ye.isBox3 ? ye.max.z - ye.min.z : 1,
                Mt = ye.min.x,
                St = ye.min.y,
                gt = ye.isBox3 ? ye.min.z : 0;
            else {
                const qn = Math.pow(2, -ue);
                Ge = Math.floor(Kt.width * qn),
                Ie = Math.floor(Kt.height * qn),
                N.isDataArrayTexture ? We = Kt.depth : N.isData3DTexture ? We = Math.floor(Kt.depth * qn) : We = 1,
                Mt = 0,
                St = 0,
                gt = 0
            }
            xe !== null ? (Et = xe.x,
            jt = xe.y,
            Tn = xe.z) : (Et = 0,
            jt = 0,
            Tn = 0);
            const an = Tt.convert(ae.format)
              , At = Tt.convert(ae.type);
            let Nn;
            ae.isData3DTexture ? (B.setTexture3D(ae, 0),
            Nn = G.TEXTURE_3D) : ae.isDataArrayTexture || ae.isCompressedArrayTexture ? (B.setTexture2DArray(ae, 0),
            Nn = G.TEXTURE_2D_ARRAY) : (B.setTexture2D(ae, 0),
            Nn = G.TEXTURE_2D),
            G.pixelStorei(G.UNPACK_FLIP_Y_WEBGL, ae.flipY),
            G.pixelStorei(G.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ae.premultiplyAlpha),
            G.pixelStorei(G.UNPACK_ALIGNMENT, ae.unpackAlignment);
            const cn = G.getParameter(G.UNPACK_ROW_LENGTH)
              , hi = G.getParameter(G.UNPACK_IMAGE_HEIGHT)
              , Da = G.getParameter(G.UNPACK_SKIP_PIXELS)
              , An = G.getParameter(G.UNPACK_SKIP_ROWS)
              , Vr = G.getParameter(G.UNPACK_SKIP_IMAGES);
            G.pixelStorei(G.UNPACK_ROW_LENGTH, Kt.width),
            G.pixelStorei(G.UNPACK_IMAGE_HEIGHT, Kt.height),
            G.pixelStorei(G.UNPACK_SKIP_PIXELS, Mt),
            G.pixelStorei(G.UNPACK_SKIP_ROWS, St),
            G.pixelStorei(G.UNPACK_SKIP_IMAGES, gt);
            const Mn = N.isDataArrayTexture || N.isData3DTexture
              , pi = ae.isDataArrayTexture || ae.isData3DTexture;
            if (N.isDepthTexture) {
                const qn = Xe.get(N)
                  , ti = Xe.get(ae)
                  , oi = Xe.get(qn.__renderTarget)
                  , Sr = Xe.get(ti.__renderTarget);
                rt.bindFramebuffer(G.READ_FRAMEBUFFER, oi.__webglFramebuffer),
                rt.bindFramebuffer(G.DRAW_FRAMEBUFFER, Sr.__webglFramebuffer);
                for (let Hr = 0; Hr < We; Hr++)
                    Mn && (G.framebufferTextureLayer(G.READ_FRAMEBUFFER, G.COLOR_ATTACHMENT0, Xe.get(N).__webglTexture, ue, gt + Hr),
                    G.framebufferTextureLayer(G.DRAW_FRAMEBUFFER, G.COLOR_ATTACHMENT0, Xe.get(ae).__webglTexture, ke, Tn + Hr)),
                    G.blitFramebuffer(Mt, St, Ge, Ie, Et, jt, Ge, Ie, G.DEPTH_BUFFER_BIT, G.NEAREST);
                rt.bindFramebuffer(G.READ_FRAMEBUFFER, null),
                rt.bindFramebuffer(G.DRAW_FRAMEBUFFER, null)
            } else if (ue !== 0 || N.isRenderTargetTexture || Xe.has(N)) {
                const qn = Xe.get(N)
                  , ti = Xe.get(ae);
                rt.bindFramebuffer(G.READ_FRAMEBUFFER, br),
                rt.bindFramebuffer(G.DRAW_FRAMEBUFFER, si);
                for (let oi = 0; oi < We; oi++)
                    Mn ? G.framebufferTextureLayer(G.READ_FRAMEBUFFER, G.COLOR_ATTACHMENT0, qn.__webglTexture, ue, gt + oi) : G.framebufferTexture2D(G.READ_FRAMEBUFFER, G.COLOR_ATTACHMENT0, G.TEXTURE_2D, qn.__webglTexture, ue),
                    pi ? G.framebufferTextureLayer(G.DRAW_FRAMEBUFFER, G.COLOR_ATTACHMENT0, ti.__webglTexture, ke, Tn + oi) : G.framebufferTexture2D(G.DRAW_FRAMEBUFFER, G.COLOR_ATTACHMENT0, G.TEXTURE_2D, ti.__webglTexture, ke),
                    ue !== 0 ? G.blitFramebuffer(Mt, St, Ge, Ie, Et, jt, Ge, Ie, G.COLOR_BUFFER_BIT, G.NEAREST) : pi ? G.copyTexSubImage3D(Nn, ke, Et, jt, Tn + oi, Mt, St, Ge, Ie) : G.copyTexSubImage2D(Nn, ke, Et, jt, Mt, St, Ge, Ie);
                rt.bindFramebuffer(G.READ_FRAMEBUFFER, null),
                rt.bindFramebuffer(G.DRAW_FRAMEBUFFER, null)
            } else
                pi ? N.isDataTexture || N.isData3DTexture ? G.texSubImage3D(Nn, ke, Et, jt, Tn, Ge, Ie, We, an, At, Kt.data) : ae.isCompressedArrayTexture ? G.compressedTexSubImage3D(Nn, ke, Et, jt, Tn, Ge, Ie, We, an, Kt.data) : G.texSubImage3D(Nn, ke, Et, jt, Tn, Ge, Ie, We, an, At, Kt) : N.isDataTexture ? G.texSubImage2D(G.TEXTURE_2D, ke, Et, jt, Ge, Ie, an, At, Kt.data) : N.isCompressedTexture ? G.compressedTexSubImage2D(G.TEXTURE_2D, ke, Et, jt, Kt.width, Kt.height, an, Kt.data) : G.texSubImage2D(G.TEXTURE_2D, ke, Et, jt, Ge, Ie, an, At, Kt);
            G.pixelStorei(G.UNPACK_ROW_LENGTH, cn),
            G.pixelStorei(G.UNPACK_IMAGE_HEIGHT, hi),
            G.pixelStorei(G.UNPACK_SKIP_PIXELS, Da),
            G.pixelStorei(G.UNPACK_SKIP_ROWS, An),
            G.pixelStorei(G.UNPACK_SKIP_IMAGES, Vr),
            ke === 0 && ae.generateMipmaps && G.generateMipmap(Nn),
            rt.unbindTexture()
        }
        ,
        this.copyTextureToTexture3D = function(N, ae, ye=null, xe=null, ue=0) {
            return vf('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'),
            this.copyTextureToTexture(N, ae, ye, xe, ue)
        }
        ,
        this.initRenderTarget = function(N) {
            Xe.get(N).__webglFramebuffer === void 0 && B.setupRenderTarget(N)
        }
        ,
        this.initTexture = function(N) {
            N.isCubeTexture ? B.setTextureCube(N, 0) : N.isData3DTexture ? B.setTexture3D(N, 0) : N.isDataArrayTexture || N.isCompressedArrayTexture ? B.setTexture2DArray(N, 0) : B.setTexture2D(N, 0),
            rt.unbindTexture()
        }
        ,
        this.resetState = function() {
            A = 0,
            F = 0,
            z = null,
            rt.reset(),
            qt.reset()
        }
        ,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    get coordinateSystem() {
        return xa
    }
    get outputColorSpace() {
        return this._outputColorSpace
    }
    set outputColorSpace(e) {
        this._outputColorSpace = e;
        const t = this.getContext();
        t.drawingBufferColorSpace = fn._getDrawingBufferColorSpace(e),
        t.unpackColorSpace = fn._getUnpackColorSpace()
    }
}
const _I = () => {
    const n = $.useRef(null)
      , e = $.useRef(0)
      , t = $.useRef(0)
      , r = u => {
        const d = new Float32Array(u * 3);
        for (let f = 0; f < u * 3; f++)
            d[f] = (Math.random() - .5) * 10;
        return d
    }
      , s = u => {
        const d = new Float32Array(u * 3);
        for (let f = 0; f < u * 3; f++)
            d[f] = (Math.random() - .5) * .001;
        return d
    }
      , o = u => {
        const d = u.domElement
          , f = d.clientWidth
          , h = d.clientHeight
          , m = d.width !== f || d.height !== h;
        return m && u.setSize(f, h, !1),
        m
    }
    ;
    return $.useEffect( () => {
        if (!n.current)
            return;
        const u = new vI({
            canvas: n.current
        });
        u.outputColorSpace = Xi,
        u.setClearColor(new pn("#000000"));
        const d = new bL
          , f = new NL(16777215,1);
        f.position.set(-1, 2, 4),
        d.add(f);
        const h = 75
          , m = n.current.clientWidth / n.current.clientHeight
          , g = 1.5
          , _ = 5
          , x = new ir(h,m,g,_);
        x.position.z = 2;
        const E = [350, 1500]
          , M = [new Ir, new Ir];
        M[0].setAttribute("position", new ar(r(E[0]),3)),
        M[1].setAttribute("position", new ar(r(E[1]),3));
        const b = [s(E[0]), s(E[1])]
          , y = new CL;
        let T, D;
        const C = () => {
            if (o(u)) {
                const A = u.domElement;
                x.aspect = A.clientWidth / A.clientHeight,
                x.updateProjectionMatrix()
            }
            T.position.x = e.current * 1e-4,
            T.position.y = t.current * -1e-4,
            D.position.x = e.current * 1e-4,
            D.position.y = t.current * -1e-4;
            for (let A = 0; A < 2; A++) {
                const F = M[A].attributes.position.array;
                for (let z = 0; z < F.length; z += 3)
                    F[z] += b[A][z],
                    F[z + 1] += b[A][z + 1],
                    F[z + 2] += b[A][z + 2],
                    Math.abs(F[z]) > 5 && (b[A][z] *= -1),
                    Math.abs(F[z + 1]) > 5 && (b[A][z + 1] *= -1),
                    Math.abs(F[z + 2]) > 5 && (b[A][z + 2] *= -1);
                M[A].attributes.position.needsUpdate = !0
            }
            u.render(d, x),
            requestAnimationFrame(C)
        }
        ;
        y.load("https://raw.githubusercontent.com/Kuntal-Das/textures/main/sp1.png", A => {
            y.load("https://raw.githubusercontent.com/Kuntal-Das/textures/main/sp2.png", F => {
                const z = [new Ev({
                    size: .05,
                    map: A,
                    transparent: !0,
                    opacity: 1
                }), new Ev({
                    size: .075,
                    map: F,
                    transparent: !0,
                    opacity: 1
                })];
                T = new bS(M[0],z[0]),
                D = new bS(M[1],z[1]),
                d.add(T, D),
                requestAnimationFrame(C)
            }
            )
        }
        );
        const P = A => {
            e.current = A.clientX,
            t.current = A.clientY
        }
        ;
        return window.addEventListener("mousemove", P),
        () => {
            window.removeEventListener("mousemove", P),
            u.dispose()
        }
    }
    , []),
    Z.jsx("canvas", {
        ref: n,
        className: "fixed inset-0 w-full h-full z-0",
        style: {
            display: "block"
        }
    })
}
;
function yI(n) {
    if (typeof document > "u")
        return;
    let e = document.head || document.getElementsByTagName("head")[0]
      , t = document.createElement("style");
    t.type = "text/css",
    e.appendChild(t),
    t.styleSheet ? t.styleSheet.cssText = n : t.appendChild(document.createTextNode(n))
}
const xI = n => {
    switch (n) {
    case "success":
        return EI;
    case "info":
        return wI;
    case "warning":
        return MI;
    case "error":
        return TI;
    default:
        return null
    }
}
  , bI = Array(12).fill(0)
  , SI = ({visible: n, className: e}) => K.createElement("div", {
    className: ["sonner-loading-wrapper", e].filter(Boolean).join(" "),
    "data-visible": n
}, K.createElement("div", {
    className: "sonner-spinner"
}, bI.map( (t, r) => K.createElement("div", {
    className: "sonner-loading-bar",
    key: `spinner-bar-${r}`
}))))
  , EI = K.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    height: "20",
    width: "20"
}, K.createElement("path", {
    fillRule: "evenodd",
    d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z",
    clipRule: "evenodd"
}))
  , MI = K.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    height: "20",
    width: "20"
}, K.createElement("path", {
    fillRule: "evenodd",
    d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",
    clipRule: "evenodd"
}))
  , wI = K.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    height: "20",
    width: "20"
}, K.createElement("path", {
    fillRule: "evenodd",
    d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z",
    clipRule: "evenodd"
}))
  , TI = K.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    height: "20",
    width: "20"
}, K.createElement("path", {
    fillRule: "evenodd",
    d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z",
    clipRule: "evenodd"
}))
  , AI = K.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "12",
    height: "12",
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}, K.createElement("line", {
    x1: "18",
    y1: "6",
    x2: "6",
    y2: "18"
}), K.createElement("line", {
    x1: "6",
    y1: "6",
    x2: "18",
    y2: "18"
}))
  , RI = () => {
    const [n,e] = K.useState(document.hidden);
    return K.useEffect( () => {
        const t = () => {
            e(document.hidden)
        }
        ;
        return document.addEventListener("visibilitychange", t),
        () => window.removeEventListener("visibilitychange", t)
    }
    , []),
    n
}
;
let Tv = 1;
class CI {
    constructor() {
        this.subscribe = e => (this.subscribers.push(e),
        () => {
            const t = this.subscribers.indexOf(e);
            this.subscribers.splice(t, 1)
        }
        ),
        this.publish = e => {
            this.subscribers.forEach(t => t(e))
        }
        ,
        this.addToast = e => {
            this.publish(e),
            this.toasts = [...this.toasts, e]
        }
        ,
        this.create = e => {
            var t;
            const {message: r, ...s} = e
              , o = typeof (e == null ? void 0 : e.id) == "number" || ((t = e.id) == null ? void 0 : t.length) > 0 ? e.id : Tv++
              , u = this.toasts.find(f => f.id === o)
              , d = e.dismissible === void 0 ? !0 : e.dismissible;
            return this.dismissedToasts.has(o) && this.dismissedToasts.delete(o),
            u ? this.toasts = this.toasts.map(f => f.id === o ? (this.publish({
                ...f,
                ...e,
                id: o,
                title: r
            }),
            {
                ...f,
                ...e,
                id: o,
                dismissible: d,
                title: r
            }) : f) : this.addToast({
                title: r,
                ...s,
                dismissible: d,
                id: o
            }),
            o
        }
        ,
        this.dismiss = e => (e ? (this.dismissedToasts.add(e),
        requestAnimationFrame( () => this.subscribers.forEach(t => t({
            id: e,
            dismiss: !0
        })))) : this.toasts.forEach(t => {
            this.subscribers.forEach(r => r({
                id: t.id,
                dismiss: !0
            }))
        }
        ),
        e),
        this.message = (e, t) => this.create({
            ...t,
            message: e
        }),
        this.error = (e, t) => this.create({
            ...t,
            message: e,
            type: "error"
        }),
        this.success = (e, t) => this.create({
            ...t,
            type: "success",
            message: e
        }),
        this.info = (e, t) => this.create({
            ...t,
            type: "info",
            message: e
        }),
        this.warning = (e, t) => this.create({
            ...t,
            type: "warning",
            message: e
        }),
        this.loading = (e, t) => this.create({
            ...t,
            type: "loading",
            message: e
        }),
        this.promise = (e, t) => {
            if (!t)
                return;
            let r;
            t.loading !== void 0 && (r = this.create({
                ...t,
                promise: e,
                type: "loading",
                message: t.loading,
                description: typeof t.description != "function" ? t.description : void 0
            }));
            const s = Promise.resolve(e instanceof Function ? e() : e);
            let o = r !== void 0, u;
            const d = s.then(async h => {
                if (u = ["resolve", h],
                K.isValidElement(h))
                    o = !1,
                    this.create({
                        id: r,
                        type: "default",
                        message: h
                    });
                else if (UI(h) && !h.ok) {
                    o = !1;
                    const g = typeof t.error == "function" ? await t.error(`HTTP error! status: ${h.status}`) : t.error
                      , _ = typeof t.description == "function" ? await t.description(`HTTP error! status: ${h.status}`) : t.description
                      , E = typeof g == "object" && !K.isValidElement(g) ? g : {
                        message: g
                    };
                    this.create({
                        id: r,
                        type: "error",
                        description: _,
                        ...E
                    })
                } else if (h instanceof Error) {
                    o = !1;
                    const g = typeof t.error == "function" ? await t.error(h) : t.error
                      , _ = typeof t.description == "function" ? await t.description(h) : t.description
                      , E = typeof g == "object" && !K.isValidElement(g) ? g : {
                        message: g
                    };
                    this.create({
                        id: r,
                        type: "error",
                        description: _,
                        ...E
                    })
                } else if (t.success !== void 0) {
                    o = !1;
                    const g = typeof t.success == "function" ? await t.success(h) : t.success
                      , _ = typeof t.description == "function" ? await t.description(h) : t.description
                      , E = typeof g == "object" && !K.isValidElement(g) ? g : {
                        message: g
                    };
                    this.create({
                        id: r,
                        type: "success",
                        description: _,
                        ...E
                    })
                }
            }
            ).catch(async h => {
                if (u = ["reject", h],
                t.error !== void 0) {
                    o = !1;
                    const m = typeof t.error == "function" ? await t.error(h) : t.error
                      , g = typeof t.description == "function" ? await t.description(h) : t.description
                      , x = typeof m == "object" && !K.isValidElement(m) ? m : {
                        message: m
                    };
                    this.create({
                        id: r,
                        type: "error",
                        description: g,
                        ...x
                    })
                }
            }
            ).finally( () => {
                o && (this.dismiss(r),
                r = void 0),
                t.finally == null || t.finally.call(t)
            }
            )
              , f = () => new Promise( (h, m) => d.then( () => u[0] === "reject" ? m(u[1]) : h(u[1])).catch(m));
            return typeof r != "string" && typeof r != "number" ? {
                unwrap: f
            } : Object.assign(r, {
                unwrap: f
            })
        }
        ,
        this.custom = (e, t) => {
            const r = (t == null ? void 0 : t.id) || Tv++;
            return this.create({
                jsx: e(r),
                id: r,
                ...t
            }),
            r
        }
        ,
        this.getActiveToasts = () => this.toasts.filter(e => !this.dismissedToasts.has(e.id)),
        this.subscribers = [],
        this.toasts = [],
        this.dismissedToasts = new Set
    }
}
const Li = new CI
  , DI = (n, e) => {
    const t = (e == null ? void 0 : e.id) || Tv++;
    return Li.addToast({
        title: n,
        ...e,
        id: t
    }),
    t
}
  , UI = n => n && typeof n == "object" && "ok"in n && typeof n.ok == "boolean" && "status"in n && typeof n.status == "number"
  , LI = DI
  , NI = () => Li.toasts
  , OI = () => Li.getActiveToasts()
  , pw = Object.assign(LI, {
    success: Li.success,
    info: Li.info,
    warning: Li.warning,
    error: Li.error,
    custom: Li.custom,
    message: Li.message,
    promise: Li.promise,
    dismiss: Li.dismiss,
    loading: Li.loading
}, {
    getHistory: NI,
    getToasts: OI
});
yI("[data-sonner-toaster][dir=ltr],html[dir=ltr]{--toast-icon-margin-start:-3px;--toast-icon-margin-end:4px;--toast-svg-margin-start:-1px;--toast-svg-margin-end:0px;--toast-button-margin-start:auto;--toast-button-margin-end:0;--toast-close-button-start:0;--toast-close-button-end:unset;--toast-close-button-transform:translate(-35%, -35%)}[data-sonner-toaster][dir=rtl],html[dir=rtl]{--toast-icon-margin-start:4px;--toast-icon-margin-end:-3px;--toast-svg-margin-start:0px;--toast-svg-margin-end:-1px;--toast-button-margin-start:0;--toast-button-margin-end:auto;--toast-close-button-start:unset;--toast-close-button-end:0;--toast-close-button-transform:translate(35%, -35%)}[data-sonner-toaster]{position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1:hsl(0, 0%, 99%);--gray2:hsl(0, 0%, 97.3%);--gray3:hsl(0, 0%, 95.1%);--gray4:hsl(0, 0%, 93%);--gray5:hsl(0, 0%, 90.9%);--gray6:hsl(0, 0%, 88.7%);--gray7:hsl(0, 0%, 85.8%);--gray8:hsl(0, 0%, 78%);--gray9:hsl(0, 0%, 56.1%);--gray10:hsl(0, 0%, 52.3%);--gray11:hsl(0, 0%, 43.5%);--gray12:hsl(0, 0%, 9%);--border-radius:8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:0;z-index:999999999;transition:transform .4s ease}[data-sonner-toaster][data-lifted=true]{transform:translateY(-8px)}@media (hover:none) and (pointer:coarse){[data-sonner-toaster][data-lifted=true]{transform:none}}[data-sonner-toaster][data-x-position=right]{right:var(--offset-right)}[data-sonner-toaster][data-x-position=left]{left:var(--offset-left)}[data-sonner-toaster][data-x-position=center]{left:50%;transform:translateX(-50%)}[data-sonner-toaster][data-y-position=top]{top:var(--offset-top)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--offset-bottom)}[data-sonner-toast]{--y:translateY(100%);--lift-amount:calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:0;overflow-wrap:anywhere}[data-sonner-toast][data-styled=true]{padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px rgba(0,0,0,.1);width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}[data-sonner-toast]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-y-position=top]{top:0;--y:translateY(-100%);--lift:1;--lift-amount:calc(1 * var(--gap))}[data-sonner-toast][data-y-position=bottom]{bottom:0;--y:translateY(100%);--lift:-1;--lift-amount:calc(var(--lift) * var(--gap))}[data-sonner-toast][data-styled=true] [data-description]{font-weight:400;line-height:1.4;color:#3f3f3f}[data-rich-colors=true][data-sonner-toast][data-styled=true] [data-description]{color:inherit}[data-sonner-toaster][data-sonner-theme=dark] [data-description]{color:#e8e8e8}[data-sonner-toast][data-styled=true] [data-title]{font-weight:500;line-height:1.5;color:inherit}[data-sonner-toast][data-styled=true] [data-icon]{display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}[data-sonner-toast][data-promise=true] [data-icon]>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}[data-sonner-toast][data-styled=true] [data-icon]>*{flex-shrink:0}[data-sonner-toast][data-styled=true] [data-icon] svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}[data-sonner-toast][data-styled=true] [data-content]{display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;font-weight:500;cursor:pointer;outline:0;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}[data-sonner-toast][data-styled=true] [data-button]:focus-visible{box-shadow:0 0 0 2px rgba(0,0,0,.4)}[data-sonner-toast][data-styled=true] [data-button]:first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}[data-sonner-toast][data-styled=true] [data-cancel]{color:var(--normal-text);background:rgba(0,0,0,.08)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-styled=true] [data-cancel]{background:rgba(255,255,255,.3)}[data-sonner-toast][data-styled=true] [data-close-button]{position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;color:var(--gray12);background:var(--normal-bg);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast][data-styled=true] [data-close-button]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-styled=true] [data-disabled=true]{cursor:not-allowed}[data-sonner-toast][data-styled=true]:hover [data-close-button]:hover{background:var(--gray2);border-color:var(--gray5)}[data-sonner-toast][data-swiping=true]::before{content:'';position:absolute;left:-100%;right:-100%;height:100%;z-index:-1}[data-sonner-toast][data-y-position=top][data-swiping=true]::before{bottom:50%;transform:scaleY(3) translateY(50%)}[data-sonner-toast][data-y-position=bottom][data-swiping=true]::before{top:50%;transform:scaleY(3) translateY(-50%)}[data-sonner-toast][data-swiping=false][data-removed=true]::before{content:'';position:absolute;inset:0;transform:scaleY(2)}[data-sonner-toast][data-expanded=true]::after{content:'';position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}[data-sonner-toast][data-mounted=true]{--y:translateY(0);opacity:1}[data-sonner-toast][data-expanded=false][data-front=false]{--scale:var(--toasts-before) * 0.05 + 1;--y:translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}[data-sonner-toast]>*{transition:opacity .4s}[data-sonner-toast][data-x-position=right]{right:0}[data-sonner-toast][data-x-position=left]{left:0}[data-sonner-toast][data-expanded=false][data-front=false][data-styled=true]>*{opacity:0}[data-sonner-toast][data-visible=false]{opacity:0;pointer-events:none}[data-sonner-toast][data-mounted=true][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}[data-sonner-toast][data-removed=true][data-front=true][data-swipe-out=false]{--y:translateY(calc(var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=false]{--y:translateY(40%);opacity:0;transition:transform .5s,opacity .2s}[data-sonner-toast][data-removed=true][data-front=false]::before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount-y,0)) translateX(var(--swipe-amount-x,0));transition:none}[data-sonner-toast][data-swiped=true]{user-select:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation-duration:.2s;animation-timing-function:ease-out;animation-fill-mode:forwards}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=left]{animation-name:swipe-out-left}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=right]{animation-name:swipe-out-right}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=up]{animation-name:swipe-out-up}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=down]{animation-name:swipe-out-down}@keyframes swipe-out-left{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) - 100%));opacity:0}}@keyframes swipe-out-right{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) + 100%));opacity:0}}@keyframes swipe-out-up{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) - 100%));opacity:0}}@keyframes swipe-out-down{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) + 100%));opacity:0}}@media (max-width:600px){[data-sonner-toaster]{position:fixed;right:var(--mobile-offset-right);left:var(--mobile-offset-left);width:100%}[data-sonner-toaster][dir=rtl]{left:calc(var(--mobile-offset-left) * -1)}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset-left) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset-left)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--mobile-offset-bottom)}[data-sonner-toaster][data-y-position=top]{top:var(--mobile-offset-top)}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset-left);right:var(--mobile-offset-right);transform:none}}[data-sonner-toaster][data-sonner-theme=light]{--normal-bg:#fff;--normal-border:var(--gray4);--normal-text:var(--gray12);--success-bg:hsl(143, 85%, 96%);--success-border:hsl(145, 92%, 87%);--success-text:hsl(140, 100%, 27%);--info-bg:hsl(208, 100%, 97%);--info-border:hsl(221, 91%, 93%);--info-text:hsl(210, 92%, 45%);--warning-bg:hsl(49, 100%, 97%);--warning-border:hsl(49, 91%, 84%);--warning-text:hsl(31, 92%, 45%);--error-bg:hsl(359, 100%, 97%);--error-border:hsl(359, 100%, 94%);--error-text:hsl(360, 100%, 45%)}[data-sonner-toaster][data-sonner-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg:#000;--normal-border:hsl(0, 0%, 20%);--normal-text:var(--gray1)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg:#fff;--normal-border:var(--gray3);--normal-text:var(--gray12)}[data-sonner-toaster][data-sonner-theme=dark]{--normal-bg:#000;--normal-bg-hover:hsl(0, 0%, 12%);--normal-border:hsl(0, 0%, 20%);--normal-border-hover:hsl(0, 0%, 25%);--normal-text:var(--gray1);--success-bg:hsl(150, 100%, 6%);--success-border:hsl(147, 100%, 12%);--success-text:hsl(150, 86%, 65%);--info-bg:hsl(215, 100%, 6%);--info-border:hsl(223, 43%, 17%);--info-text:hsl(216, 87%, 65%);--warning-bg:hsl(64, 100%, 6%);--warning-border:hsl(60, 100%, 9%);--warning-text:hsl(46, 87%, 65%);--error-bg:hsl(358, 76%, 10%);--error-border:hsl(357, 89%, 16%);--error-text:hsl(358, 100%, 81%)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]{background:var(--normal-bg);border-color:var(--normal-border);color:var(--normal-text)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]:hover{background:var(--normal-bg-hover);border-color:var(--normal-border-hover)}[data-rich-colors=true][data-sonner-toast][data-type=success]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size:16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:first-child{animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}100%{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}100%{opacity:.15}}@media (prefers-reduced-motion){.sonner-loading-bar,[data-sonner-toast],[data-sonner-toast]>*{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}");
function af(n) {
    return n.label !== void 0
}
const PI = 3
  , II = "24px"
  , zI = "16px"
  , KS = 4e3
  , kI = 356
  , FI = 14
  , BI = 45
  , VI = 200;
function Rr(...n) {
    return n.filter(Boolean).join(" ")
}
function HI(n) {
    const [e,t] = n.split("-")
      , r = [];
    return e && r.push(e),
    t && r.push(t),
    r
}
const GI = n => {
    var e, t, r, s, o, u, d, f, h;
    const {invert: m, toast: g, unstyled: _, interacting: x, setHeights: E, visibleToasts: M, heights: b, index: y, toasts: T, expanded: D, removeToast: C, defaultRichColors: P, closeButton: A, style: F, cancelButtonStyle: z, actionButtonStyle: U, className: R="", descriptionClassName: V="", duration: Q, position: X, gap: oe, expandByDefault: le, classNames: O, icons: W, closeButtonAriaLabel: H="Close toast"} = n
      , [Me,k] = K.useState(null)
      , [ee,ge] = K.useState(null)
      , [pe,te] = K.useState(!1)
      , [we,Se] = K.useState(!1)
      , [De,Ve] = K.useState(!1)
      , [_t,He] = K.useState(!1)
      , [Pt,kt] = K.useState(!1)
      , [nt,G] = K.useState(0)
      , [Zt,ot] = K.useState(0)
      , it = K.useRef(g.duration || Q || KS)
      , rt = K.useRef(null)
      , pt = K.useRef(null)
      , Xe = y === 0
      , B = y + 1 <= M
      , S = g.type
      , I = g.dismissible !== !1
      , q = g.className || ""
      , se = g.descriptionClassName || ""
      , J = K.useMemo( () => b.findIndex(Ce => Ce.toastId === g.id) || 0, [b, g.id])
      , de = K.useMemo( () => {
        var Ce;
        return (Ce = g.closeButton) != null ? Ce : A
    }
    , [g.closeButton, A])
      , _e = K.useMemo( () => g.duration || Q || KS, [g.duration, Q])
      , Ae = K.useRef(0)
      , lt = K.useRef(0)
      , Le = K.useRef(0)
      , $e = K.useRef(null)
      , [ht,yt] = X.split("-")
      , qe = K.useMemo( () => b.reduce( (Ce, at, zt) => zt >= J ? Ce : Ce + at.height, 0), [b, J])
      , Lt = RI()
      , Tt = g.invert || m
      , qt = S === "loading";
    lt.current = K.useMemo( () => J * oe + qe, [J, qe]),
    K.useEffect( () => {
        it.current = _e
    }
    , [_e]),
    K.useEffect( () => {
        te(!0)
    }
    , []),
    K.useEffect( () => {
        const Ce = pt.current;
        if (Ce) {
            const at = Ce.getBoundingClientRect().height;
            return ot(at),
            E(zt => [{
                toastId: g.id,
                height: at,
                position: g.position
            }, ...zt]),
            () => E(zt => zt.filter(nn => nn.toastId !== g.id))
        }
    }
    , [E, g.id]),
    K.useLayoutEffect( () => {
        if (!pe)
            return;
        const Ce = pt.current
          , at = Ce.style.height;
        Ce.style.height = "auto";
        const zt = Ce.getBoundingClientRect().height;
        Ce.style.height = at,
        ot(zt),
        E(nn => nn.find(ie => ie.toastId === g.id) ? nn.map(ie => ie.toastId === g.id ? {
            ...ie,
            height: zt
        } : ie) : [{
            toastId: g.id,
            height: zt,
            position: g.position
        }, ...nn])
    }
    , [pe, g.title, g.description, E, g.id]);
    const re = K.useCallback( () => {
        Se(!0),
        G(lt.current),
        E(Ce => Ce.filter(at => at.toastId !== g.id)),
        setTimeout( () => {
            C(g)
        }
        , VI)
    }
    , [g, C, E, lt]);
    K.useEffect( () => {
        if (g.promise && S === "loading" || g.duration === 1 / 0 || g.type === "loading")
            return;
        let Ce;
        return D || x || Lt ? ( () => {
            if (Le.current < Ae.current) {
                const nn = new Date().getTime() - Ae.current;
                it.current = it.current - nn
            }
            Le.current = new Date().getTime()
        }
        )() : ( () => {
            it.current !== 1 / 0 && (Ae.current = new Date().getTime(),
            Ce = setTimeout( () => {
                g.onAutoClose == null || g.onAutoClose.call(g, g),
                re()
            }
            , it.current))
        }
        )(),
        () => clearTimeout(Ce)
    }
    , [D, x, g, S, Lt, re]),
    K.useEffect( () => {
        g.delete && re()
    }
    , [re, g.delete]);
    function Ye() {
        var Ce;
        if (W != null && W.loading) {
            var at;
            return K.createElement("div", {
                className: Rr(O == null ? void 0 : O.loader, g == null || (at = g.classNames) == null ? void 0 : at.loader, "sonner-loader"),
                "data-visible": S === "loading"
            }, W.loading)
        }
        return K.createElement(SI, {
            className: Rr(O == null ? void 0 : O.loader, g == null || (Ce = g.classNames) == null ? void 0 : Ce.loader),
            visible: S === "loading"
        })
    }
    const Te = g.icon || (W == null ? void 0 : W[S]) || xI(S);
    var Ne, Ke;
    return K.createElement("li", {
        tabIndex: 0,
        ref: pt,
        className: Rr(R, q, O == null ? void 0 : O.toast, g == null || (e = g.classNames) == null ? void 0 : e.toast, O == null ? void 0 : O.default, O == null ? void 0 : O[S], g == null || (t = g.classNames) == null ? void 0 : t[S]),
        "data-sonner-toast": "",
        "data-rich-colors": (Ne = g.richColors) != null ? Ne : P,
        "data-styled": !(g.jsx || g.unstyled || _),
        "data-mounted": pe,
        "data-promise": !!g.promise,
        "data-swiped": Pt,
        "data-removed": we,
        "data-visible": B,
        "data-y-position": ht,
        "data-x-position": yt,
        "data-index": y,
        "data-front": Xe,
        "data-swiping": De,
        "data-dismissible": I,
        "data-type": S,
        "data-invert": Tt,
        "data-swipe-out": _t,
        "data-swipe-direction": ee,
        "data-expanded": !!(D || le && pe),
        style: {
            "--index": y,
            "--toasts-before": y,
            "--z-index": T.length - y,
            "--offset": `${we ? nt : lt.current}px`,
            "--initial-height": le ? "auto" : `${Zt}px`,
            ...F,
            ...g.style
        },
        onDragEnd: () => {
            Ve(!1),
            k(null),
            $e.current = null
        }
        ,
        onPointerDown: Ce => {
            qt || !I || (rt.current = new Date,
            G(lt.current),
            Ce.target.setPointerCapture(Ce.pointerId),
            Ce.target.tagName !== "BUTTON" && (Ve(!0),
            $e.current = {
                x: Ce.clientX,
                y: Ce.clientY
            }))
        }
        ,
        onPointerUp: () => {
            var Ce, at, zt;
            if (_t || !I)
                return;
            $e.current = null;
            const nn = Number(((Ce = pt.current) == null ? void 0 : Ce.style.getPropertyValue("--swipe-amount-x").replace("px", "")) || 0)
              , j = Number(((at = pt.current) == null ? void 0 : at.style.getPropertyValue("--swipe-amount-y").replace("px", "")) || 0)
              , ie = new Date().getTime() - ((zt = rt.current) == null ? void 0 : zt.getTime())
              , fe = Me === "x" ? nn : j
              , Ue = Math.abs(fe) / ie;
            if (Math.abs(fe) >= BI || Ue > .11) {
                G(lt.current),
                g.onDismiss == null || g.onDismiss.call(g, g),
                ge(Me === "x" ? nn > 0 ? "right" : "left" : j > 0 ? "down" : "up"),
                re(),
                He(!0);
                return
            } else {
                var ze, je;
                (ze = pt.current) == null || ze.style.setProperty("--swipe-amount-x", "0px"),
                (je = pt.current) == null || je.style.setProperty("--swipe-amount-y", "0px")
            }
            kt(!1),
            Ve(!1),
            k(null)
        }
        ,
        onPointerMove: Ce => {
            var at, zt, nn;
            if (!$e.current || !I || ((at = window.getSelection()) == null ? void 0 : at.toString().length) > 0)
                return;
            const ie = Ce.clientY - $e.current.y
              , fe = Ce.clientX - $e.current.x;
            var Ue;
            const ze = (Ue = n.swipeDirections) != null ? Ue : HI(X);
            !Me && (Math.abs(fe) > 1 || Math.abs(ie) > 1) && k(Math.abs(fe) > Math.abs(ie) ? "x" : "y");
            let je = {
                x: 0,
                y: 0
            };
            const bt = Qe => 1 / (1.5 + Math.abs(Qe) / 20);
            if (Me === "y") {
                if (ze.includes("top") || ze.includes("bottom"))
                    if (ze.includes("top") && ie < 0 || ze.includes("bottom") && ie > 0)
                        je.y = ie;
                    else {
                        const Qe = ie * bt(ie);
                        je.y = Math.abs(Qe) < Math.abs(ie) ? Qe : ie
                    }
            } else if (Me === "x" && (ze.includes("left") || ze.includes("right")))
                if (ze.includes("left") && fe < 0 || ze.includes("right") && fe > 0)
                    je.x = fe;
                else {
                    const Qe = fe * bt(fe);
                    je.x = Math.abs(Qe) < Math.abs(fe) ? Qe : fe
                }
            (Math.abs(je.x) > 0 || Math.abs(je.y) > 0) && kt(!0),
            (zt = pt.current) == null || zt.style.setProperty("--swipe-amount-x", `${je.x}px`),
            (nn = pt.current) == null || nn.style.setProperty("--swipe-amount-y", `${je.y}px`)
        }
    }, de && !g.jsx && S !== "loading" ? K.createElement("button", {
        "aria-label": H,
        "data-disabled": qt,
        "data-close-button": !0,
        onClick: qt || !I ? () => {}
        : () => {
            re(),
            g.onDismiss == null || g.onDismiss.call(g, g)
        }
        ,
        className: Rr(O == null ? void 0 : O.closeButton, g == null || (r = g.classNames) == null ? void 0 : r.closeButton)
    }, (Ke = W == null ? void 0 : W.close) != null ? Ke : AI) : null, (S || g.icon || g.promise) && g.icon !== null && ((W == null ? void 0 : W[S]) !== null || g.icon) ? K.createElement("div", {
        "data-icon": "",
        className: Rr(O == null ? void 0 : O.icon, g == null || (s = g.classNames) == null ? void 0 : s.icon)
    }, g.promise || g.type === "loading" && !g.icon ? g.icon || Ye() : null, g.type !== "loading" ? Te : null) : null, K.createElement("div", {
        "data-content": "",
        className: Rr(O == null ? void 0 : O.content, g == null || (o = g.classNames) == null ? void 0 : o.content)
    }, K.createElement("div", {
        "data-title": "",
        className: Rr(O == null ? void 0 : O.title, g == null || (u = g.classNames) == null ? void 0 : u.title)
    }, g.jsx ? g.jsx : typeof g.title == "function" ? g.title() : g.title), g.description ? K.createElement("div", {
        "data-description": "",
        className: Rr(V, se, O == null ? void 0 : O.description, g == null || (d = g.classNames) == null ? void 0 : d.description)
    }, typeof g.description == "function" ? g.description() : g.description) : null), K.isValidElement(g.cancel) ? g.cancel : g.cancel && af(g.cancel) ? K.createElement("button", {
        "data-button": !0,
        "data-cancel": !0,
        style: g.cancelButtonStyle || z,
        onClick: Ce => {
            af(g.cancel) && I && (g.cancel.onClick == null || g.cancel.onClick.call(g.cancel, Ce),
            re())
        }
        ,
        className: Rr(O == null ? void 0 : O.cancelButton, g == null || (f = g.classNames) == null ? void 0 : f.cancelButton)
    }, g.cancel.label) : null, K.isValidElement(g.action) ? g.action : g.action && af(g.action) ? K.createElement("button", {
        "data-button": !0,
        "data-action": !0,
        style: g.actionButtonStyle || U,
        onClick: Ce => {
            af(g.action) && (g.action.onClick == null || g.action.onClick.call(g.action, Ce),
            !Ce.defaultPrevented && re())
        }
        ,
        className: Rr(O == null ? void 0 : O.actionButton, g == null || (h = g.classNames) == null ? void 0 : h.actionButton)
    }, g.action.label) : null)
}
;
function QS() {
    if (typeof window > "u" || typeof document > "u")
        return "ltr";
    const n = document.documentElement.getAttribute("dir");
    return n === "auto" || !n ? window.getComputedStyle(document.documentElement).direction : n
}
function jI(n, e) {
    const t = {};
    return [n, e].forEach( (r, s) => {
        const o = s === 1
          , u = o ? "--mobile-offset" : "--offset"
          , d = o ? zI : II;
        function f(h) {
            ["top", "right", "bottom", "left"].forEach(m => {
                t[`${u}-${m}`] = typeof h == "number" ? `${h}px` : h
            }
            )
        }
        typeof r == "number" || typeof r == "string" ? f(r) : typeof r == "object" ? ["top", "right", "bottom", "left"].forEach(h => {
            r[h] === void 0 ? t[`${u}-${h}`] = d : t[`${u}-${h}`] = typeof r[h] == "number" ? `${r[h]}px` : r[h]
        }
        ) : f(d)
    }
    ),
    t
}
const WI = K.forwardRef(function(e, t) {
    const {invert: r, position: s="bottom-right", hotkey: o=["altKey", "KeyT"], expand: u, closeButton: d, className: f, offset: h, mobileOffset: m, theme: g="light", richColors: _, duration: x, style: E, visibleToasts: M=PI, toastOptions: b, dir: y=QS(), gap: T=FI, icons: D, containerAriaLabel: C="Notifications"} = e
      , [P,A] = K.useState([])
      , F = K.useMemo( () => Array.from(new Set([s].concat(P.filter(ee => ee.position).map(ee => ee.position)))), [P, s])
      , [z,U] = K.useState([])
      , [R,V] = K.useState(!1)
      , [Q,X] = K.useState(!1)
      , [oe,le] = K.useState(g !== "system" ? g : typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light")
      , O = K.useRef(null)
      , W = o.join("+").replace(/Key/g, "").replace(/Digit/g, "")
      , H = K.useRef(null)
      , Me = K.useRef(!1)
      , k = K.useCallback(ee => {
        A(ge => {
            var pe;
            return (pe = ge.find(te => te.id === ee.id)) != null && pe.delete || Li.dismiss(ee.id),
            ge.filter( ({id: te}) => te !== ee.id)
        }
        )
    }
    , []);
    return K.useEffect( () => Li.subscribe(ee => {
        if (ee.dismiss) {
            requestAnimationFrame( () => {
                A(ge => ge.map(pe => pe.id === ee.id ? {
                    ...pe,
                    delete: !0
                } : pe))
            }
            );
            return
        }
        setTimeout( () => {
            CC.flushSync( () => {
                A(ge => {
                    const pe = ge.findIndex(te => te.id === ee.id);
                    return pe !== -1 ? [...ge.slice(0, pe), {
                        ...ge[pe],
                        ...ee
                    }, ...ge.slice(pe + 1)] : [ee, ...ge]
                }
                )
            }
            )
        }
        )
    }
    ), [P]),
    K.useEffect( () => {
        if (g !== "system") {
            le(g);
            return
        }
        if (g === "system" && (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? le("dark") : le("light")),
        typeof window > "u")
            return;
        const ee = window.matchMedia("(prefers-color-scheme: dark)");
        try {
            ee.addEventListener("change", ({matches: ge}) => {
                le(ge ? "dark" : "light")
            }
            )
        } catch {
            ee.addListener( ({matches: pe}) => {
                try {
                    le(pe ? "dark" : "light")
                } catch (te) {
                    console.error(te)
                }
            }
            )
        }
    }
    , [g]),
    K.useEffect( () => {
        P.length <= 1 && V(!1)
    }
    , [P]),
    K.useEffect( () => {
        const ee = ge => {
            var pe;
            if (o.every(Se => ge[Se] || ge.code === Se)) {
                var we;
                V(!0),
                (we = O.current) == null || we.focus()
            }
            ge.code === "Escape" && (document.activeElement === O.current || (pe = O.current) != null && pe.contains(document.activeElement)) && V(!1)
        }
        ;
        return document.addEventListener("keydown", ee),
        () => document.removeEventListener("keydown", ee)
    }
    , [o]),
    K.useEffect( () => {
        if (O.current)
            return () => {
                H.current && (H.current.focus({
                    preventScroll: !0
                }),
                H.current = null,
                Me.current = !1)
            }
    }
    , [O.current]),
    K.createElement("section", {
        ref: t,
        "aria-label": `${C} ${W}`,
        tabIndex: -1,
        "aria-live": "polite",
        "aria-relevant": "additions text",
        "aria-atomic": "false",
        suppressHydrationWarning: !0
    }, F.map( (ee, ge) => {
        var pe;
        const [te,we] = ee.split("-");
        return P.length ? K.createElement("ol", {
            key: ee,
            dir: y === "auto" ? QS() : y,
            tabIndex: -1,
            ref: O,
            className: f,
            "data-sonner-toaster": !0,
            "data-sonner-theme": oe,
            "data-y-position": te,
            "data-lifted": R && P.length > 1 && !u,
            "data-x-position": we,
            style: {
                "--front-toast-height": `${((pe = z[0]) == null ? void 0 : pe.height) || 0}px`,
                "--width": `${kI}px`,
                "--gap": `${T}px`,
                ...E,
                ...jI(h, m)
            },
            onBlur: Se => {
                Me.current && !Se.currentTarget.contains(Se.relatedTarget) && (Me.current = !1,
                H.current && (H.current.focus({
                    preventScroll: !0
                }),
                H.current = null))
            }
            ,
            onFocus: Se => {
                Se.target instanceof HTMLElement && Se.target.dataset.dismissible === "false" || Me.current || (Me.current = !0,
                H.current = Se.relatedTarget)
            }
            ,
            onMouseEnter: () => V(!0),
            onMouseMove: () => V(!0),
            onMouseLeave: () => {
                Q || V(!1)
            }
            ,
            onDragEnd: () => V(!1),
            onPointerDown: Se => {
                Se.target instanceof HTMLElement && Se.target.dataset.dismissible === "false" || X(!0)
            }
            ,
            onPointerUp: () => X(!1)
        }, P.filter(Se => !Se.position && ge === 0 || Se.position === ee).map( (Se, De) => {
            var Ve, _t;
            return K.createElement(GI, {
                key: Se.id,
                icons: D,
                index: De,
                toast: Se,
                defaultRichColors: _,
                duration: (Ve = b == null ? void 0 : b.duration) != null ? Ve : x,
                className: b == null ? void 0 : b.className,
                descriptionClassName: b == null ? void 0 : b.descriptionClassName,
                invert: r,
                visibleToasts: M,
                closeButton: (_t = b == null ? void 0 : b.closeButton) != null ? _t : d,
                interacting: Q,
                position: ee,
                style: b == null ? void 0 : b.style,
                unstyled: b == null ? void 0 : b.unstyled,
                classNames: b == null ? void 0 : b.classNames,
                cancelButtonStyle: b == null ? void 0 : b.cancelButtonStyle,
                actionButtonStyle: b == null ? void 0 : b.actionButtonStyle,
                closeButtonAriaLabel: b == null ? void 0 : b.closeButtonAriaLabel,
                removeToast: k,
                toasts: P.filter(He => He.position == Se.position),
                heights: z.filter(He => He.position == Se.position),
                setHeights: U,
                expandByDefault: u,
                gap: T,
                expanded: R,
                swipeDirections: e.swipeDirections
            })
        }
        )) : null
    }
    ))
})
  , XI = () => Z.jsxs(Z.Fragment, {
    children: [Z.jsx(_I, {}), Z.jsx(iU, {}), Z.jsx("div", {
        className: "absolute top-4 right-4 z-50",
        children: Z.jsx(HC, {})
    }), Z.jsx(xD, {}), Z.jsx(WI, {
        richColors: !0
    })]
})
  , to = ({children: n, className: e="", ...t}) => Z.jsx("button", {
    className: `
        bg-black
        text-2xl
        text-white
        inline-block
        transition-all
        duration-200
        relative
        top-0
        cursor-pointer
        mx-5
        border
        border-white
        active:top-[3px]
        ${e}
      `,
    ...t,
    children: n
})
  , qI = () => Z.jsxs(Z.Fragment, {
    children: [Z.jsx("div", {
        className: "absolute inset-0 opacity-30 pointer-events-none z-10 overflow-hidden",
        children: Z.jsx("div", {
            className: "w-full h-full bg-gradient-to-r from-purple-800/20 via-transparent to-blue-800/20 animate-nebula"
        })
    }), Z.jsx("div", {
        className: "fixed inset-0 flex items-center justify-center z-10",
        children: Z.jsxs("div", {
            className: "flex flex-col items-center text-center px-4 sm:px-6 md:px-8",
            children: [Z.jsx("h1", {
                className: "text-4xl sm:text-5xl md:text-6xl lg:text-7xl xl:text-8xl font-extrabold text-white mb-6 sm:mb-8 animate-glow drop-shadow-lg",
                children: "WELCOME TO XUNBAO"
            }), Z.jsxs("div", {
                className: "flex flex-col gap-5",
                children: [Z.jsx(Wc, {
                    to: "/register",
                    className: "flex justify-center",
                    children: Z.jsx(to, {
                        className: "w-full max-w-xs px-6 py-3 sm:px-8 sm:py-4 text-lg sm:text-xl font-semibold transition-colors duration-300 border rounded-sm shadow-[3px_4px_0_white] active:shadow-[1px_2px_0_white]",
                        children: "REGISTER"
                    })
                }), Z.jsx(Wc, {
                    to: "/quiz",
                    className: "flex justify-center",
                    children: Z.jsx(to, {
                        className: "w-full max-w-xs px-6 py-3 sm:px-8 sm:py-4 text-lg sm:text-xl font-semibold transition-colors duration-300 border rounded-sm shadow-[3px_4px_0_white] active:shadow-[1px_2px_0_white]",
                        children: "Play"
                    })
                }), Z.jsx(Wc, {
                    to: "/leaderboard",
                    className: "flex justify-center",
                    children: Z.jsx(to, {
                        className: "w-full max-w-xs px-6 py-3 sm:px-8 sm:py-4 text-lg sm:text-xl font-semibold transition-colors duration-300 border rounded-sm shadow-[3px_4px_0_white] active:shadow-[1px_2px_0_white]",
                        children: "Leaderboards"
                    })
                })]
            })]
        })
    }), Z.jsx("div", {
        className: "absolute bottom-0 left-1/2 transform -translate-x-1/2 text-white my-5 text-center",
        children: "Made by Manan"
    })]
});
function JS(n, e) {
    if (typeof n == "function")
        return n(e);
    n != null && (n.current = e)
}
function YI(...n) {
    return e => {
        let t = !1;
        const r = n.map(s => {
            const o = JS(s, e);
            return !t && typeof o == "function" && (t = !0),
            o
        }
        );
        if (t)
            return () => {
                for (let s = 0; s < r.length; s++) {
                    const o = r[s];
                    typeof o == "function" ? o() : JS(n[s], null)
                }
            }
    }
}
function mw(n) {
    const e = ZI(n)
      , t = $.forwardRef( (r, s) => {
        const {children: o, ...u} = r
          , d = $.Children.toArray(o)
          , f = d.find(KI);
        if (f) {
            const h = f.props.children
              , m = d.map(g => g === f ? $.Children.count(h) > 1 ? $.Children.only(null) : $.isValidElement(h) ? h.props.children : null : g);
            return Z.jsx(e, {
                ...u,
                ref: s,
                children: $.isValidElement(h) ? $.cloneElement(h, void 0, m) : null
            })
        }
        return Z.jsx(e, {
            ...u,
            ref: s,
            children: o
        })
    }
    );
    return t.displayName = `${n}.Slot`,
    t
}
var gw = mw("Slot");
function ZI(n) {
    const e = $.forwardRef( (t, r) => {
        const {children: s, ...o} = t;
        if ($.isValidElement(s)) {
            const u = JI(s)
              , d = QI(o, s.props);
            return s.type !== $.Fragment && (d.ref = r ? YI(r, u) : u),
            $.cloneElement(s, d)
        }
        return $.Children.count(s) > 1 ? $.Children.only(null) : null
    }
    );
    return e.displayName = `${n}.SlotClone`,
    e
}
var $I = Symbol("radix.slottable");
function KI(n) {
    return $.isValidElement(n) && typeof n.type == "function" && "__radixId"in n.type && n.type.__radixId === $I
}
function QI(n, e) {
    const t = {
        ...e
    };
    for (const r in e) {
        const s = n[r]
          , o = e[r];
        /^on[A-Z]/.test(r) ? s && o ? t[r] = (...d) => {
            o(...d),
            s(...d)
        }
        : s && (t[r] = s) : r === "style" ? t[r] = {
            ...s,
            ...o
        } : r === "className" && (t[r] = [s, o].filter(Boolean).join(" "))
    }
    return {
        ...n,
        ...t
    }
}
function JI(n) {
    var r, s;
    let e = (r = Object.getOwnPropertyDescriptor(n.props, "ref")) == null ? void 0 : r.get
      , t = e && "isReactWarning"in e && e.isReactWarning;
    return t ? n.ref : (e = (s = Object.getOwnPropertyDescriptor(n, "ref")) == null ? void 0 : s.get,
    t = e && "isReactWarning"in e && e.isReactWarning,
    t ? n.props.ref : n.props.ref || n.ref)
}
function vw(n) {
    var e, t, r = "";
    if (typeof n == "string" || typeof n == "number")
        r += n;
    else if (typeof n == "object")
        if (Array.isArray(n)) {
            var s = n.length;
            for (e = 0; e < s; e++)
                n[e] && (t = vw(n[e])) && (r && (r += " "),
                r += t)
        } else
            for (t in n)
                n[t] && (r && (r += " "),
                r += t);
    return r
}
function _w() {
    for (var n, e, t = 0, r = "", s = arguments.length; t < s; t++)
        (n = arguments[t]) && (e = vw(n)) && (r && (r += " "),
        r += e);
    return r
}
const eE = n => typeof n == "boolean" ? `${n}` : n === 0 ? "0" : n
  , tE = _w
  , ez = (n, e) => t => {
    var r;
    if ((e == null ? void 0 : e.variants) == null)
        return tE(n, t == null ? void 0 : t.class, t == null ? void 0 : t.className);
    const {variants: s, defaultVariants: o} = e
      , u = Object.keys(s).map(h => {
        const m = t == null ? void 0 : t[h]
          , g = o == null ? void 0 : o[h];
        if (m === null)
            return null;
        const _ = eE(m) || eE(g);
        return s[h][_]
    }
    )
      , d = t && Object.entries(t).reduce( (h, m) => {
        let[g,_] = m;
        return _ === void 0 || (h[g] = _),
        h
    }
    , {})
      , f = e == null || (r = e.compoundVariants) === null || r === void 0 ? void 0 : r.reduce( (h, m) => {
        let {class: g, className: _, ...x} = m;
        return Object.entries(x).every(E => {
            let[M,b] = E;
            return Array.isArray(b) ? b.includes({
                ...o,
                ...d
            }[M]) : {
                ...o,
                ...d
            }[M] === b
        }
        ) ? [...h, g, _] : h
    }
    , []);
    return tE(n, u, f, t == null ? void 0 : t.class, t == null ? void 0 : t.className)
}
  , p_ = "-"
  , tz = n => {
    const e = iz(n)
      , {conflictingClassGroups: t, conflictingClassGroupModifiers: r} = n;
    return {
        getClassGroupId: u => {
            const d = u.split(p_);
            return d[0] === "" && d.length !== 1 && d.shift(),
            yw(d, e) || nz(u)
        }
        ,
        getConflictingClassGroupIds: (u, d) => {
            const f = t[u] || [];
            return d && r[u] ? [...f, ...r[u]] : f
        }
    }
}
  , yw = (n, e) => {
    var u;
    if (n.length === 0)
        return e.classGroupId;
    const t = n[0]
      , r = e.nextPart.get(t)
      , s = r ? yw(n.slice(1), r) : void 0;
    if (s)
        return s;
    if (e.validators.length === 0)
        return;
    const o = n.join(p_);
    return (u = e.validators.find( ({validator: d}) => d(o))) == null ? void 0 : u.classGroupId
}
  , nE = /^\[(.+)\]$/
  , nz = n => {
    if (nE.test(n)) {
        const e = nE.exec(n)[1]
          , t = e == null ? void 0 : e.substring(0, e.indexOf(":"));
        if (t)
            return "arbitrary.." + t
    }
}
  , iz = n => {
    const {theme: e, classGroups: t} = n
      , r = {
        nextPart: new Map,
        validators: []
    };
    for (const s in t)
        Av(t[s], r, s, e);
    return r
}
  , Av = (n, e, t, r) => {
    n.forEach(s => {
        if (typeof s == "string") {
            const o = s === "" ? e : iE(e, s);
            o.classGroupId = t;
            return
        }
        if (typeof s == "function") {
            if (rz(s)) {
                Av(s(r), e, t, r);
                return
            }
            e.validators.push({
                validator: s,
                classGroupId: t
            });
            return
        }
        Object.entries(s).forEach( ([o,u]) => {
            Av(u, iE(e, o), t, r)
        }
        )
    }
    )
}
  , iE = (n, e) => {
    let t = n;
    return e.split(p_).forEach(r => {
        t.nextPart.has(r) || t.nextPart.set(r, {
            nextPart: new Map,
            validators: []
        }),
        t = t.nextPart.get(r)
    }
    ),
    t
}
  , rz = n => n.isThemeGetter
  , az = n => {
    if (n < 1)
        return {
            get: () => {}
            ,
            set: () => {}
        };
    let e = 0
      , t = new Map
      , r = new Map;
    const s = (o, u) => {
        t.set(o, u),
        e++,
        e > n && (e = 0,
        r = t,
        t = new Map)
    }
    ;
    return {
        get(o) {
            let u = t.get(o);
            if (u !== void 0)
                return u;
            if ((u = r.get(o)) !== void 0)
                return s(o, u),
                u
        },
        set(o, u) {
            t.has(o) ? t.set(o, u) : s(o, u)
        }
    }
}
  , Rv = "!"
  , Cv = ":"
  , sz = Cv.length
  , oz = n => {
    const {prefix: e, experimentalParseClassName: t} = n;
    let r = s => {
        const o = [];
        let u = 0, d = 0, f = 0, h;
        for (let E = 0; E < s.length; E++) {
            let M = s[E];
            if (u === 0 && d === 0) {
                if (M === Cv) {
                    o.push(s.slice(f, E)),
                    f = E + sz;
                    continue
                }
                if (M === "/") {
                    h = E;
                    continue
                }
            }
            M === "[" ? u++ : M === "]" ? u-- : M === "(" ? d++ : M === ")" && d--
        }
        const m = o.length === 0 ? s : s.substring(f)
          , g = lz(m)
          , _ = g !== m
          , x = h && h > f ? h - f : void 0;
        return {
            modifiers: o,
            hasImportantModifier: _,
            baseClassName: g,
            maybePostfixModifierPosition: x
        }
    }
    ;
    if (e) {
        const s = e + Cv
          , o = r;
        r = u => u.startsWith(s) ? o(u.substring(s.length)) : {
            isExternal: !0,
            modifiers: [],
            hasImportantModifier: !1,
            baseClassName: u,
            maybePostfixModifierPosition: void 0
        }
    }
    if (t) {
        const s = r;
        r = o => t({
            className: o,
            parseClassName: s
        })
    }
    return r
}
  , lz = n => n.endsWith(Rv) ? n.substring(0, n.length - 1) : n.startsWith(Rv) ? n.substring(1) : n
  , cz = n => {
    const e = Object.fromEntries(n.orderSensitiveModifiers.map(r => [r, !0]));
    return r => {
        if (r.length <= 1)
            return r;
        const s = [];
        let o = [];
        return r.forEach(u => {
            u[0] === "[" || e[u] ? (s.push(...o.sort(), u),
            o = []) : o.push(u)
        }
        ),
        s.push(...o.sort()),
        s
    }
}
  , uz = n => ({
    cache: az(n.cacheSize),
    parseClassName: oz(n),
    sortModifiers: cz(n),
    ...tz(n)
})
  , dz = /\s+/
  , fz = (n, e) => {
    const {parseClassName: t, getClassGroupId: r, getConflictingClassGroupIds: s, sortModifiers: o} = e
      , u = []
      , d = n.trim().split(dz);
    let f = "";
    for (let h = d.length - 1; h >= 0; h -= 1) {
        const m = d[h]
          , {isExternal: g, modifiers: _, hasImportantModifier: x, baseClassName: E, maybePostfixModifierPosition: M} = t(m);
        if (g) {
            f = m + (f.length > 0 ? " " + f : f);
            continue
        }
        let b = !!M
          , y = r(b ? E.substring(0, M) : E);
        if (!y) {
            if (!b) {
                f = m + (f.length > 0 ? " " + f : f);
                continue
            }
            if (y = r(E),
            !y) {
                f = m + (f.length > 0 ? " " + f : f);
                continue
            }
            b = !1
        }
        const T = o(_).join(":")
          , D = x ? T + Rv : T
          , C = D + y;
        if (u.includes(C))
            continue;
        u.push(C);
        const P = s(y, b);
        for (let A = 0; A < P.length; ++A) {
            const F = P[A];
            u.push(D + F)
        }
        f = m + (f.length > 0 ? " " + f : f)
    }
    return f
}
;
function hz() {
    let n = 0, e, t, r = "";
    for (; n < arguments.length; )
        (e = arguments[n++]) && (t = xw(e)) && (r && (r += " "),
        r += t);
    return r
}
const xw = n => {
    if (typeof n == "string")
        return n;
    let e, t = "";
    for (let r = 0; r < n.length; r++)
        n[r] && (e = xw(n[r])) && (t && (t += " "),
        t += e);
    return t
}
;
function pz(n, ...e) {
    let t, r, s, o = u;
    function u(f) {
        const h = e.reduce( (m, g) => g(m), n());
        return t = uz(h),
        r = t.cache.get,
        s = t.cache.set,
        o = d,
        d(f)
    }
    function d(f) {
        const h = r(f);
        if (h)
            return h;
        const m = fz(f, t);
        return s(f, m),
        m
    }
    return function() {
        return o(hz.apply(null, arguments))
    }
}
const $n = n => {
    const e = t => t[n] || [];
    return e.isThemeGetter = !0,
    e
}
  , bw = /^\[(?:(\w[\w-]*):)?(.+)\]$/i
  , Sw = /^\((?:(\w[\w-]*):)?(.+)\)$/i
  , mz = /^\d+\/\d+$/
  , gz = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/
  , vz = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/
  , _z = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/
  , yz = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/
  , xz = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/
  , tl = n => mz.test(n)
  , Xt = n => !!n && !Number.isNaN(Number(n))
  , as = n => !!n && Number.isInteger(Number(n))
  , pg = n => n.endsWith("%") && Xt(n.slice(0, -1))
  , la = n => gz.test(n)
  , bz = () => !0
  , Sz = n => vz.test(n) && !_z.test(n)
  , Ew = () => !1
  , Ez = n => yz.test(n)
  , Mz = n => xz.test(n)
  , wz = n => !ut(n) && !dt(n)
  , Tz = n => Al(n, Tw, Ew)
  , ut = n => bw.test(n)
  , js = n => Al(n, Aw, Sz)
  , mg = n => Al(n, Uz, Xt)
  , rE = n => Al(n, Mw, Ew)
  , Az = n => Al(n, ww, Mz)
  , sf = n => Al(n, Rw, Ez)
  , dt = n => Sw.test(n)
  , Nc = n => Rl(n, Aw)
  , Rz = n => Rl(n, Lz)
  , aE = n => Rl(n, Mw)
  , Cz = n => Rl(n, Tw)
  , Dz = n => Rl(n, ww)
  , of = n => Rl(n, Rw, !0)
  , Al = (n, e, t) => {
    const r = bw.exec(n);
    return r ? r[1] ? e(r[1]) : t(r[2]) : !1
}
  , Rl = (n, e, t=!1) => {
    const r = Sw.exec(n);
    return r ? r[1] ? e(r[1]) : t : !1
}
  , Mw = n => n === "position" || n === "percentage"
  , ww = n => n === "image" || n === "url"
  , Tw = n => n === "length" || n === "size" || n === "bg-size"
  , Aw = n => n === "length"
  , Uz = n => n === "number"
  , Lz = n => n === "family-name"
  , Rw = n => n === "shadow"
  , Nz = () => {
    const n = $n("color")
      , e = $n("font")
      , t = $n("text")
      , r = $n("font-weight")
      , s = $n("tracking")
      , o = $n("leading")
      , u = $n("breakpoint")
      , d = $n("container")
      , f = $n("spacing")
      , h = $n("radius")
      , m = $n("shadow")
      , g = $n("inset-shadow")
      , _ = $n("text-shadow")
      , x = $n("drop-shadow")
      , E = $n("blur")
      , M = $n("perspective")
      , b = $n("aspect")
      , y = $n("ease")
      , T = $n("animate")
      , D = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"]
      , C = () => ["center", "top", "bottom", "left", "right", "top-left", "left-top", "top-right", "right-top", "bottom-right", "right-bottom", "bottom-left", "left-bottom"]
      , P = () => [...C(), dt, ut]
      , A = () => ["auto", "hidden", "clip", "visible", "scroll"]
      , F = () => ["auto", "contain", "none"]
      , z = () => [dt, ut, f]
      , U = () => [tl, "full", "auto", ...z()]
      , R = () => [as, "none", "subgrid", dt, ut]
      , V = () => ["auto", {
        span: ["full", as, dt, ut]
    }, as, dt, ut]
      , Q = () => [as, "auto", dt, ut]
      , X = () => ["auto", "min", "max", "fr", dt, ut]
      , oe = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"]
      , le = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"]
      , O = () => ["auto", ...z()]
      , W = () => [tl, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...z()]
      , H = () => [n, dt, ut]
      , Me = () => [...C(), aE, rE, {
        position: [dt, ut]
    }]
      , k = () => ["no-repeat", {
        repeat: ["", "x", "y", "space", "round"]
    }]
      , ee = () => ["auto", "cover", "contain", Cz, Tz, {
        size: [dt, ut]
    }]
      , ge = () => [pg, Nc, js]
      , pe = () => ["", "none", "full", h, dt, ut]
      , te = () => ["", Xt, Nc, js]
      , we = () => ["solid", "dashed", "dotted", "double"]
      , Se = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"]
      , De = () => [Xt, pg, aE, rE]
      , Ve = () => ["", "none", E, dt, ut]
      , _t = () => ["none", Xt, dt, ut]
      , He = () => ["none", Xt, dt, ut]
      , Pt = () => [Xt, dt, ut]
      , kt = () => [tl, "full", ...z()];
    return {
        cacheSize: 500,
        theme: {
            animate: ["spin", "ping", "pulse", "bounce"],
            aspect: ["video"],
            blur: [la],
            breakpoint: [la],
            color: [bz],
            container: [la],
            "drop-shadow": [la],
            ease: ["in", "out", "in-out"],
            font: [wz],
            "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
            "inset-shadow": [la],
            leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
            perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
            radius: [la],
            shadow: [la],
            spacing: ["px", Xt],
            text: [la],
            "text-shadow": [la],
            tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
        },
        classGroups: {
            aspect: [{
                aspect: ["auto", "square", tl, ut, dt, b]
            }],
            container: ["container"],
            columns: [{
                columns: [Xt, ut, dt, d]
            }],
            "break-after": [{
                "break-after": D()
            }],
            "break-before": [{
                "break-before": D()
            }],
            "break-inside": [{
                "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
            }],
            "box-decoration": [{
                "box-decoration": ["slice", "clone"]
            }],
            box: [{
                box: ["border", "content"]
            }],
            display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
            sr: ["sr-only", "not-sr-only"],
            float: [{
                float: ["right", "left", "none", "start", "end"]
            }],
            clear: [{
                clear: ["left", "right", "both", "none", "start", "end"]
            }],
            isolation: ["isolate", "isolation-auto"],
            "object-fit": [{
                object: ["contain", "cover", "fill", "none", "scale-down"]
            }],
            "object-position": [{
                object: P()
            }],
            overflow: [{
                overflow: A()
            }],
            "overflow-x": [{
                "overflow-x": A()
            }],
            "overflow-y": [{
                "overflow-y": A()
            }],
            overscroll: [{
                overscroll: F()
            }],
            "overscroll-x": [{
                "overscroll-x": F()
            }],
            "overscroll-y": [{
                "overscroll-y": F()
            }],
            position: ["static", "fixed", "absolute", "relative", "sticky"],
            inset: [{
                inset: U()
            }],
            "inset-x": [{
                "inset-x": U()
            }],
            "inset-y": [{
                "inset-y": U()
            }],
            start: [{
                start: U()
            }],
            end: [{
                end: U()
            }],
            top: [{
                top: U()
            }],
            right: [{
                right: U()
            }],
            bottom: [{
                bottom: U()
            }],
            left: [{
                left: U()
            }],
            visibility: ["visible", "invisible", "collapse"],
            z: [{
                z: [as, "auto", dt, ut]
            }],
            basis: [{
                basis: [tl, "full", "auto", d, ...z()]
            }],
            "flex-direction": [{
                flex: ["row", "row-reverse", "col", "col-reverse"]
            }],
            "flex-wrap": [{
                flex: ["nowrap", "wrap", "wrap-reverse"]
            }],
            flex: [{
                flex: [Xt, tl, "auto", "initial", "none", ut]
            }],
            grow: [{
                grow: ["", Xt, dt, ut]
            }],
            shrink: [{
                shrink: ["", Xt, dt, ut]
            }],
            order: [{
                order: [as, "first", "last", "none", dt, ut]
            }],
            "grid-cols": [{
                "grid-cols": R()
            }],
            "col-start-end": [{
                col: V()
            }],
            "col-start": [{
                "col-start": Q()
            }],
            "col-end": [{
                "col-end": Q()
            }],
            "grid-rows": [{
                "grid-rows": R()
            }],
            "row-start-end": [{
                row: V()
            }],
            "row-start": [{
                "row-start": Q()
            }],
            "row-end": [{
                "row-end": Q()
            }],
            "grid-flow": [{
                "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
            }],
            "auto-cols": [{
                "auto-cols": X()
            }],
            "auto-rows": [{
                "auto-rows": X()
            }],
            gap: [{
                gap: z()
            }],
            "gap-x": [{
                "gap-x": z()
            }],
            "gap-y": [{
                "gap-y": z()
            }],
            "justify-content": [{
                justify: [...oe(), "normal"]
            }],
            "justify-items": [{
                "justify-items": [...le(), "normal"]
            }],
            "justify-self": [{
                "justify-self": ["auto", ...le()]
            }],
            "align-content": [{
                content: ["normal", ...oe()]
            }],
            "align-items": [{
                items: [...le(), {
                    baseline: ["", "last"]
                }]
            }],
            "align-self": [{
                self: ["auto", ...le(), {
                    baseline: ["", "last"]
                }]
            }],
            "place-content": [{
                "place-content": oe()
            }],
            "place-items": [{
                "place-items": [...le(), "baseline"]
            }],
            "place-self": [{
                "place-self": ["auto", ...le()]
            }],
            p: [{
                p: z()
            }],
            px: [{
                px: z()
            }],
            py: [{
                py: z()
            }],
            ps: [{
                ps: z()
            }],
            pe: [{
                pe: z()
            }],
            pt: [{
                pt: z()
            }],
            pr: [{
                pr: z()
            }],
            pb: [{
                pb: z()
            }],
            pl: [{
                pl: z()
            }],
            m: [{
                m: O()
            }],
            mx: [{
                mx: O()
            }],
            my: [{
                my: O()
            }],
            ms: [{
                ms: O()
            }],
            me: [{
                me: O()
            }],
            mt: [{
                mt: O()
            }],
            mr: [{
                mr: O()
            }],
            mb: [{
                mb: O()
            }],
            ml: [{
                ml: O()
            }],
            "space-x": [{
                "space-x": z()
            }],
            "space-x-reverse": ["space-x-reverse"],
            "space-y": [{
                "space-y": z()
            }],
            "space-y-reverse": ["space-y-reverse"],
            size: [{
                size: W()
            }],
            w: [{
                w: [d, "screen", ...W()]
            }],
            "min-w": [{
                "min-w": [d, "screen", "none", ...W()]
            }],
            "max-w": [{
                "max-w": [d, "screen", "none", "prose", {
                    screen: [u]
                }, ...W()]
            }],
            h: [{
                h: ["screen", ...W()]
            }],
            "min-h": [{
                "min-h": ["screen", "none", ...W()]
            }],
            "max-h": [{
                "max-h": ["screen", ...W()]
            }],
            "font-size": [{
                text: ["base", t, Nc, js]
            }],
            "font-smoothing": ["antialiased", "subpixel-antialiased"],
            "font-style": ["italic", "not-italic"],
            "font-weight": [{
                font: [r, dt, mg]
            }],
            "font-stretch": [{
                "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", pg, ut]
            }],
            "font-family": [{
                font: [Rz, ut, e]
            }],
            "fvn-normal": ["normal-nums"],
            "fvn-ordinal": ["ordinal"],
            "fvn-slashed-zero": ["slashed-zero"],
            "fvn-figure": ["lining-nums", "oldstyle-nums"],
            "fvn-spacing": ["proportional-nums", "tabular-nums"],
            "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
            tracking: [{
                tracking: [s, dt, ut]
            }],
            "line-clamp": [{
                "line-clamp": [Xt, "none", dt, mg]
            }],
            leading: [{
                leading: [o, ...z()]
            }],
            "list-image": [{
                "list-image": ["none", dt, ut]
            }],
            "list-style-position": [{
                list: ["inside", "outside"]
            }],
            "list-style-type": [{
                list: ["disc", "decimal", "none", dt, ut]
            }],
            "text-alignment": [{
                text: ["left", "center", "right", "justify", "start", "end"]
            }],
            "placeholder-color": [{
                placeholder: H()
            }],
            "text-color": [{
                text: H()
            }],
            "text-decoration": ["underline", "overline", "line-through", "no-underline"],
            "text-decoration-style": [{
                decoration: [...we(), "wavy"]
            }],
            "text-decoration-thickness": [{
                decoration: [Xt, "from-font", "auto", dt, js]
            }],
            "text-decoration-color": [{
                decoration: H()
            }],
            "underline-offset": [{
                "underline-offset": [Xt, "auto", dt, ut]
            }],
            "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
            "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
            "text-wrap": [{
                text: ["wrap", "nowrap", "balance", "pretty"]
            }],
            indent: [{
                indent: z()
            }],
            "vertical-align": [{
                align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", dt, ut]
            }],
            whitespace: [{
                whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
            }],
            break: [{
                break: ["normal", "words", "all", "keep"]
            }],
            wrap: [{
                wrap: ["break-word", "anywhere", "normal"]
            }],
            hyphens: [{
                hyphens: ["none", "manual", "auto"]
            }],
            content: [{
                content: ["none", dt, ut]
            }],
            "bg-attachment": [{
                bg: ["fixed", "local", "scroll"]
            }],
            "bg-clip": [{
                "bg-clip": ["border", "padding", "content", "text"]
            }],
            "bg-origin": [{
                "bg-origin": ["border", "padding", "content"]
            }],
            "bg-position": [{
                bg: Me()
            }],
            "bg-repeat": [{
                bg: k()
            }],
            "bg-size": [{
                bg: ee()
            }],
            "bg-image": [{
                bg: ["none", {
                    linear: [{
                        to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
                    }, as, dt, ut],
                    radial: ["", dt, ut],
                    conic: [as, dt, ut]
                }, Dz, Az]
            }],
            "bg-color": [{
                bg: H()
            }],
            "gradient-from-pos": [{
                from: ge()
            }],
            "gradient-via-pos": [{
                via: ge()
            }],
            "gradient-to-pos": [{
                to: ge()
            }],
            "gradient-from": [{
                from: H()
            }],
            "gradient-via": [{
                via: H()
            }],
            "gradient-to": [{
                to: H()
            }],
            rounded: [{
                rounded: pe()
            }],
            "rounded-s": [{
                "rounded-s": pe()
            }],
            "rounded-e": [{
                "rounded-e": pe()
            }],
            "rounded-t": [{
                "rounded-t": pe()
            }],
            "rounded-r": [{
                "rounded-r": pe()
            }],
            "rounded-b": [{
                "rounded-b": pe()
            }],
            "rounded-l": [{
                "rounded-l": pe()
            }],
            "rounded-ss": [{
                "rounded-ss": pe()
            }],
            "rounded-se": [{
                "rounded-se": pe()
            }],
            "rounded-ee": [{
                "rounded-ee": pe()
            }],
            "rounded-es": [{
                "rounded-es": pe()
            }],
            "rounded-tl": [{
                "rounded-tl": pe()
            }],
            "rounded-tr": [{
                "rounded-tr": pe()
            }],
            "rounded-br": [{
                "rounded-br": pe()
            }],
            "rounded-bl": [{
                "rounded-bl": pe()
            }],
            "border-w": [{
                border: te()
            }],
            "border-w-x": [{
                "border-x": te()
            }],
            "border-w-y": [{
                "border-y": te()
            }],
            "border-w-s": [{
                "border-s": te()
            }],
            "border-w-e": [{
                "border-e": te()
            }],
            "border-w-t": [{
                "border-t": te()
            }],
            "border-w-r": [{
                "border-r": te()
            }],
            "border-w-b": [{
                "border-b": te()
            }],
            "border-w-l": [{
                "border-l": te()
            }],
            "divide-x": [{
                "divide-x": te()
            }],
            "divide-x-reverse": ["divide-x-reverse"],
            "divide-y": [{
                "divide-y": te()
            }],
            "divide-y-reverse": ["divide-y-reverse"],
            "border-style": [{
                border: [...we(), "hidden", "none"]
            }],
            "divide-style": [{
                divide: [...we(), "hidden", "none"]
            }],
            "border-color": [{
                border: H()
            }],
            "border-color-x": [{
                "border-x": H()
            }],
            "border-color-y": [{
                "border-y": H()
            }],
            "border-color-s": [{
                "border-s": H()
            }],
            "border-color-e": [{
                "border-e": H()
            }],
            "border-color-t": [{
                "border-t": H()
            }],
            "border-color-r": [{
                "border-r": H()
            }],
            "border-color-b": [{
                "border-b": H()
            }],
            "border-color-l": [{
                "border-l": H()
            }],
            "divide-color": [{
                divide: H()
            }],
            "outline-style": [{
                outline: [...we(), "none", "hidden"]
            }],
            "outline-offset": [{
                "outline-offset": [Xt, dt, ut]
            }],
            "outline-w": [{
                outline: ["", Xt, Nc, js]
            }],
            "outline-color": [{
                outline: H()
            }],
            shadow: [{
                shadow: ["", "none", m, of, sf]
            }],
            "shadow-color": [{
                shadow: H()
            }],
            "inset-shadow": [{
                "inset-shadow": ["none", g, of, sf]
            }],
            "inset-shadow-color": [{
                "inset-shadow": H()
            }],
            "ring-w": [{
                ring: te()
            }],
            "ring-w-inset": ["ring-inset"],
            "ring-color": [{
                ring: H()
            }],
            "ring-offset-w": [{
                "ring-offset": [Xt, js]
            }],
            "ring-offset-color": [{
                "ring-offset": H()
            }],
            "inset-ring-w": [{
                "inset-ring": te()
            }],
            "inset-ring-color": [{
                "inset-ring": H()
            }],
            "text-shadow": [{
                "text-shadow": ["none", _, of, sf]
            }],
            "text-shadow-color": [{
                "text-shadow": H()
            }],
            opacity: [{
                opacity: [Xt, dt, ut]
            }],
            "mix-blend": [{
                "mix-blend": [...Se(), "plus-darker", "plus-lighter"]
            }],
            "bg-blend": [{
                "bg-blend": Se()
            }],
            "mask-clip": [{
                "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"]
            }, "mask-no-clip"],
            "mask-composite": [{
                mask: ["add", "subtract", "intersect", "exclude"]
            }],
            "mask-image-linear-pos": [{
                "mask-linear": [Xt]
            }],
            "mask-image-linear-from-pos": [{
                "mask-linear-from": De()
            }],
            "mask-image-linear-to-pos": [{
                "mask-linear-to": De()
            }],
            "mask-image-linear-from-color": [{
                "mask-linear-from": H()
            }],
            "mask-image-linear-to-color": [{
                "mask-linear-to": H()
            }],
            "mask-image-t-from-pos": [{
                "mask-t-from": De()
            }],
            "mask-image-t-to-pos": [{
                "mask-t-to": De()
            }],
            "mask-image-t-from-color": [{
                "mask-t-from": H()
            }],
            "mask-image-t-to-color": [{
                "mask-t-to": H()
            }],
            "mask-image-r-from-pos": [{
                "mask-r-from": De()
            }],
            "mask-image-r-to-pos": [{
                "mask-r-to": De()
            }],
            "mask-image-r-from-color": [{
                "mask-r-from": H()
            }],
            "mask-image-r-to-color": [{
                "mask-r-to": H()
            }],
            "mask-image-b-from-pos": [{
                "mask-b-from": De()
            }],
            "mask-image-b-to-pos": [{
                "mask-b-to": De()
            }],
            "mask-image-b-from-color": [{
                "mask-b-from": H()
            }],
            "mask-image-b-to-color": [{
                "mask-b-to": H()
            }],
            "mask-image-l-from-pos": [{
                "mask-l-from": De()
            }],
            "mask-image-l-to-pos": [{
                "mask-l-to": De()
            }],
            "mask-image-l-from-color": [{
                "mask-l-from": H()
            }],
            "mask-image-l-to-color": [{
                "mask-l-to": H()
            }],
            "mask-image-x-from-pos": [{
                "mask-x-from": De()
            }],
            "mask-image-x-to-pos": [{
                "mask-x-to": De()
            }],
            "mask-image-x-from-color": [{
                "mask-x-from": H()
            }],
            "mask-image-x-to-color": [{
                "mask-x-to": H()
            }],
            "mask-image-y-from-pos": [{
                "mask-y-from": De()
            }],
            "mask-image-y-to-pos": [{
                "mask-y-to": De()
            }],
            "mask-image-y-from-color": [{
                "mask-y-from": H()
            }],
            "mask-image-y-to-color": [{
                "mask-y-to": H()
            }],
            "mask-image-radial": [{
                "mask-radial": [dt, ut]
            }],
            "mask-image-radial-from-pos": [{
                "mask-radial-from": De()
            }],
            "mask-image-radial-to-pos": [{
                "mask-radial-to": De()
            }],
            "mask-image-radial-from-color": [{
                "mask-radial-from": H()
            }],
            "mask-image-radial-to-color": [{
                "mask-radial-to": H()
            }],
            "mask-image-radial-shape": [{
                "mask-radial": ["circle", "ellipse"]
            }],
            "mask-image-radial-size": [{
                "mask-radial": [{
                    closest: ["side", "corner"],
                    farthest: ["side", "corner"]
                }]
            }],
            "mask-image-radial-pos": [{
                "mask-radial-at": C()
            }],
            "mask-image-conic-pos": [{
                "mask-conic": [Xt]
            }],
            "mask-image-conic-from-pos": [{
                "mask-conic-from": De()
            }],
            "mask-image-conic-to-pos": [{
                "mask-conic-to": De()
            }],
            "mask-image-conic-from-color": [{
                "mask-conic-from": H()
            }],
            "mask-image-conic-to-color": [{
                "mask-conic-to": H()
            }],
            "mask-mode": [{
                mask: ["alpha", "luminance", "match"]
            }],
            "mask-origin": [{
                "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"]
            }],
            "mask-position": [{
                mask: Me()
            }],
            "mask-repeat": [{
                mask: k()
            }],
            "mask-size": [{
                mask: ee()
            }],
            "mask-type": [{
                "mask-type": ["alpha", "luminance"]
            }],
            "mask-image": [{
                mask: ["none", dt, ut]
            }],
            filter: [{
                filter: ["", "none", dt, ut]
            }],
            blur: [{
                blur: Ve()
            }],
            brightness: [{
                brightness: [Xt, dt, ut]
            }],
            contrast: [{
                contrast: [Xt, dt, ut]
            }],
            "drop-shadow": [{
                "drop-shadow": ["", "none", x, of, sf]
            }],
            "drop-shadow-color": [{
                "drop-shadow": H()
            }],
            grayscale: [{
                grayscale: ["", Xt, dt, ut]
            }],
            "hue-rotate": [{
                "hue-rotate": [Xt, dt, ut]
            }],
            invert: [{
                invert: ["", Xt, dt, ut]
            }],
            saturate: [{
                saturate: [Xt, dt, ut]
            }],
            sepia: [{
                sepia: ["", Xt, dt, ut]
            }],
            "backdrop-filter": [{
                "backdrop-filter": ["", "none", dt, ut]
            }],
            "backdrop-blur": [{
                "backdrop-blur": Ve()
            }],
            "backdrop-brightness": [{
                "backdrop-brightness": [Xt, dt, ut]
            }],
            "backdrop-contrast": [{
                "backdrop-contrast": [Xt, dt, ut]
            }],
            "backdrop-grayscale": [{
                "backdrop-grayscale": ["", Xt, dt, ut]
            }],
            "backdrop-hue-rotate": [{
                "backdrop-hue-rotate": [Xt, dt, ut]
            }],
            "backdrop-invert": [{
                "backdrop-invert": ["", Xt, dt, ut]
            }],
            "backdrop-opacity": [{
                "backdrop-opacity": [Xt, dt, ut]
            }],
            "backdrop-saturate": [{
                "backdrop-saturate": [Xt, dt, ut]
            }],
            "backdrop-sepia": [{
                "backdrop-sepia": ["", Xt, dt, ut]
            }],
            "border-collapse": [{
                border: ["collapse", "separate"]
            }],
            "border-spacing": [{
                "border-spacing": z()
            }],
            "border-spacing-x": [{
                "border-spacing-x": z()
            }],
            "border-spacing-y": [{
                "border-spacing-y": z()
            }],
            "table-layout": [{
                table: ["auto", "fixed"]
            }],
            caption: [{
                caption: ["top", "bottom"]
            }],
            transition: [{
                transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", dt, ut]
            }],
            "transition-behavior": [{
                transition: ["normal", "discrete"]
            }],
            duration: [{
                duration: [Xt, "initial", dt, ut]
            }],
            ease: [{
                ease: ["linear", "initial", y, dt, ut]
            }],
            delay: [{
                delay: [Xt, dt, ut]
            }],
            animate: [{
                animate: ["none", T, dt, ut]
            }],
            backface: [{
                backface: ["hidden", "visible"]
            }],
            perspective: [{
                perspective: [M, dt, ut]
            }],
            "perspective-origin": [{
                "perspective-origin": P()
            }],
            rotate: [{
                rotate: _t()
            }],
            "rotate-x": [{
                "rotate-x": _t()
            }],
            "rotate-y": [{
                "rotate-y": _t()
            }],
            "rotate-z": [{
                "rotate-z": _t()
            }],
            scale: [{
                scale: He()
            }],
            "scale-x": [{
                "scale-x": He()
            }],
            "scale-y": [{
                "scale-y": He()
            }],
            "scale-z": [{
                "scale-z": He()
            }],
            "scale-3d": ["scale-3d"],
            skew: [{
                skew: Pt()
            }],
            "skew-x": [{
                "skew-x": Pt()
            }],
            "skew-y": [{
                "skew-y": Pt()
            }],
            transform: [{
                transform: [dt, ut, "", "none", "gpu", "cpu"]
            }],
            "transform-origin": [{
                origin: P()
            }],
            "transform-style": [{
                transform: ["3d", "flat"]
            }],
            translate: [{
                translate: kt()
            }],
            "translate-x": [{
                "translate-x": kt()
            }],
            "translate-y": [{
                "translate-y": kt()
            }],
            "translate-z": [{
                "translate-z": kt()
            }],
            "translate-none": ["translate-none"],
            accent: [{
                accent: H()
            }],
            appearance: [{
                appearance: ["none", "auto"]
            }],
            "caret-color": [{
                caret: H()
            }],
            "color-scheme": [{
                scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
            }],
            cursor: [{
                cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", dt, ut]
            }],
            "field-sizing": [{
                "field-sizing": ["fixed", "content"]
            }],
            "pointer-events": [{
                "pointer-events": ["auto", "none"]
            }],
            resize: [{
                resize: ["none", "", "y", "x"]
            }],
            "scroll-behavior": [{
                scroll: ["auto", "smooth"]
            }],
            "scroll-m": [{
                "scroll-m": z()
            }],
            "scroll-mx": [{
                "scroll-mx": z()
            }],
            "scroll-my": [{
                "scroll-my": z()
            }],
            "scroll-ms": [{
                "scroll-ms": z()
            }],
            "scroll-me": [{
                "scroll-me": z()
            }],
            "scroll-mt": [{
                "scroll-mt": z()
            }],
            "scroll-mr": [{
                "scroll-mr": z()
            }],
            "scroll-mb": [{
                "scroll-mb": z()
            }],
            "scroll-ml": [{
                "scroll-ml": z()
            }],
            "scroll-p": [{
                "scroll-p": z()
            }],
            "scroll-px": [{
                "scroll-px": z()
            }],
            "scroll-py": [{
                "scroll-py": z()
            }],
            "scroll-ps": [{
                "scroll-ps": z()
            }],
            "scroll-pe": [{
                "scroll-pe": z()
            }],
            "scroll-pt": [{
                "scroll-pt": z()
            }],
            "scroll-pr": [{
                "scroll-pr": z()
            }],
            "scroll-pb": [{
                "scroll-pb": z()
            }],
            "scroll-pl": [{
                "scroll-pl": z()
            }],
            "snap-align": [{
                snap: ["start", "end", "center", "align-none"]
            }],
            "snap-stop": [{
                snap: ["normal", "always"]
            }],
            "snap-type": [{
                snap: ["none", "x", "y", "both"]
            }],
            "snap-strictness": [{
                snap: ["mandatory", "proximity"]
            }],
            touch: [{
                touch: ["auto", "none", "manipulation"]
            }],
            "touch-x": [{
                "touch-pan": ["x", "left", "right"]
            }],
            "touch-y": [{
                "touch-pan": ["y", "up", "down"]
            }],
            "touch-pz": ["touch-pinch-zoom"],
            select: [{
                select: ["none", "text", "all", "auto"]
            }],
            "will-change": [{
                "will-change": ["auto", "scroll", "contents", "transform", dt, ut]
            }],
            fill: [{
                fill: ["none", ...H()]
            }],
            "stroke-w": [{
                stroke: [Xt, Nc, js, mg]
            }],
            stroke: [{
                stroke: ["none", ...H()]
            }],
            "forced-color-adjust": [{
                "forced-color-adjust": ["auto", "none"]
            }]
        },
        conflictingClassGroups: {
            overflow: ["overflow-x", "overflow-y"],
            overscroll: ["overscroll-x", "overscroll-y"],
            inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
            "inset-x": ["right", "left"],
            "inset-y": ["top", "bottom"],
            flex: ["basis", "grow", "shrink"],
            gap: ["gap-x", "gap-y"],
            p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
            px: ["pr", "pl"],
            py: ["pt", "pb"],
            m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
            mx: ["mr", "ml"],
            my: ["mt", "mb"],
            size: ["w", "h"],
            "font-size": ["leading"],
            "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
            "fvn-ordinal": ["fvn-normal"],
            "fvn-slashed-zero": ["fvn-normal"],
            "fvn-figure": ["fvn-normal"],
            "fvn-spacing": ["fvn-normal"],
            "fvn-fraction": ["fvn-normal"],
            "line-clamp": ["display", "overflow"],
            rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
            "rounded-s": ["rounded-ss", "rounded-es"],
            "rounded-e": ["rounded-se", "rounded-ee"],
            "rounded-t": ["rounded-tl", "rounded-tr"],
            "rounded-r": ["rounded-tr", "rounded-br"],
            "rounded-b": ["rounded-br", "rounded-bl"],
            "rounded-l": ["rounded-tl", "rounded-bl"],
            "border-spacing": ["border-spacing-x", "border-spacing-y"],
            "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
            "border-w-x": ["border-w-r", "border-w-l"],
            "border-w-y": ["border-w-t", "border-w-b"],
            "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
            "border-color-x": ["border-color-r", "border-color-l"],
            "border-color-y": ["border-color-t", "border-color-b"],
            translate: ["translate-x", "translate-y", "translate-none"],
            "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
            "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
            "scroll-mx": ["scroll-mr", "scroll-ml"],
            "scroll-my": ["scroll-mt", "scroll-mb"],
            "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
            "scroll-px": ["scroll-pr", "scroll-pl"],
            "scroll-py": ["scroll-pt", "scroll-pb"],
            touch: ["touch-x", "touch-y", "touch-pz"],
            "touch-x": ["touch"],
            "touch-y": ["touch"],
            "touch-pz": ["touch"]
        },
        conflictingClassGroupModifiers: {
            "font-size": ["leading"]
        },
        orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"]
    }
}
  , Oz = pz(Nz);
function Cl(...n) {
    return Oz(_w(n))
}
const Pz = ez("inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive", {
    variants: {
        variant: {
            default: "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
            destructive: "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
            outline: "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
            secondary: "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
            ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
            link: "text-primary underline-offset-4 hover:underline"
        },
        size: {
            default: "h-9 px-4 py-2 has-[>svg]:px-3",
            sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
            lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
            icon: "size-9"
        }
    },
    defaultVariants: {
        variant: "default",
        size: "default"
    }
});
function Iz({className: n, variant: e, size: t, asChild: r=!1, ...s}) {
    const o = r ? gw : "button";
    return Z.jsx(o, {
        "data-slot": "button",
        className: Cl(Pz({
            variant: e,
            size: t,
            className: n
        })),
        ...s
    })
}
var yu = n => n.type === "checkbox"
  , Js = n => n instanceof Date
  , Ei = n => n == null;
const Cw = n => typeof n == "object";
var Vn = n => !Ei(n) && !Array.isArray(n) && Cw(n) && !Js(n)
  , Dw = n => Vn(n) && n.target ? yu(n.target) ? n.target.checked : n.target.value : n
  , zz = n => n.substring(0, n.search(/\.\d+(\.|$)/)) || n
  , Uw = (n, e) => n.has(zz(e))
  , kz = n => {
    const e = n.constructor && n.constructor.prototype;
    return Vn(e) && e.hasOwnProperty("isPrototypeOf")
}
  , m_ = typeof window < "u" && typeof window.HTMLElement < "u" && typeof document < "u";
function di(n) {
    let e;
    const t = Array.isArray(n)
      , r = typeof FileList < "u" ? n instanceof FileList : !1;
    if (n instanceof Date)
        e = new Date(n);
    else if (n instanceof Set)
        e = new Set(n);
    else if (!(m_ && (n instanceof Blob || r)) && (t || Vn(n)))
        if (e = t ? [] : {},
        !t && !kz(n))
            e = n;
        else
            for (const s in n)
                n.hasOwnProperty(s) && (e[s] = di(n[s]));
    else
        return n;
    return e
}
var sh = n => Array.isArray(n) ? n.filter(Boolean) : []
  , Bn = n => n === void 0
  , Je = (n, e, t) => {
    if (!e || !Vn(n))
        return t;
    const r = sh(e.split(/[,[\].]+?/)).reduce( (s, o) => Ei(s) ? s : s[o], n);
    return Bn(r) || r === n ? Bn(n[e]) ? t : n[e] : r
}
  , qi = n => typeof n == "boolean"
  , g_ = n => /^\w*$/.test(n)
  , Lw = n => sh(n.replace(/["|']|\]/g, "").split(/\.|\[/))
  , mn = (n, e, t) => {
    let r = -1;
    const s = g_(e) ? [e] : Lw(e)
      , o = s.length
      , u = o - 1;
    for (; ++r < o; ) {
        const d = s[r];
        let f = t;
        if (r !== u) {
            const h = n[d];
            f = Vn(h) || Array.isArray(h) ? h : isNaN(+s[r + 1]) ? {} : []
        }
        if (d === "__proto__" || d === "constructor" || d === "prototype")
            return;
        n[d] = f,
        n = n[d]
    }
}
;
const Af = {
    BLUR: "blur",
    FOCUS_OUT: "focusout",
    CHANGE: "change"
}
  , vr = {
    onBlur: "onBlur",
    onChange: "onChange",
    onSubmit: "onSubmit",
    onTouched: "onTouched",
    all: "all"
}
  , ca = {
    max: "max",
    min: "min",
    maxLength: "maxLength",
    minLength: "minLength",
    pattern: "pattern",
    required: "required",
    validate: "validate"
}
  , Nw = K.createContext(null)
  , oh = () => K.useContext(Nw)
  , Fz = n => {
    const {children: e, ...t} = n;
    return K.createElement(Nw.Provider, {
        value: t
    }, e)
}
;
var Ow = (n, e, t, r=!0) => {
    const s = {
        defaultValues: e._defaultValues
    };
    for (const o in n)
        Object.defineProperty(s, o, {
            get: () => {
                const u = o;
                return e._proxyFormState[u] !== vr.all && (e._proxyFormState[u] = !r || vr.all),
                t && (t[u] = !0),
                n[u]
            }
        });
    return s
}
;
function Pw(n) {
    const e = oh()
      , {control: t=e.control, disabled: r, name: s, exact: o} = n || {}
      , [u,d] = K.useState(t._formState)
      , f = K.useRef({
        isDirty: !1,
        isLoading: !1,
        dirtyFields: !1,
        touchedFields: !1,
        validatingFields: !1,
        isValidating: !1,
        isValid: !1,
        errors: !1
    })
      , h = K.useRef(s);
    return h.current = s,
    K.useEffect( () => t._subscribe({
        name: h.current,
        formState: f.current,
        exact: o,
        callback: m => {
            !r && d({
                ...t._formState,
                ...m
            })
        }
    }), [t, r, o]),
    K.useEffect( () => {
        f.current.isValid && t._setValid(!0)
    }
    , [t]),
    K.useMemo( () => Ow(u, t, f.current, !1), [u, t])
}
var Lr = n => typeof n == "string"
  , Iw = (n, e, t, r, s) => Lr(n) ? (r && e.watch.add(n),
Je(t, n, s)) : Array.isArray(n) ? n.map(o => (r && e.watch.add(o),
Je(t, o))) : (r && (e.watchAll = !0),
t);
function Bz(n) {
    const e = oh()
      , {control: t=e.control, name: r, defaultValue: s, disabled: o, exact: u} = n || {}
      , d = K.useRef(r)
      , f = K.useRef(s);
    d.current = r,
    K.useEffect( () => t._subscribe({
        name: d.current,
        formState: {
            values: !0
        },
        exact: u,
        callback: g => !o && m(Iw(d.current, t._names, g.values || t._formValues, !1, f.current))
    }), [t, o, u]);
    const [h,m] = K.useState(t._getWatch(r, s));
    return K.useEffect( () => t._removeUnmounted()),
    h
}
function Vz(n) {
    const e = oh()
      , {name: t, disabled: r, control: s=e.control, shouldUnregister: o} = n
      , u = Uw(s._names.array, t)
      , d = Bz({
        control: s,
        name: t,
        defaultValue: Je(s._formValues, t, Je(s._defaultValues, t, n.defaultValue)),
        exact: !0
    })
      , f = Pw({
        control: s,
        name: t,
        exact: !0
    })
      , h = K.useRef(n)
      , m = K.useRef(s.register(t, {
        ...n.rules,
        value: d,
        ...qi(n.disabled) ? {
            disabled: n.disabled
        } : {}
    }))
      , g = K.useMemo( () => Object.defineProperties({}, {
        invalid: {
            enumerable: !0,
            get: () => !!Je(f.errors, t)
        },
        isDirty: {
            enumerable: !0,
            get: () => !!Je(f.dirtyFields, t)
        },
        isTouched: {
            enumerable: !0,
            get: () => !!Je(f.touchedFields, t)
        },
        isValidating: {
            enumerable: !0,
            get: () => !!Je(f.validatingFields, t)
        },
        error: {
            enumerable: !0,
            get: () => Je(f.errors, t)
        }
    }), [f, t])
      , _ = K.useCallback(b => m.current.onChange({
        target: {
            value: Dw(b),
            name: t
        },
        type: Af.CHANGE
    }), [t])
      , x = K.useCallback( () => m.current.onBlur({
        target: {
            value: Je(s._formValues, t),
            name: t
        },
        type: Af.BLUR
    }), [t, s._formValues])
      , E = K.useCallback(b => {
        const y = Je(s._fields, t);
        y && b && (y._f.ref = {
            focus: () => b.focus(),
            select: () => b.select(),
            setCustomValidity: T => b.setCustomValidity(T),
            reportValidity: () => b.reportValidity()
        })
    }
    , [s._fields, t])
      , M = K.useMemo( () => ({
        name: t,
        value: d,
        ...qi(r) || f.disabled ? {
            disabled: f.disabled || r
        } : {},
        onChange: _,
        onBlur: x,
        ref: E
    }), [t, r, f.disabled, _, x, E, d]);
    return K.useEffect( () => {
        const b = s._options.shouldUnregister || o;
        s.register(t, {
            ...h.current.rules,
            ...qi(h.current.disabled) ? {
                disabled: h.current.disabled
            } : {}
        });
        const y = (T, D) => {
            const C = Je(s._fields, T);
            C && C._f && (C._f.mount = D)
        }
        ;
        if (y(t, !0),
        b) {
            const T = di(Je(s._options.defaultValues, t));
            mn(s._defaultValues, t, T),
            Bn(Je(s._formValues, t)) && mn(s._formValues, t, T)
        }
        return !u && s.register(t),
        () => {
            (u ? b && !s._state.action : b) ? s.unregister(t) : y(t, !1)
        }
    }
    , [t, s, u, o]),
    K.useEffect( () => {
        s._setDisabledField({
            disabled: r,
            name: t
        })
    }
    , [r, t, s]),
    K.useMemo( () => ({
        field: M,
        formState: f,
        fieldState: g
    }), [M, f, g])
}
const Hz = n => n.render(Vz(n));
var zw = (n, e, t, r, s) => e ? {
    ...t[n],
    types: {
        ...t[n] && t[n].types ? t[n].types : {},
        [r]: s || !0
    }
} : {}
  , Xc = n => Array.isArray(n) ? n : [n]
  , sE = () => {
    let n = [];
    return {
        get observers() {
            return n
        },
        next: s => {
            for (const o of n)
                o.next && o.next(s)
        }
        ,
        subscribe: s => (n.push(s),
        {
            unsubscribe: () => {
                n = n.filter(o => o !== s)
            }
        }),
        unsubscribe: () => {
            n = []
        }
    }
}
  , Dv = n => Ei(n) || !Cw(n);
function hs(n, e) {
    if (Dv(n) || Dv(e))
        return n === e;
    if (Js(n) && Js(e))
        return n.getTime() === e.getTime();
    const t = Object.keys(n)
      , r = Object.keys(e);
    if (t.length !== r.length)
        return !1;
    for (const s of t) {
        const o = n[s];
        if (!r.includes(s))
            return !1;
        if (s !== "ref") {
            const u = e[s];
            if (Js(o) && Js(u) || Vn(o) && Vn(u) || Array.isArray(o) && Array.isArray(u) ? !hs(o, u) : o !== u)
                return !1
        }
    }
    return !0
}
var bi = n => Vn(n) && !Object.keys(n).length
  , v_ = n => n.type === "file"
  , _r = n => typeof n == "function"
  , Rf = n => {
    if (!m_)
        return !1;
    const e = n ? n.ownerDocument : 0;
    return n instanceof (e && e.defaultView ? e.defaultView.HTMLElement : HTMLElement)
}
  , kw = n => n.type === "select-multiple"
  , __ = n => n.type === "radio"
  , Gz = n => __(n) || yu(n)
  , gg = n => Rf(n) && n.isConnected;
function jz(n, e) {
    const t = e.slice(0, -1).length;
    let r = 0;
    for (; r < t; )
        n = Bn(n) ? r++ : n[e[r++]];
    return n
}
function Wz(n) {
    for (const e in n)
        if (n.hasOwnProperty(e) && !Bn(n[e]))
            return !1;
    return !0
}
function Kn(n, e) {
    const t = Array.isArray(e) ? e : g_(e) ? [e] : Lw(e)
      , r = t.length === 1 ? n : jz(n, t)
      , s = t.length - 1
      , o = t[s];
    return r && delete r[o],
    s !== 0 && (Vn(r) && bi(r) || Array.isArray(r) && Wz(r)) && Kn(n, t.slice(0, -1)),
    n
}
var Fw = n => {
    for (const e in n)
        if (_r(n[e]))
            return !0;
    return !1
}
;
function Cf(n, e={}) {
    const t = Array.isArray(n);
    if (Vn(n) || t)
        for (const r in n)
            Array.isArray(n[r]) || Vn(n[r]) && !Fw(n[r]) ? (e[r] = Array.isArray(n[r]) ? [] : {},
            Cf(n[r], e[r])) : Ei(n[r]) || (e[r] = !0);
    return e
}
function Bw(n, e, t) {
    const r = Array.isArray(n);
    if (Vn(n) || r)
        for (const s in n)
            Array.isArray(n[s]) || Vn(n[s]) && !Fw(n[s]) ? Bn(e) || Dv(t[s]) ? t[s] = Array.isArray(n[s]) ? Cf(n[s], []) : {
                ...Cf(n[s])
            } : Bw(n[s], Ei(e) ? {} : e[s], t[s]) : t[s] = !hs(n[s], e[s]);
    return t
}
var Oc = (n, e) => Bw(n, e, Cf(e));
const oE = {
    value: !1,
    isValid: !1
}
  , lE = {
    value: !0,
    isValid: !0
};
var Vw = n => {
    if (Array.isArray(n)) {
        if (n.length > 1) {
            const e = n.filter(t => t && t.checked && !t.disabled).map(t => t.value);
            return {
                value: e,
                isValid: !!e.length
            }
        }
        return n[0].checked && !n[0].disabled ? n[0].attributes && !Bn(n[0].attributes.value) ? Bn(n[0].value) || n[0].value === "" ? lE : {
            value: n[0].value,
            isValid: !0
        } : lE : oE
    }
    return oE
}
  , Hw = (n, {valueAsNumber: e, valueAsDate: t, setValueAs: r}) => Bn(n) ? n : e ? n === "" ? NaN : n && +n : t && Lr(n) ? new Date(n) : r ? r(n) : n;
const cE = {
    isValid: !1,
    value: null
};
var Gw = n => Array.isArray(n) ? n.reduce( (e, t) => t && t.checked && !t.disabled ? {
    isValid: !0,
    value: t.value
} : e, cE) : cE;
function uE(n) {
    const e = n.ref;
    return v_(e) ? e.files : __(e) ? Gw(n.refs).value : kw(e) ? [...e.selectedOptions].map( ({value: t}) => t) : yu(e) ? Vw(n.refs).value : Hw(Bn(e.value) ? n.ref.value : e.value, n)
}
var Xz = (n, e, t, r) => {
    const s = {};
    for (const o of n) {
        const u = Je(e, o);
        u && mn(s, o, u._f)
    }
    return {
        criteriaMode: t,
        names: [...n],
        fields: s,
        shouldUseNativeValidation: r
    }
}
  , Df = n => n instanceof RegExp
  , Pc = n => Bn(n) ? n : Df(n) ? n.source : Vn(n) ? Df(n.value) ? n.value.source : n.value : n
  , dE = n => ({
    isOnSubmit: !n || n === vr.onSubmit,
    isOnBlur: n === vr.onBlur,
    isOnChange: n === vr.onChange,
    isOnAll: n === vr.all,
    isOnTouch: n === vr.onTouched
});
const fE = "AsyncFunction";
var qz = n => !!n && !!n.validate && !!(_r(n.validate) && n.validate.constructor.name === fE || Vn(n.validate) && Object.values(n.validate).find(e => e.constructor.name === fE))
  , Yz = n => n.mount && (n.required || n.min || n.max || n.maxLength || n.minLength || n.pattern || n.validate)
  , hE = (n, e, t) => !t && (e.watchAll || e.watch.has(n) || [...e.watch].some(r => n.startsWith(r) && /^\.\w+/.test(n.slice(r.length))));
const qc = (n, e, t, r) => {
    for (const s of t || Object.keys(n)) {
        const o = Je(n, s);
        if (o) {
            const {_f: u, ...d} = o;
            if (u) {
                if (u.refs && u.refs[0] && e(u.refs[0], s) && !r)
                    return !0;
                if (u.ref && e(u.ref, u.name) && !r)
                    return !0;
                if (qc(d, e))
                    break
            } else if (Vn(d) && qc(d, e))
                break
        }
    }
}
;
function pE(n, e, t) {
    const r = Je(n, t);
    if (r || g_(t))
        return {
            error: r,
            name: t
        };
    const s = t.split(".");
    for (; s.length; ) {
        const o = s.join(".")
          , u = Je(e, o)
          , d = Je(n, o);
        if (u && !Array.isArray(u) && t !== o)
            return {
                name: t
            };
        if (d && d.type)
            return {
                name: o,
                error: d
            };
        s.pop()
    }
    return {
        name: t
    }
}
var Zz = (n, e, t, r) => {
    t(n);
    const {name: s, ...o} = n;
    return bi(o) || Object.keys(o).length >= Object.keys(e).length || Object.keys(o).find(u => e[u] === (!r || vr.all))
}
  , $z = (n, e, t) => !n || !e || n === e || Xc(n).some(r => r && (t ? r === e : r.startsWith(e) || e.startsWith(r)))
  , Kz = (n, e, t, r, s) => s.isOnAll ? !1 : !t && s.isOnTouch ? !(e || n) : (t ? r.isOnBlur : s.isOnBlur) ? !n : (t ? r.isOnChange : s.isOnChange) ? n : !0
  , Qz = (n, e) => !sh(Je(n, e)).length && Kn(n, e)
  , Jz = (n, e, t) => {
    const r = Xc(Je(n, t));
    return mn(r, "root", e[t]),
    mn(n, t, r),
    n
}
  , yf = n => Lr(n);
function mE(n, e, t="validate") {
    if (yf(n) || Array.isArray(n) && n.every(yf) || qi(n) && !n)
        return {
            type: t,
            message: yf(n) ? n : "",
            ref: e
        }
}
var nl = n => Vn(n) && !Df(n) ? n : {
    value: n,
    message: ""
}
  , gE = async (n, e, t, r, s, o) => {
    const {ref: u, refs: d, required: f, maxLength: h, minLength: m, min: g, max: _, pattern: x, validate: E, name: M, valueAsNumber: b, mount: y} = n._f
      , T = Je(t, M);
    if (!y || e.has(M))
        return {};
    const D = d ? d[0] : u
      , C = Q => {
        s && D.reportValidity && (D.setCustomValidity(qi(Q) ? "" : Q || ""),
        D.reportValidity())
    }
      , P = {}
      , A = __(u)
      , F = yu(u)
      , z = A || F
      , U = (b || v_(u)) && Bn(u.value) && Bn(T) || Rf(u) && u.value === "" || T === "" || Array.isArray(T) && !T.length
      , R = zw.bind(null, M, r, P)
      , V = (Q, X, oe, le=ca.maxLength, O=ca.minLength) => {
        const W = Q ? X : oe;
        P[M] = {
            type: Q ? le : O,
            message: W,
            ref: u,
            ...R(Q ? le : O, W)
        }
    }
    ;
    if (o ? !Array.isArray(T) || !T.length : f && (!z && (U || Ei(T)) || qi(T) && !T || F && !Vw(d).isValid || A && !Gw(d).isValid)) {
        const {value: Q, message: X} = yf(f) ? {
            value: !!f,
            message: f
        } : nl(f);
        if (Q && (P[M] = {
            type: ca.required,
            message: X,
            ref: D,
            ...R(ca.required, X)
        },
        !r))
            return C(X),
            P
    }
    if (!U && (!Ei(g) || !Ei(_))) {
        let Q, X;
        const oe = nl(_)
          , le = nl(g);
        if (!Ei(T) && !isNaN(T)) {
            const O = u.valueAsNumber || T && +T;
            Ei(oe.value) || (Q = O > oe.value),
            Ei(le.value) || (X = O < le.value)
        } else {
            const O = u.valueAsDate || new Date(T)
              , W = k => new Date(new Date().toDateString() + " " + k)
              , H = u.type == "time"
              , Me = u.type == "week";
            Lr(oe.value) && T && (Q = H ? W(T) > W(oe.value) : Me ? T > oe.value : O > new Date(oe.value)),
            Lr(le.value) && T && (X = H ? W(T) < W(le.value) : Me ? T < le.value : O < new Date(le.value))
        }
        if ((Q || X) && (V(!!Q, oe.message, le.message, ca.max, ca.min),
        !r))
            return C(P[M].message),
            P
    }
    if ((h || m) && !U && (Lr(T) || o && Array.isArray(T))) {
        const Q = nl(h)
          , X = nl(m)
          , oe = !Ei(Q.value) && T.length > +Q.value
          , le = !Ei(X.value) && T.length < +X.value;
        if ((oe || le) && (V(oe, Q.message, X.message),
        !r))
            return C(P[M].message),
            P
    }
    if (x && !U && Lr(T)) {
        const {value: Q, message: X} = nl(x);
        if (Df(Q) && !T.match(Q) && (P[M] = {
            type: ca.pattern,
            message: X,
            ref: u,
            ...R(ca.pattern, X)
        },
        !r))
            return C(X),
            P
    }
    if (E) {
        if (_r(E)) {
            const Q = await E(T, t)
              , X = mE(Q, D);
            if (X && (P[M] = {
                ...X,
                ...R(ca.validate, X.message)
            },
            !r))
                return C(X.message),
                P
        } else if (Vn(E)) {
            let Q = {};
            for (const X in E) {
                if (!bi(Q) && !r)
                    break;
                const oe = mE(await E[X](T, t), D, X);
                oe && (Q = {
                    ...oe,
                    ...R(X, oe.message)
                },
                C(oe.message),
                r && (P[M] = Q))
            }
            if (!bi(Q) && (P[M] = {
                ref: D,
                ...Q
            },
            !r))
                return P
        }
    }
    return C(!0),
    P
}
;
const ek = {
    mode: vr.onSubmit,
    reValidateMode: vr.onChange,
    shouldFocusError: !0
};
function tk(n={}) {
    let e = {
        ...ek,
        ...n
    }
      , t = {
        submitCount: 0,
        isDirty: !1,
        isLoading: _r(e.defaultValues),
        isValidating: !1,
        isSubmitted: !1,
        isSubmitting: !1,
        isSubmitSuccessful: !1,
        isValid: !1,
        touchedFields: {},
        dirtyFields: {},
        validatingFields: {},
        errors: e.errors || {},
        disabled: e.disabled || !1
    };
    const r = {};
    let s = Vn(e.defaultValues) || Vn(e.values) ? di(e.values || e.defaultValues) || {} : {}, o = e.shouldUnregister ? {} : di(s), u = {
        action: !1,
        mount: !1,
        watch: !1
    }, d = {
        mount: new Set,
        disabled: new Set,
        unMount: new Set,
        array: new Set,
        watch: new Set
    }, f, h = 0;
    const m = {
        isDirty: !1,
        dirtyFields: !1,
        validatingFields: !1,
        touchedFields: !1,
        isValidating: !1,
        isValid: !1,
        errors: !1
    };
    let g = {
        ...m
    };
    const _ = {
        array: sE(),
        state: sE()
    }
      , x = dE(e.mode)
      , E = dE(e.reValidateMode)
      , M = e.criteriaMode === vr.all
      , b = S => I => {
        clearTimeout(h),
        h = setTimeout(S, I)
    }
      , y = async S => {
        if (!e.disabled && (m.isValid || g.isValid || S)) {
            const I = e.resolver ? bi((await U()).errors) : await V(r, !0);
            I !== t.isValid && _.state.next({
                isValid: I
            })
        }
    }
      , T = (S, I) => {
        !e.disabled && (m.isValidating || m.validatingFields || g.isValidating || g.validatingFields) && ((S || Array.from(d.mount)).forEach(q => {
            q && (I ? mn(t.validatingFields, q, I) : Kn(t.validatingFields, q))
        }
        ),
        _.state.next({
            validatingFields: t.validatingFields,
            isValidating: !bi(t.validatingFields)
        }))
    }
      , D = (S, I=[], q, se, J=!0, de=!0) => {
        if (se && q && !e.disabled) {
            if (u.action = !0,
            de && Array.isArray(Je(r, S))) {
                const _e = q(Je(r, S), se.argA, se.argB);
                J && mn(r, S, _e)
            }
            if (de && Array.isArray(Je(t.errors, S))) {
                const _e = q(Je(t.errors, S), se.argA, se.argB);
                J && mn(t.errors, S, _e),
                Qz(t.errors, S)
            }
            if ((m.touchedFields || g.touchedFields) && de && Array.isArray(Je(t.touchedFields, S))) {
                const _e = q(Je(t.touchedFields, S), se.argA, se.argB);
                J && mn(t.touchedFields, S, _e)
            }
            (m.dirtyFields || g.dirtyFields) && (t.dirtyFields = Oc(s, o)),
            _.state.next({
                name: S,
                isDirty: X(S, I),
                dirtyFields: t.dirtyFields,
                errors: t.errors,
                isValid: t.isValid
            })
        } else
            mn(o, S, I)
    }
      , C = (S, I) => {
        mn(t.errors, S, I),
        _.state.next({
            errors: t.errors
        })
    }
      , P = S => {
        t.errors = S,
        _.state.next({
            errors: t.errors,
            isValid: !1
        })
    }
      , A = (S, I, q, se) => {
        const J = Je(r, S);
        if (J) {
            const de = Je(o, S, Bn(q) ? Je(s, S) : q);
            Bn(de) || se && se.defaultChecked || I ? mn(o, S, I ? de : uE(J._f)) : O(S, de),
            u.mount && y()
        }
    }
      , F = (S, I, q, se, J) => {
        let de = !1
          , _e = !1;
        const Ae = {
            name: S
        };
        if (!e.disabled) {
            if (!q || se) {
                (m.isDirty || g.isDirty) && (_e = t.isDirty,
                t.isDirty = Ae.isDirty = X(),
                de = _e !== Ae.isDirty);
                const lt = hs(Je(s, S), I);
                _e = !!Je(t.dirtyFields, S),
                lt ? Kn(t.dirtyFields, S) : mn(t.dirtyFields, S, !0),
                Ae.dirtyFields = t.dirtyFields,
                de = de || (m.dirtyFields || g.dirtyFields) && _e !== !lt
            }
            if (q) {
                const lt = Je(t.touchedFields, S);
                lt || (mn(t.touchedFields, S, q),
                Ae.touchedFields = t.touchedFields,
                de = de || (m.touchedFields || g.touchedFields) && lt !== q)
            }
            de && J && _.state.next(Ae)
        }
        return de ? Ae : {}
    }
      , z = (S, I, q, se) => {
        const J = Je(t.errors, S)
          , de = (m.isValid || g.isValid) && qi(I) && t.isValid !== I;
        if (e.delayError && q ? (f = b( () => C(S, q)),
        f(e.delayError)) : (clearTimeout(h),
        f = null,
        q ? mn(t.errors, S, q) : Kn(t.errors, S)),
        (q ? !hs(J, q) : J) || !bi(se) || de) {
            const _e = {
                ...se,
                ...de && qi(I) ? {
                    isValid: I
                } : {},
                errors: t.errors,
                name: S
            };
            t = {
                ...t,
                ..._e
            },
            _.state.next(_e)
        }
    }
      , U = async S => {
        T(S, !0);
        const I = await e.resolver(o, e.context, Xz(S || d.mount, r, e.criteriaMode, e.shouldUseNativeValidation));
        return T(S),
        I
    }
      , R = async S => {
        const {errors: I} = await U(S);
        if (S)
            for (const q of S) {
                const se = Je(I, q);
                se ? mn(t.errors, q, se) : Kn(t.errors, q)
            }
        else
            t.errors = I;
        return I
    }
      , V = async (S, I, q={
        valid: !0
    }) => {
        for (const se in S) {
            const J = S[se];
            if (J) {
                const {_f: de, ..._e} = J;
                if (de) {
                    const Ae = d.array.has(de.name)
                      , lt = J._f && qz(J._f);
                    lt && m.validatingFields && T([se], !0);
                    const Le = await gE(J, d.disabled, o, M, e.shouldUseNativeValidation && !I, Ae);
                    if (lt && m.validatingFields && T([se]),
                    Le[de.name] && (q.valid = !1,
                    I))
                        break;
                    !I && (Je(Le, de.name) ? Ae ? Jz(t.errors, Le, de.name) : mn(t.errors, de.name, Le[de.name]) : Kn(t.errors, de.name))
                }
                !bi(_e) && await V(_e, I, q)
            }
        }
        return q.valid
    }
      , Q = () => {
        for (const S of d.unMount) {
            const I = Je(r, S);
            I && (I._f.refs ? I._f.refs.every(q => !gg(q)) : !gg(I._f.ref)) && _t(S)
        }
        d.unMount = new Set
    }
      , X = (S, I) => !e.disabled && (S && I && mn(o, S, I),
    !hs(ge(), s))
      , oe = (S, I, q) => Iw(S, d, {
        ...u.mount ? o : Bn(I) ? s : Lr(S) ? {
            [S]: I
        } : I
    }, q, I)
      , le = S => sh(Je(u.mount ? o : s, S, e.shouldUnregister ? Je(s, S, []) : []))
      , O = (S, I, q={}) => {
        const se = Je(r, S);
        let J = I;
        if (se) {
            const de = se._f;
            de && (!de.disabled && mn(o, S, Hw(I, de)),
            J = Rf(de.ref) && Ei(I) ? "" : I,
            kw(de.ref) ? [...de.ref.options].forEach(_e => _e.selected = J.includes(_e.value)) : de.refs ? yu(de.ref) ? de.refs.length > 1 ? de.refs.forEach(_e => (!_e.defaultChecked || !_e.disabled) && (_e.checked = Array.isArray(J) ? !!J.find(Ae => Ae === _e.value) : J === _e.value)) : de.refs[0] && (de.refs[0].checked = !!J) : de.refs.forEach(_e => _e.checked = _e.value === J) : v_(de.ref) ? de.ref.value = "" : (de.ref.value = J,
            de.ref.type || _.state.next({
                name: S,
                values: di(o)
            })))
        }
        (q.shouldDirty || q.shouldTouch) && F(S, J, q.shouldTouch, q.shouldDirty, !0),
        q.shouldValidate && ee(S)
    }
      , W = (S, I, q) => {
        for (const se in I) {
            const J = I[se]
              , de = `${S}.${se}`
              , _e = Je(r, de);
            (d.array.has(S) || Vn(J) || _e && !_e._f) && !Js(J) ? W(de, J, q) : O(de, J, q)
        }
    }
      , H = (S, I, q={}) => {
        const se = Je(r, S)
          , J = d.array.has(S)
          , de = di(I);
        mn(o, S, de),
        J ? (_.array.next({
            name: S,
            values: di(o)
        }),
        (m.isDirty || m.dirtyFields || g.isDirty || g.dirtyFields) && q.shouldDirty && _.state.next({
            name: S,
            dirtyFields: Oc(s, o),
            isDirty: X(S, de)
        })) : se && !se._f && !Ei(de) ? W(S, de, q) : O(S, de, q),
        hE(S, d) && _.state.next({
            ...t
        }),
        _.state.next({
            name: u.mount ? S : void 0,
            values: di(o)
        })
    }
      , Me = async S => {
        u.mount = !0;
        const I = S.target;
        let q = I.name
          , se = !0;
        const J = Je(r, q)
          , de = _e => {
            se = Number.isNaN(_e) || Js(_e) && isNaN(_e.getTime()) || hs(_e, Je(o, q, _e))
        }
        ;
        if (J) {
            let _e, Ae;
            const lt = I.type ? uE(J._f) : Dw(S)
              , Le = S.type === Af.BLUR || S.type === Af.FOCUS_OUT
              , $e = !Yz(J._f) && !e.resolver && !Je(t.errors, q) && !J._f.deps || Kz(Le, Je(t.touchedFields, q), t.isSubmitted, E, x)
              , ht = hE(q, d, Le);
            mn(o, q, lt),
            Le ? (J._f.onBlur && J._f.onBlur(S),
            f && f(0)) : J._f.onChange && J._f.onChange(S);
            const yt = F(q, lt, Le)
              , qe = !bi(yt) || ht;
            if (!Le && _.state.next({
                name: q,
                type: S.type,
                values: di(o)
            }),
            $e)
                return (m.isValid || g.isValid) && (e.mode === "onBlur" ? Le && y() : Le || y()),
                qe && _.state.next({
                    name: q,
                    ...ht ? {} : yt
                });
            if (!Le && ht && _.state.next({
                ...t
            }),
            e.resolver) {
                const {errors: Lt} = await U([q]);
                if (de(lt),
                se) {
                    const Tt = pE(t.errors, r, q)
                      , qt = pE(Lt, r, Tt.name || q);
                    _e = qt.error,
                    q = qt.name,
                    Ae = bi(Lt)
                }
            } else
                T([q], !0),
                _e = (await gE(J, d.disabled, o, M, e.shouldUseNativeValidation))[q],
                T([q]),
                de(lt),
                se && (_e ? Ae = !1 : (m.isValid || g.isValid) && (Ae = await V(r, !0)));
            se && (J._f.deps && ee(J._f.deps),
            z(q, Ae, _e, yt))
        }
    }
      , k = (S, I) => {
        if (Je(t.errors, I) && S.focus)
            return S.focus(),
            1
    }
      , ee = async (S, I={}) => {
        let q, se;
        const J = Xc(S);
        if (e.resolver) {
            const de = await R(Bn(S) ? S : J);
            q = bi(de),
            se = S ? !J.some(_e => Je(de, _e)) : q
        } else
            S ? (se = (await Promise.all(J.map(async de => {
                const _e = Je(r, de);
                return await V(_e && _e._f ? {
                    [de]: _e
                } : _e)
            }
            ))).every(Boolean),
            !(!se && !t.isValid) && y()) : se = q = await V(r);
        return _.state.next({
            ...!Lr(S) || (m.isValid || g.isValid) && q !== t.isValid ? {} : {
                name: S
            },
            ...e.resolver || !S ? {
                isValid: q
            } : {},
            errors: t.errors
        }),
        I.shouldFocus && !se && qc(r, k, S ? J : d.mount),
        se
    }
      , ge = S => {
        const I = {
            ...u.mount ? o : s
        };
        return Bn(S) ? I : Lr(S) ? Je(I, S) : S.map(q => Je(I, q))
    }
      , pe = (S, I) => ({
        invalid: !!Je((I || t).errors, S),
        isDirty: !!Je((I || t).dirtyFields, S),
        error: Je((I || t).errors, S),
        isValidating: !!Je(t.validatingFields, S),
        isTouched: !!Je((I || t).touchedFields, S)
    })
      , te = S => {
        S && Xc(S).forEach(I => Kn(t.errors, I)),
        _.state.next({
            errors: S ? t.errors : {}
        })
    }
      , we = (S, I, q) => {
        const se = (Je(r, S, {
            _f: {}
        })._f || {}).ref
          , J = Je(t.errors, S) || {}
          , {ref: de, message: _e, type: Ae, ...lt} = J;
        mn(t.errors, S, {
            ...lt,
            ...I,
            ref: se
        }),
        _.state.next({
            name: S,
            errors: t.errors,
            isValid: !1
        }),
        q && q.shouldFocus && se && se.focus && se.focus()
    }
      , Se = (S, I) => _r(S) ? _.state.subscribe({
        next: q => S(oe(void 0, I), q)
    }) : oe(S, I, !0)
      , De = S => _.state.subscribe({
        next: I => {
            $z(S.name, I.name, S.exact) && Zz(I, S.formState || m, pt, S.reRenderRoot) && S.callback({
                values: {
                    ...o
                },
                ...t,
                ...I
            })
        }
    }).unsubscribe
      , Ve = S => (u.mount = !0,
    g = {
        ...g,
        ...S.formState
    },
    De({
        ...S,
        formState: g
    }))
      , _t = (S, I={}) => {
        for (const q of S ? Xc(S) : d.mount)
            d.mount.delete(q),
            d.array.delete(q),
            I.keepValue || (Kn(r, q),
            Kn(o, q)),
            !I.keepError && Kn(t.errors, q),
            !I.keepDirty && Kn(t.dirtyFields, q),
            !I.keepTouched && Kn(t.touchedFields, q),
            !I.keepIsValidating && Kn(t.validatingFields, q),
            !e.shouldUnregister && !I.keepDefaultValue && Kn(s, q);
        _.state.next({
            values: di(o)
        }),
        _.state.next({
            ...t,
            ...I.keepDirty ? {
                isDirty: X()
            } : {}
        }),
        !I.keepIsValid && y()
    }
      , He = ({disabled: S, name: I}) => {
        (qi(S) && u.mount || S || d.disabled.has(I)) && (S ? d.disabled.add(I) : d.disabled.delete(I))
    }
      , Pt = (S, I={}) => {
        let q = Je(r, S);
        const se = qi(I.disabled) || qi(e.disabled);
        return mn(r, S, {
            ...q || {},
            _f: {
                ...q && q._f ? q._f : {
                    ref: {
                        name: S
                    }
                },
                name: S,
                mount: !0,
                ...I
            }
        }),
        d.mount.add(S),
        q ? He({
            disabled: qi(I.disabled) ? I.disabled : e.disabled,
            name: S
        }) : A(S, !0, I.value),
        {
            ...se ? {
                disabled: I.disabled || e.disabled
            } : {},
            ...e.progressive ? {
                required: !!I.required,
                min: Pc(I.min),
                max: Pc(I.max),
                minLength: Pc(I.minLength),
                maxLength: Pc(I.maxLength),
                pattern: Pc(I.pattern)
            } : {},
            name: S,
            onChange: Me,
            onBlur: Me,
            ref: J => {
                if (J) {
                    Pt(S, I),
                    q = Je(r, S);
                    const de = Bn(J.value) && J.querySelectorAll && J.querySelectorAll("input,select,textarea")[0] || J
                      , _e = Gz(de)
                      , Ae = q._f.refs || [];
                    if (_e ? Ae.find(lt => lt === de) : de === q._f.ref)
                        return;
                    mn(r, S, {
                        _f: {
                            ...q._f,
                            ..._e ? {
                                refs: [...Ae.filter(gg), de, ...Array.isArray(Je(s, S)) ? [{}] : []],
                                ref: {
                                    type: de.type,
                                    name: S
                                }
                            } : {
                                ref: de
                            }
                        }
                    }),
                    A(S, !1, void 0, de)
                } else
                    q = Je(r, S, {}),
                    q._f && (q._f.mount = !1),
                    (e.shouldUnregister || I.shouldUnregister) && !(Uw(d.array, S) && u.action) && d.unMount.add(S)
            }
        }
    }
      , kt = () => e.shouldFocusError && qc(r, k, d.mount)
      , nt = S => {
        qi(S) && (_.state.next({
            disabled: S
        }),
        qc(r, (I, q) => {
            const se = Je(r, q);
            se && (I.disabled = se._f.disabled || S,
            Array.isArray(se._f.refs) && se._f.refs.forEach(J => {
                J.disabled = se._f.disabled || S
            }
            ))
        }
        , 0, !1))
    }
      , G = (S, I) => async q => {
        let se;
        q && (q.preventDefault && q.preventDefault(),
        q.persist && q.persist());
        let J = di(o);
        if (_.state.next({
            isSubmitting: !0
        }),
        e.resolver) {
            const {errors: de, values: _e} = await U();
            t.errors = de,
            J = _e
        } else
            await V(r);
        if (d.disabled.size)
            for (const de of d.disabled)
                mn(J, de, void 0);
        if (Kn(t.errors, "root"),
        bi(t.errors)) {
            _.state.next({
                errors: {}
            });
            try {
                await S(J, q)
            } catch (de) {
                se = de
            }
        } else
            I && await I({
                ...t.errors
            }, q),
            kt(),
            setTimeout(kt);
        if (_.state.next({
            isSubmitted: !0,
            isSubmitting: !1,
            isSubmitSuccessful: bi(t.errors) && !se,
            submitCount: t.submitCount + 1,
            errors: t.errors
        }),
        se)
            throw se
    }
      , Zt = (S, I={}) => {
        Je(r, S) && (Bn(I.defaultValue) ? H(S, di(Je(s, S))) : (H(S, I.defaultValue),
        mn(s, S, di(I.defaultValue))),
        I.keepTouched || Kn(t.touchedFields, S),
        I.keepDirty || (Kn(t.dirtyFields, S),
        t.isDirty = I.defaultValue ? X(S, di(Je(s, S))) : X()),
        I.keepError || (Kn(t.errors, S),
        m.isValid && y()),
        _.state.next({
            ...t
        }))
    }
      , ot = (S, I={}) => {
        const q = S ? di(S) : s
          , se = di(q)
          , J = bi(S)
          , de = J ? s : se;
        if (I.keepDefaultValues || (s = q),
        !I.keepValues) {
            if (I.keepDirtyValues) {
                const _e = new Set([...d.mount, ...Object.keys(Oc(s, o))]);
                for (const Ae of Array.from(_e))
                    Je(t.dirtyFields, Ae) ? mn(de, Ae, Je(o, Ae)) : H(Ae, Je(de, Ae))
            } else {
                if (m_ && Bn(S))
                    for (const _e of d.mount) {
                        const Ae = Je(r, _e);
                        if (Ae && Ae._f) {
                            const lt = Array.isArray(Ae._f.refs) ? Ae._f.refs[0] : Ae._f.ref;
                            if (Rf(lt)) {
                                const Le = lt.closest("form");
                                if (Le) {
                                    Le.reset();
                                    break
                                }
                            }
                        }
                    }
                for (const _e of d.mount)
                    H(_e, Je(de, _e))
            }
            o = di(de),
            _.array.next({
                values: {
                    ...de
                }
            }),
            _.state.next({
                values: {
                    ...de
                }
            })
        }
        d = {
            mount: I.keepDirtyValues ? d.mount : new Set,
            unMount: new Set,
            array: new Set,
            disabled: new Set,
            watch: new Set,
            watchAll: !1,
            focus: ""
        },
        u.mount = !m.isValid || !!I.keepIsValid || !!I.keepDirtyValues,
        u.watch = !!e.shouldUnregister,
        _.state.next({
            submitCount: I.keepSubmitCount ? t.submitCount : 0,
            isDirty: J ? !1 : I.keepDirty ? t.isDirty : !!(I.keepDefaultValues && !hs(S, s)),
            isSubmitted: I.keepIsSubmitted ? t.isSubmitted : !1,
            dirtyFields: J ? {} : I.keepDirtyValues ? I.keepDefaultValues && o ? Oc(s, o) : t.dirtyFields : I.keepDefaultValues && S ? Oc(s, S) : I.keepDirty ? t.dirtyFields : {},
            touchedFields: I.keepTouched ? t.touchedFields : {},
            errors: I.keepErrors ? t.errors : {},
            isSubmitSuccessful: I.keepIsSubmitSuccessful ? t.isSubmitSuccessful : !1,
            isSubmitting: !1
        })
    }
      , it = (S, I) => ot(_r(S) ? S(o) : S, I)
      , rt = (S, I={}) => {
        const q = Je(r, S)
          , se = q && q._f;
        if (se) {
            const J = se.refs ? se.refs[0] : se.ref;
            J.focus && (J.focus(),
            I.shouldSelect && _r(J.select) && J.select())
        }
    }
      , pt = S => {
        t = {
            ...t,
            ...S
        }
    }
      , B = {
        control: {
            register: Pt,
            unregister: _t,
            getFieldState: pe,
            handleSubmit: G,
            setError: we,
            _subscribe: De,
            _runSchema: U,
            _getWatch: oe,
            _getDirty: X,
            _setValid: y,
            _setFieldArray: D,
            _setDisabledField: He,
            _setErrors: P,
            _getFieldArray: le,
            _reset: ot,
            _resetDefaultValues: () => _r(e.defaultValues) && e.defaultValues().then(S => {
                it(S, e.resetOptions),
                _.state.next({
                    isLoading: !1
                })
            }
            ),
            _removeUnmounted: Q,
            _disableForm: nt,
            _subjects: _,
            _proxyFormState: m,
            get _fields() {
                return r
            },
            get _formValues() {
                return o
            },
            get _state() {
                return u
            },
            set _state(S) {
                u = S
            },
            get _defaultValues() {
                return s
            },
            get _names() {
                return d
            },
            set _names(S) {
                d = S
            },
            get _formState() {
                return t
            },
            get _options() {
                return e
            },
            set _options(S) {
                e = {
                    ...e,
                    ...S
                }
            }
        },
        subscribe: Ve,
        trigger: ee,
        register: Pt,
        handleSubmit: G,
        watch: Se,
        setValue: H,
        getValues: ge,
        reset: it,
        resetField: Zt,
        clearErrors: te,
        unregister: _t,
        setError: we,
        setFocus: rt,
        getFieldState: pe
    };
    return {
        ...B,
        formControl: B
    }
}
function jw(n={}) {
    const e = K.useRef(void 0)
      , t = K.useRef(void 0)
      , [r,s] = K.useState({
        isDirty: !1,
        isValidating: !1,
        isLoading: _r(n.defaultValues),
        isSubmitted: !1,
        isSubmitting: !1,
        isSubmitSuccessful: !1,
        isValid: !1,
        submitCount: 0,
        dirtyFields: {},
        touchedFields: {},
        validatingFields: {},
        errors: n.errors || {},
        disabled: n.disabled || !1,
        defaultValues: _r(n.defaultValues) ? void 0 : n.defaultValues
    });
    e.current || (e.current = {
        ...n.formControl ? n.formControl : tk(n),
        formState: r
    },
    n.formControl && n.defaultValues && !_r(n.defaultValues) && n.formControl.reset(n.defaultValues, n.resetOptions));
    const o = e.current.control;
    return o._options = n,
    K.useLayoutEffect( () => o._subscribe({
        formState: o._proxyFormState,
        callback: () => s({
            ...o._formState
        }),
        reRenderRoot: !0
    }), [o]),
    K.useEffect( () => o._disableForm(n.disabled), [o, n.disabled]),
    K.useEffect( () => {
        if (o._proxyFormState.isDirty) {
            const u = o._getDirty();
            u !== r.isDirty && o._subjects.state.next({
                isDirty: u
            })
        }
    }
    , [o, r.isDirty]),
    K.useEffect( () => {
        n.values && !hs(n.values, t.current) ? (o._reset(n.values, o._options.resetOptions),
        t.current = n.values,
        s(u => ({
            ...u
        }))) : o._resetDefaultValues()
    }
    , [n.values, o]),
    K.useEffect( () => {
        n.errors && !bi(n.errors) && o._setErrors(n.errors)
    }
    , [n.errors, o]),
    K.useEffect( () => {
        o._state.mount || (o._setValid(),
        o._state.mount = !0),
        o._state.watch && (o._state.watch = !1,
        o._subjects.state.next({
            ...o._formState
        })),
        o._removeUnmounted()
    }
    ),
    K.useEffect( () => {
        n.shouldUnregister && o._subjects.state.next({
            values: o._getWatch()
        })
    }
    , [n.shouldUnregister, o]),
    e.current.formState = Ow(r, o),
    e.current
}
var nk = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "select", "span", "svg", "ul"]
  , ik = nk.reduce( (n, e) => {
    const t = mw(`Primitive.${e}`)
      , r = $.forwardRef( (s, o) => {
        const {asChild: u, ...d} = s
          , f = u ? t : e;
        return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0),
        Z.jsx(f, {
            ...d,
            ref: o
        })
    }
    );
    return r.displayName = `Primitive.${e}`,
    {
        ...n,
        [e]: r
    }
}
, {})
  , rk = "Label"
  , Ww = $.forwardRef( (n, e) => Z.jsx(ik.label, {
    ...n,
    ref: e,
    onMouseDown: t => {
        var s;
        t.target.closest("button, input, select, textarea") || ((s = n.onMouseDown) == null || s.call(n, t),
        !t.defaultPrevented && t.detail > 1 && t.preventDefault())
    }
}));
Ww.displayName = rk;
var ak = Ww;
function sk({className: n, ...e}) {
    return Z.jsx(ak, {
        "data-slot": "label",
        className: Cl("flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50", n),
        ...e
    })
}
const Xw = Fz
  , qw = $.createContext({})
  , fa = ({...n}) => Z.jsx(qw.Provider, {
    value: {
        name: n.name
    },
    children: Z.jsx(Hz, {
        ...n
    })
})
  , y_ = () => {
    const n = $.useContext(qw)
      , e = $.useContext(Yw)
      , {getFieldState: t} = oh()
      , r = Pw({
        name: n.name
    })
      , s = t(n.name, r);
    if (!n)
        throw new Error("useFormField should be used within <FormField>");
    const {id: o} = e;
    return {
        id: o,
        name: n.name,
        formItemId: `${o}-form-item`,
        formDescriptionId: `${o}-form-item-description`,
        formMessageId: `${o}-form-item-message`,
        ...s
    }
}
  , Yw = $.createContext({});
function ha({className: n, ...e}) {
    const t = $.useId();
    return Z.jsx(Yw.Provider, {
        value: {
            id: t
        },
        children: Z.jsx("div", {
            "data-slot": "form-item",
            className: Cl("grid gap-2", n),
            ...e
        })
    })
}
function pa({className: n, ...e}) {
    const {error: t, formItemId: r} = y_();
    return Z.jsx(sk, {
        "data-slot": "form-label",
        "data-error": !!t,
        className: Cl("data-[error=true]:text-destructive", n),
        htmlFor: r,
        ...e
    })
}
function ma({...n}) {
    const {error: e, formItemId: t, formDescriptionId: r, formMessageId: s} = y_();
    return Z.jsx(gw, {
        "data-slot": "form-control",
        id: t,
        "aria-describedby": e ? `${r} ${s}` : `${r}`,
        "aria-invalid": !!e,
        ...n
    })
}
function ga({className: n, ...e}) {
    const {error: t, formMessageId: r} = y_()
      , s = t ? String((t == null ? void 0 : t.message) ?? "") : e.children;
    return s ? Z.jsx("p", {
        "data-slot": "form-message",
        id: r,
        className: Cl("text-destructive text-sm", n),
        ...e,
        children: s
    }) : null
}
function Cr({className: n, type: e, ...t}) {
    return Z.jsx("input", {
        type: e,
        "data-slot": "input",
        className: Cl("file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]", "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive", n),
        ...t
    })
}
/**
 * @license lucide-react v0.501.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ok = n => n.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase()
  , lk = n => n.replace(/^([A-Z])|[\s-_]+(\w)/g, (e, t, r) => r ? r.toUpperCase() : t.toLowerCase())
  , vE = n => {
    const e = lk(n);
    return e.charAt(0).toUpperCase() + e.slice(1)
}
  , Zw = (...n) => n.filter( (e, t, r) => !!e && e.trim() !== "" && r.indexOf(e) === t).join(" ").trim()
  , ck = n => {
    for (const e in n)
        if (e.startsWith("aria-") || e === "role" || e === "title")
            return !0
}
;
/**
 * @license lucide-react v0.501.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var uk = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.501.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const dk = $.forwardRef( ({color: n="currentColor", size: e=24, strokeWidth: t=2, absoluteStrokeWidth: r, className: s="", children: o, iconNode: u, ...d}, f) => $.createElement("svg", {
    ref: f,
    ...uk,
    width: e,
    height: e,
    stroke: n,
    strokeWidth: r ? Number(t) * 24 / Number(e) : t,
    className: Zw("lucide", s),
    ...!o && !ck(d) && {
        "aria-hidden": "true"
    },
    ...d
}, [...u.map( ([h,m]) => $.createElement(h, m)), ...Array.isArray(o) ? o : [o]]));
/**
 * @license lucide-react v0.501.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const fk = (n, e) => {
    const t = $.forwardRef( ({className: r, ...s}, o) => $.createElement(dk, {
        ref: o,
        iconNode: e,
        className: Zw(`lucide-${ok(vE(n))}`, `lucide-${n}`, r),
        ...s
    }));
    return t.displayName = vE(n),
    t
}
;
/**
 * @license lucide-react v0.501.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const hk = [["path", {
    d: "M21 12a9 9 0 1 1-6.219-8.56",
    key: "13zald"
}]]
  , Uv = fk("loader-circle", hk)
  , _E = (n, e, t) => {
    if (n && "reportValidity"in n) {
        const r = Je(t, e);
        n.setCustomValidity(r && r.message || ""),
        n.reportValidity()
    }
}
  , $w = (n, e) => {
    for (const t in e.fields) {
        const r = e.fields[t];
        r && r.ref && "reportValidity"in r.ref ? _E(r.ref, t, n) : r && r.refs && r.refs.forEach(s => _E(s, t, n))
    }
}
  , pk = (n, e) => {
    e.shouldUseNativeValidation && $w(n, e);
    const t = {};
    for (const r in n) {
        const s = Je(e.fields, r)
          , o = Object.assign(n[r] || {}, {
            ref: s && s.ref
        });
        if (mk(e.names || Object.keys(n), r)) {
            const u = Object.assign({}, Je(t, r));
            mn(u, "root", o),
            mn(t, r, u)
        } else
            mn(t, r, o)
    }
    return t
}
  , mk = (n, e) => {
    const t = yE(e);
    return n.some(r => yE(r).match(`^${t}\\.\\d+`))
}
;
function yE(n) {
    return n.replace(/\]|\[/g, "")
}
function gk(n, e) {
    for (var t = {}; n.length; ) {
        var r = n[0]
          , s = r.code
          , o = r.message
          , u = r.path.join(".");
        if (!t[u])
            if ("unionErrors"in r) {
                var d = r.unionErrors[0].errors[0];
                t[u] = {
                    message: d.message,
                    type: d.code
                }
            } else
                t[u] = {
                    message: o,
                    type: s
                };
        if ("unionErrors"in r && r.unionErrors.forEach(function(m) {
            return m.errors.forEach(function(g) {
                return n.push(g)
            })
        }),
        e) {
            var f = t[u].types
              , h = f && f[r.code];
            t[u] = zw(u, e, t, s, h ? [].concat(h, r.message) : r.message)
        }
        n.shift()
    }
    return t
}
function Kw(n, e, t) {
    return t === void 0 && (t = {}),
    function(r, s, o) {
        try {
            return Promise.resolve(function(u, d) {
                try {
                    var f = Promise.resolve(n[t.mode === "sync" ? "parse" : "parseAsync"](r, e)).then(function(h) {
                        return o.shouldUseNativeValidation && $w({}, o),
                        {
                            errors: {},
                            values: t.raw ? Object.assign({}, r) : h
                        }
                    })
                } catch (h) {
                    return d(h)
                }
                return f && f.then ? f.then(void 0, d) : f
            }(0, function(u) {
                if (function(d) {
                    return Array.isArray(d == null ? void 0 : d.errors)
                }(u))
                    return {
                        values: {},
                        errors: pk(gk(u.errors, !o.shouldUseNativeValidation && o.criteriaMode === "all"), o)
                    };
                throw u
            }))
        } catch (u) {
            return Promise.reject(u)
        }
    }
}
var un;
(function(n) {
    n.assertEqual = s => s;
    function e(s) {}
    n.assertIs = e;
    function t(s) {
        throw new Error
    }
    n.assertNever = t,
    n.arrayToEnum = s => {
        const o = {};
        for (const u of s)
            o[u] = u;
        return o
    }
    ,
    n.getValidEnumValues = s => {
        const o = n.objectKeys(s).filter(d => typeof s[s[d]] != "number")
          , u = {};
        for (const d of o)
            u[d] = s[d];
        return n.objectValues(u)
    }
    ,
    n.objectValues = s => n.objectKeys(s).map(function(o) {
        return s[o]
    }),
    n.objectKeys = typeof Object.keys == "function" ? s => Object.keys(s) : s => {
        const o = [];
        for (const u in s)
            Object.prototype.hasOwnProperty.call(s, u) && o.push(u);
        return o
    }
    ,
    n.find = (s, o) => {
        for (const u of s)
            if (o(u))
                return u
    }
    ,
    n.isInteger = typeof Number.isInteger == "function" ? s => Number.isInteger(s) : s => typeof s == "number" && isFinite(s) && Math.floor(s) === s;
    function r(s, o=" | ") {
        return s.map(u => typeof u == "string" ? `'${u}'` : u).join(o)
    }
    n.joinValues = r,
    n.jsonStringifyReplacer = (s, o) => typeof o == "bigint" ? o.toString() : o
}
)(un || (un = {}));
var xE;
(function(n) {
    n.mergeShapes = (e, t) => ({
        ...e,
        ...t
    })
}
)(xE || (xE = {}));
const st = un.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"])
  , us = n => {
    switch (typeof n) {
    case "undefined":
        return st.undefined;
    case "string":
        return st.string;
    case "number":
        return isNaN(n) ? st.nan : st.number;
    case "boolean":
        return st.boolean;
    case "function":
        return st.function;
    case "bigint":
        return st.bigint;
    case "symbol":
        return st.symbol;
    case "object":
        return Array.isArray(n) ? st.array : n === null ? st.null : n.then && typeof n.then == "function" && n.catch && typeof n.catch == "function" ? st.promise : typeof Map < "u" && n instanceof Map ? st.map : typeof Set < "u" && n instanceof Set ? st.set : typeof Date < "u" && n instanceof Date ? st.date : st.object;
    default:
        return st.unknown
    }
}
  , Fe = un.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]);
class sr extends Error {
    get errors() {
        return this.issues
    }
    constructor(e) {
        super(),
        this.issues = [],
        this.addIssue = r => {
            this.issues = [...this.issues, r]
        }
        ,
        this.addIssues = (r=[]) => {
            this.issues = [...this.issues, ...r]
        }
        ;
        const t = new.target.prototype;
        Object.setPrototypeOf ? Object.setPrototypeOf(this, t) : this.__proto__ = t,
        this.name = "ZodError",
        this.issues = e
    }
    format(e) {
        const t = e || function(o) {
            return o.message
        }
          , r = {
            _errors: []
        }
          , s = o => {
            for (const u of o.issues)
                if (u.code === "invalid_union")
                    u.unionErrors.map(s);
                else if (u.code === "invalid_return_type")
                    s(u.returnTypeError);
                else if (u.code === "invalid_arguments")
                    s(u.argumentsError);
                else if (u.path.length === 0)
                    r._errors.push(t(u));
                else {
                    let d = r
                      , f = 0;
                    for (; f < u.path.length; ) {
                        const h = u.path[f];
                        f === u.path.length - 1 ? (d[h] = d[h] || {
                            _errors: []
                        },
                        d[h]._errors.push(t(u))) : d[h] = d[h] || {
                            _errors: []
                        },
                        d = d[h],
                        f++
                    }
                }
        }
        ;
        return s(this),
        r
    }
    static assert(e) {
        if (!(e instanceof sr))
            throw new Error(`Not a ZodError: ${e}`)
    }
    toString() {
        return this.message
    }
    get message() {
        return JSON.stringify(this.issues, un.jsonStringifyReplacer, 2)
    }
    get isEmpty() {
        return this.issues.length === 0
    }
    flatten(e=t => t.message) {
        const t = {}
          , r = [];
        for (const s of this.issues)
            s.path.length > 0 ? (t[s.path[0]] = t[s.path[0]] || [],
            t[s.path[0]].push(e(s))) : r.push(e(s));
        return {
            formErrors: r,
            fieldErrors: t
        }
    }
    get formErrors() {
        return this.flatten()
    }
}
sr.create = n => new sr(n);
const iu = (n, e) => {
    let t;
    switch (n.code) {
    case Fe.invalid_type:
        n.received === st.undefined ? t = "Required" : t = `Expected ${n.expected}, received ${n.received}`;
        break;
    case Fe.invalid_literal:
        t = `Invalid literal value, expected ${JSON.stringify(n.expected, un.jsonStringifyReplacer)}`;
        break;
    case Fe.unrecognized_keys:
        t = `Unrecognized key(s) in object: ${un.joinValues(n.keys, ", ")}`;
        break;
    case Fe.invalid_union:
        t = "Invalid input";
        break;
    case Fe.invalid_union_discriminator:
        t = `Invalid discriminator value. Expected ${un.joinValues(n.options)}`;
        break;
    case Fe.invalid_enum_value:
        t = `Invalid enum value. Expected ${un.joinValues(n.options)}, received '${n.received}'`;
        break;
    case Fe.invalid_arguments:
        t = "Invalid function arguments";
        break;
    case Fe.invalid_return_type:
        t = "Invalid function return type";
        break;
    case Fe.invalid_date:
        t = "Invalid date";
        break;
    case Fe.invalid_string:
        typeof n.validation == "object" ? "includes"in n.validation ? (t = `Invalid input: must include "${n.validation.includes}"`,
        typeof n.validation.position == "number" && (t = `${t} at one or more positions greater than or equal to ${n.validation.position}`)) : "startsWith"in n.validation ? t = `Invalid input: must start with "${n.validation.startsWith}"` : "endsWith"in n.validation ? t = `Invalid input: must end with "${n.validation.endsWith}"` : un.assertNever(n.validation) : n.validation !== "regex" ? t = `Invalid ${n.validation}` : t = "Invalid";
        break;
    case Fe.too_small:
        n.type === "array" ? t = `Array must contain ${n.exact ? "exactly" : n.inclusive ? "at least" : "more than"} ${n.minimum} element(s)` : n.type === "string" ? t = `String must contain ${n.exact ? "exactly" : n.inclusive ? "at least" : "over"} ${n.minimum} character(s)` : n.type === "number" ? t = `Number must be ${n.exact ? "exactly equal to " : n.inclusive ? "greater than or equal to " : "greater than "}${n.minimum}` : n.type === "date" ? t = `Date must be ${n.exact ? "exactly equal to " : n.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(n.minimum))}` : t = "Invalid input";
        break;
    case Fe.too_big:
        n.type === "array" ? t = `Array must contain ${n.exact ? "exactly" : n.inclusive ? "at most" : "less than"} ${n.maximum} element(s)` : n.type === "string" ? t = `String must contain ${n.exact ? "exactly" : n.inclusive ? "at most" : "under"} ${n.maximum} character(s)` : n.type === "number" ? t = `Number must be ${n.exact ? "exactly" : n.inclusive ? "less than or equal to" : "less than"} ${n.maximum}` : n.type === "bigint" ? t = `BigInt must be ${n.exact ? "exactly" : n.inclusive ? "less than or equal to" : "less than"} ${n.maximum}` : n.type === "date" ? t = `Date must be ${n.exact ? "exactly" : n.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(n.maximum))}` : t = "Invalid input";
        break;
    case Fe.custom:
        t = "Invalid input";
        break;
    case Fe.invalid_intersection_types:
        t = "Intersection results could not be merged";
        break;
    case Fe.not_multiple_of:
        t = `Number must be a multiple of ${n.multipleOf}`;
        break;
    case Fe.not_finite:
        t = "Number must be finite";
        break;
    default:
        t = e.defaultError,
        un.assertNever(n)
    }
    return {
        message: t
    }
}
;
let vk = iu;
function Lv() {
    return vk
}
const Nv = n => {
    const {data: e, path: t, errorMaps: r, issueData: s} = n
      , o = [...t, ...s.path || []]
      , u = {
        ...s,
        path: o
    };
    if (s.message !== void 0)
        return {
            ...s,
            path: o,
            message: s.message
        };
    let d = "";
    const f = r.filter(h => !!h).slice().reverse();
    for (const h of f)
        d = h(u, {
            data: e,
            defaultError: d
        }).message;
    return {
        ...s,
        path: o,
        message: d
    }
}
;
function tt(n, e) {
    const t = Lv()
      , r = Nv({
        issueData: e,
        data: n.data,
        path: n.path,
        errorMaps: [n.common.contextualErrorMap, n.schemaErrorMap, t, t === iu ? void 0 : iu].filter(s => !!s)
    });
    n.common.issues.push(r)
}
class Ti {
    constructor() {
        this.value = "valid"
    }
    dirty() {
        this.value === "valid" && (this.value = "dirty")
    }
    abort() {
        this.value !== "aborted" && (this.value = "aborted")
    }
    static mergeArray(e, t) {
        const r = [];
        for (const s of t) {
            if (s.status === "aborted")
                return It;
            s.status === "dirty" && e.dirty(),
            r.push(s.value)
        }
        return {
            status: e.value,
            value: r
        }
    }
    static async mergeObjectAsync(e, t) {
        const r = [];
        for (const s of t) {
            const o = await s.key
              , u = await s.value;
            r.push({
                key: o,
                value: u
            })
        }
        return Ti.mergeObjectSync(e, r)
    }
    static mergeObjectSync(e, t) {
        const r = {};
        for (const s of t) {
            const {key: o, value: u} = s;
            if (o.status === "aborted" || u.status === "aborted")
                return It;
            o.status === "dirty" && e.dirty(),
            u.status === "dirty" && e.dirty(),
            o.value !== "__proto__" && (typeof u.value < "u" || s.alwaysSet) && (r[o.value] = u.value)
        }
        return {
            status: e.value,
            value: r
        }
    }
}
const It = Object.freeze({
    status: "aborted"
})
  , Fc = n => ({
    status: "dirty",
    value: n
})
  , Oi = n => ({
    status: "valid",
    value: n
})
  , bE = n => n.status === "aborted"
  , SE = n => n.status === "dirty"
  , yl = n => n.status === "valid"
  , Uf = n => typeof Promise < "u" && n instanceof Promise;
function Lf(n, e, t, r) {
    if (typeof e == "function" ? n !== e || !0 : !e.has(n))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return e.get(n)
}
function Qw(n, e, t, r, s) {
    if (typeof e == "function" ? n !== e || !0 : !e.has(n))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return e.set(n, t),
    t
}
var vt;
(function(n) {
    n.errToObj = e => typeof e == "string" ? {
        message: e
    } : e || {},
    n.toString = e => typeof e == "string" ? e : e == null ? void 0 : e.message
}
)(vt || (vt = {}));
var Bc, Vc;
class zr {
    constructor(e, t, r, s) {
        this._cachedPath = [],
        this.parent = e,
        this.data = t,
        this._path = r,
        this._key = s
    }
    get path() {
        return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)),
        this._cachedPath
    }
}
const EE = (n, e) => {
    if (yl(e))
        return {
            success: !0,
            data: e.value
        };
    if (!n.common.issues.length)
        throw new Error("Validation failed but no issues detected.");
    return {
        success: !1,
        get error() {
            if (this._error)
                return this._error;
            const t = new sr(n.common.issues);
            return this._error = t,
            this._error
        }
    }
}
;
function Ft(n) {
    if (!n)
        return {};
    const {errorMap: e, invalid_type_error: t, required_error: r, description: s} = n;
    if (e && (t || r))
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return e ? {
        errorMap: e,
        description: s
    } : {
        errorMap: (u, d) => {
            var f, h;
            const {message: m} = n;
            return u.code === "invalid_enum_value" ? {
                message: m ?? d.defaultError
            } : typeof d.data > "u" ? {
                message: (f = m ?? r) !== null && f !== void 0 ? f : d.defaultError
            } : u.code !== "invalid_type" ? {
                message: d.defaultError
            } : {
                message: (h = m ?? t) !== null && h !== void 0 ? h : d.defaultError
            }
        }
        ,
        description: s
    }
}
class tn {
    get description() {
        return this._def.description
    }
    _getType(e) {
        return us(e.data)
    }
    _getOrReturnCtx(e, t) {
        return t || {
            common: e.parent.common,
            data: e.data,
            parsedType: us(e.data),
            schemaErrorMap: this._def.errorMap,
            path: e.path,
            parent: e.parent
        }
    }
    _processInputParams(e) {
        return {
            status: new Ti,
            ctx: {
                common: e.parent.common,
                data: e.data,
                parsedType: us(e.data),
                schemaErrorMap: this._def.errorMap,
                path: e.path,
                parent: e.parent
            }
        }
    }
    _parseSync(e) {
        const t = this._parse(e);
        if (Uf(t))
            throw new Error("Synchronous parse encountered promise.");
        return t
    }
    _parseAsync(e) {
        const t = this._parse(e);
        return Promise.resolve(t)
    }
    parse(e, t) {
        const r = this.safeParse(e, t);
        if (r.success)
            return r.data;
        throw r.error
    }
    safeParse(e, t) {
        var r;
        const s = {
            common: {
                issues: [],
                async: (r = t == null ? void 0 : t.async) !== null && r !== void 0 ? r : !1,
                contextualErrorMap: t == null ? void 0 : t.errorMap
            },
            path: (t == null ? void 0 : t.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: e,
            parsedType: us(e)
        }
          , o = this._parseSync({
            data: e,
            path: s.path,
            parent: s
        });
        return EE(s, o)
    }
    "~validate"(e) {
        var t, r;
        const s = {
            common: {
                issues: [],
                async: !!this["~standard"].async
            },
            path: [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: e,
            parsedType: us(e)
        };
        if (!this["~standard"].async)
            try {
                const o = this._parseSync({
                    data: e,
                    path: [],
                    parent: s
                });
                return yl(o) ? {
                    value: o.value
                } : {
                    issues: s.common.issues
                }
            } catch (o) {
                !((r = (t = o == null ? void 0 : o.message) === null || t === void 0 ? void 0 : t.toLowerCase()) === null || r === void 0) && r.includes("encountered") && (this["~standard"].async = !0),
                s.common = {
                    issues: [],
                    async: !0
                }
            }
        return this._parseAsync({
            data: e,
            path: [],
            parent: s
        }).then(o => yl(o) ? {
            value: o.value
        } : {
            issues: s.common.issues
        })
    }
    async parseAsync(e, t) {
        const r = await this.safeParseAsync(e, t);
        if (r.success)
            return r.data;
        throw r.error
    }
    async safeParseAsync(e, t) {
        const r = {
            common: {
                issues: [],
                contextualErrorMap: t == null ? void 0 : t.errorMap,
                async: !0
            },
            path: (t == null ? void 0 : t.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: e,
            parsedType: us(e)
        }
          , s = this._parse({
            data: e,
            path: r.path,
            parent: r
        })
          , o = await (Uf(s) ? s : Promise.resolve(s));
        return EE(r, o)
    }
    refine(e, t) {
        const r = s => typeof t == "string" || typeof t > "u" ? {
            message: t
        } : typeof t == "function" ? t(s) : t;
        return this._refinement( (s, o) => {
            const u = e(s)
              , d = () => o.addIssue({
                code: Fe.custom,
                ...r(s)
            });
            return typeof Promise < "u" && u instanceof Promise ? u.then(f => f ? !0 : (d(),
            !1)) : u ? !0 : (d(),
            !1)
        }
        )
    }
    refinement(e, t) {
        return this._refinement( (r, s) => e(r) ? !0 : (s.addIssue(typeof t == "function" ? t(r, s) : t),
        !1))
    }
    _refinement(e) {
        return new Ca({
            schema: this,
            typeName: Ot.ZodEffects,
            effect: {
                type: "refinement",
                refinement: e
            }
        })
    }
    superRefine(e) {
        return this._refinement(e)
    }
    constructor(e) {
        this.spa = this.safeParseAsync,
        this._def = e,
        this.parse = this.parse.bind(this),
        this.safeParse = this.safeParse.bind(this),
        this.parseAsync = this.parseAsync.bind(this),
        this.safeParseAsync = this.safeParseAsync.bind(this),
        this.spa = this.spa.bind(this),
        this.refine = this.refine.bind(this),
        this.refinement = this.refinement.bind(this),
        this.superRefine = this.superRefine.bind(this),
        this.optional = this.optional.bind(this),
        this.nullable = this.nullable.bind(this),
        this.nullish = this.nullish.bind(this),
        this.array = this.array.bind(this),
        this.promise = this.promise.bind(this),
        this.or = this.or.bind(this),
        this.and = this.and.bind(this),
        this.transform = this.transform.bind(this),
        this.brand = this.brand.bind(this),
        this.default = this.default.bind(this),
        this.catch = this.catch.bind(this),
        this.describe = this.describe.bind(this),
        this.pipe = this.pipe.bind(this),
        this.readonly = this.readonly.bind(this),
        this.isNullable = this.isNullable.bind(this),
        this.isOptional = this.isOptional.bind(this),
        this["~standard"] = {
            version: 1,
            vendor: "zod",
            validate: t => this["~validate"](t)
        }
    }
    optional() {
        return Ma.create(this, this._def)
    }
    nullable() {
        return ao.create(this, this._def)
    }
    nullish() {
        return this.nullable().optional()
    }
    array() {
        return Pr.create(this)
    }
    promise() {
        return au.create(this, this._def)
    }
    or(e) {
        return Pf.create([this, e], this._def)
    }
    and(e) {
        return If.create(this, e, this._def)
    }
    transform(e) {
        return new Ca({
            ...Ft(this._def),
            schema: this,
            typeName: Ot.ZodEffects,
            effect: {
                type: "transform",
                transform: e
            }
        })
    }
    default(e) {
        const t = typeof e == "function" ? e : () => e;
        return new Vf({
            ...Ft(this._def),
            innerType: this,
            defaultValue: t,
            typeName: Ot.ZodDefault
        })
    }
    brand() {
        return new nT({
            typeName: Ot.ZodBranded,
            type: this,
            ...Ft(this._def)
        })
    }
    catch(e) {
        const t = typeof e == "function" ? e : () => e;
        return new Hf({
            ...Ft(this._def),
            innerType: this,
            catchValue: t,
            typeName: Ot.ZodCatch
        })
    }
    describe(e) {
        const t = this.constructor;
        return new t({
            ...this._def,
            description: e
        })
    }
    pipe(e) {
        return lh.create(this, e)
    }
    readonly() {
        return Gf.create(this)
    }
    isOptional() {
        return this.safeParse(void 0).success
    }
    isNullable() {
        return this.safeParse(null).success
    }
}
const _k = /^c[^\s-]{8,}$/i
  , yk = /^[0-9a-z]+$/
  , xk = /^[0-9A-HJKMNP-TV-Z]{26}$/i
  , bk = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i
  , Sk = /^[a-z0-9_-]{21}$/i
  , Ek = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
  , Mk = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/
  , wk = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i
  , Tk = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let vg;
const Ak = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/
  , Rk = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/
  , Ck = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/
  , Dk = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/
  , Uk = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/
  , Lk = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/
  , Jw = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))"
  , Nk = new RegExp(`^${Jw}$`);
function eT(n) {
    let e = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
    return n.precision ? e = `${e}\\.\\d{${n.precision}}` : n.precision == null && (e = `${e}(\\.\\d+)?`),
    e
}
function Ok(n) {
    return new RegExp(`^${eT(n)}$`)
}
function Pk(n) {
    let e = `${Jw}T${eT(n)}`;
    const t = [];
    return t.push(n.local ? "Z?" : "Z"),
    n.offset && t.push("([+-]\\d{2}:?\\d{2})"),
    e = `${e}(${t.join("|")})`,
    new RegExp(`^${e}$`)
}
function Ik(n, e) {
    return !!((e === "v4" || !e) && Ak.test(n) || (e === "v6" || !e) && Ck.test(n))
}
function zk(n, e) {
    if (!Ek.test(n))
        return !1;
    try {
        const [t] = n.split(".")
          , r = t.replace(/-/g, "+").replace(/_/g, "/").padEnd(t.length + (4 - t.length % 4) % 4, "=")
          , s = JSON.parse(atob(r));
        return !(typeof s != "object" || s === null || !s.typ || !s.alg || e && s.alg !== e)
    } catch {
        return !1
    }
}
function kk(n, e) {
    return !!((e === "v4" || !e) && Rk.test(n) || (e === "v6" || !e) && Dk.test(n))
}
class Sa extends tn {
    _parse(e) {
        if (this._def.coerce && (e.data = String(e.data)),
        this._getType(e) !== st.string) {
            const o = this._getOrReturnCtx(e);
            return tt(o, {
                code: Fe.invalid_type,
                expected: st.string,
                received: o.parsedType
            }),
            It
        }
        const r = new Ti;
        let s;
        for (const o of this._def.checks)
            if (o.kind === "min")
                e.data.length < o.value && (s = this._getOrReturnCtx(e, s),
                tt(s, {
                    code: Fe.too_small,
                    minimum: o.value,
                    type: "string",
                    inclusive: !0,
                    exact: !1,
                    message: o.message
                }),
                r.dirty());
            else if (o.kind === "max")
                e.data.length > o.value && (s = this._getOrReturnCtx(e, s),
                tt(s, {
                    code: Fe.too_big,
                    maximum: o.value,
                    type: "string",
                    inclusive: !0,
                    exact: !1,
                    message: o.message
                }),
                r.dirty());
            else if (o.kind === "length") {
                const u = e.data.length > o.value
                  , d = e.data.length < o.value;
                (u || d) && (s = this._getOrReturnCtx(e, s),
                u ? tt(s, {
                    code: Fe.too_big,
                    maximum: o.value,
                    type: "string",
                    inclusive: !0,
                    exact: !0,
                    message: o.message
                }) : d && tt(s, {
                    code: Fe.too_small,
                    minimum: o.value,
                    type: "string",
                    inclusive: !0,
                    exact: !0,
                    message: o.message
                }),
                r.dirty())
            } else if (o.kind === "email")
                wk.test(e.data) || (s = this._getOrReturnCtx(e, s),
                tt(s, {
                    validation: "email",
                    code: Fe.invalid_string,
                    message: o.message
                }),
                r.dirty());
            else if (o.kind === "emoji")
                vg || (vg = new RegExp(Tk,"u")),
                vg.test(e.data) || (s = this._getOrReturnCtx(e, s),
                tt(s, {
                    validation: "emoji",
                    code: Fe.invalid_string,
                    message: o.message
                }),
                r.dirty());
            else if (o.kind === "uuid")
                bk.test(e.data) || (s = this._getOrReturnCtx(e, s),
                tt(s, {
                    validation: "uuid",
                    code: Fe.invalid_string,
                    message: o.message
                }),
                r.dirty());
            else if (o.kind === "nanoid")
                Sk.test(e.data) || (s = this._getOrReturnCtx(e, s),
                tt(s, {
                    validation: "nanoid",
                    code: Fe.invalid_string,
                    message: o.message
                }),
                r.dirty());
            else if (o.kind === "cuid")
                _k.test(e.data) || (s = this._getOrReturnCtx(e, s),
                tt(s, {
                    validation: "cuid",
                    code: Fe.invalid_string,
                    message: o.message
                }),
                r.dirty());
            else if (o.kind === "cuid2")
                yk.test(e.data) || (s = this._getOrReturnCtx(e, s),
                tt(s, {
                    validation: "cuid2",
                    code: Fe.invalid_string,
                    message: o.message
                }),
                r.dirty());
            else if (o.kind === "ulid")
                xk.test(e.data) || (s = this._getOrReturnCtx(e, s),
                tt(s, {
                    validation: "ulid",
                    code: Fe.invalid_string,
                    message: o.message
                }),
                r.dirty());
            else if (o.kind === "url")
                try {
                    new URL(e.data)
                } catch {
                    s = this._getOrReturnCtx(e, s),
                    tt(s, {
                        validation: "url",
                        code: Fe.invalid_string,
                        message: o.message
                    }),
                    r.dirty()
                }
            else
                o.kind === "regex" ? (o.regex.lastIndex = 0,
                o.regex.test(e.data) || (s = this._getOrReturnCtx(e, s),
                tt(s, {
                    validation: "regex",
                    code: Fe.invalid_string,
                    message: o.message
                }),
                r.dirty())) : o.kind === "trim" ? e.data = e.data.trim() : o.kind === "includes" ? e.data.includes(o.value, o.position) || (s = this._getOrReturnCtx(e, s),
                tt(s, {
                    code: Fe.invalid_string,
                    validation: {
                        includes: o.value,
                        position: o.position
                    },
                    message: o.message
                }),
                r.dirty()) : o.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : o.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : o.kind === "startsWith" ? e.data.startsWith(o.value) || (s = this._getOrReturnCtx(e, s),
                tt(s, {
                    code: Fe.invalid_string,
                    validation: {
                        startsWith: o.value
                    },
                    message: o.message
                }),
                r.dirty()) : o.kind === "endsWith" ? e.data.endsWith(o.value) || (s = this._getOrReturnCtx(e, s),
                tt(s, {
                    code: Fe.invalid_string,
                    validation: {
                        endsWith: o.value
                    },
                    message: o.message
                }),
                r.dirty()) : o.kind === "datetime" ? Pk(o).test(e.data) || (s = this._getOrReturnCtx(e, s),
                tt(s, {
                    code: Fe.invalid_string,
                    validation: "datetime",
                    message: o.message
                }),
                r.dirty()) : o.kind === "date" ? Nk.test(e.data) || (s = this._getOrReturnCtx(e, s),
                tt(s, {
                    code: Fe.invalid_string,
                    validation: "date",
                    message: o.message
                }),
                r.dirty()) : o.kind === "time" ? Ok(o).test(e.data) || (s = this._getOrReturnCtx(e, s),
                tt(s, {
                    code: Fe.invalid_string,
                    validation: "time",
                    message: o.message
                }),
                r.dirty()) : o.kind === "duration" ? Mk.test(e.data) || (s = this._getOrReturnCtx(e, s),
                tt(s, {
                    validation: "duration",
                    code: Fe.invalid_string,
                    message: o.message
                }),
                r.dirty()) : o.kind === "ip" ? Ik(e.data, o.version) || (s = this._getOrReturnCtx(e, s),
                tt(s, {
                    validation: "ip",
                    code: Fe.invalid_string,
                    message: o.message
                }),
                r.dirty()) : o.kind === "jwt" ? zk(e.data, o.alg) || (s = this._getOrReturnCtx(e, s),
                tt(s, {
                    validation: "jwt",
                    code: Fe.invalid_string,
                    message: o.message
                }),
                r.dirty()) : o.kind === "cidr" ? kk(e.data, o.version) || (s = this._getOrReturnCtx(e, s),
                tt(s, {
                    validation: "cidr",
                    code: Fe.invalid_string,
                    message: o.message
                }),
                r.dirty()) : o.kind === "base64" ? Uk.test(e.data) || (s = this._getOrReturnCtx(e, s),
                tt(s, {
                    validation: "base64",
                    code: Fe.invalid_string,
                    message: o.message
                }),
                r.dirty()) : o.kind === "base64url" ? Lk.test(e.data) || (s = this._getOrReturnCtx(e, s),
                tt(s, {
                    validation: "base64url",
                    code: Fe.invalid_string,
                    message: o.message
                }),
                r.dirty()) : un.assertNever(o);
        return {
            status: r.value,
            value: e.data
        }
    }
    _regex(e, t, r) {
        return this.refinement(s => e.test(s), {
            validation: t,
            code: Fe.invalid_string,
            ...vt.errToObj(r)
        })
    }
    _addCheck(e) {
        return new Sa({
            ...this._def,
            checks: [...this._def.checks, e]
        })
    }
    email(e) {
        return this._addCheck({
            kind: "email",
            ...vt.errToObj(e)
        })
    }
    url(e) {
        return this._addCheck({
            kind: "url",
            ...vt.errToObj(e)
        })
    }
    emoji(e) {
        return this._addCheck({
            kind: "emoji",
            ...vt.errToObj(e)
        })
    }
    uuid(e) {
        return this._addCheck({
            kind: "uuid",
            ...vt.errToObj(e)
        })
    }
    nanoid(e) {
        return this._addCheck({
            kind: "nanoid",
            ...vt.errToObj(e)
        })
    }
    cuid(e) {
        return this._addCheck({
            kind: "cuid",
            ...vt.errToObj(e)
        })
    }
    cuid2(e) {
        return this._addCheck({
            kind: "cuid2",
            ...vt.errToObj(e)
        })
    }
    ulid(e) {
        return this._addCheck({
            kind: "ulid",
            ...vt.errToObj(e)
        })
    }
    base64(e) {
        return this._addCheck({
            kind: "base64",
            ...vt.errToObj(e)
        })
    }
    base64url(e) {
        return this._addCheck({
            kind: "base64url",
            ...vt.errToObj(e)
        })
    }
    jwt(e) {
        return this._addCheck({
            kind: "jwt",
            ...vt.errToObj(e)
        })
    }
    ip(e) {
        return this._addCheck({
            kind: "ip",
            ...vt.errToObj(e)
        })
    }
    cidr(e) {
        return this._addCheck({
            kind: "cidr",
            ...vt.errToObj(e)
        })
    }
    datetime(e) {
        var t, r;
        return typeof e == "string" ? this._addCheck({
            kind: "datetime",
            precision: null,
            offset: !1,
            local: !1,
            message: e
        }) : this._addCheck({
            kind: "datetime",
            precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
            offset: (t = e == null ? void 0 : e.offset) !== null && t !== void 0 ? t : !1,
            local: (r = e == null ? void 0 : e.local) !== null && r !== void 0 ? r : !1,
            ...vt.errToObj(e == null ? void 0 : e.message)
        })
    }
    date(e) {
        return this._addCheck({
            kind: "date",
            message: e
        })
    }
    time(e) {
        return typeof e == "string" ? this._addCheck({
            kind: "time",
            precision: null,
            message: e
        }) : this._addCheck({
            kind: "time",
            precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
            ...vt.errToObj(e == null ? void 0 : e.message)
        })
    }
    duration(e) {
        return this._addCheck({
            kind: "duration",
            ...vt.errToObj(e)
        })
    }
    regex(e, t) {
        return this._addCheck({
            kind: "regex",
            regex: e,
            ...vt.errToObj(t)
        })
    }
    includes(e, t) {
        return this._addCheck({
            kind: "includes",
            value: e,
            position: t == null ? void 0 : t.position,
            ...vt.errToObj(t == null ? void 0 : t.message)
        })
    }
    startsWith(e, t) {
        return this._addCheck({
            kind: "startsWith",
            value: e,
            ...vt.errToObj(t)
        })
    }
    endsWith(e, t) {
        return this._addCheck({
            kind: "endsWith",
            value: e,
            ...vt.errToObj(t)
        })
    }
    min(e, t) {
        return this._addCheck({
            kind: "min",
            value: e,
            ...vt.errToObj(t)
        })
    }
    max(e, t) {
        return this._addCheck({
            kind: "max",
            value: e,
            ...vt.errToObj(t)
        })
    }
    length(e, t) {
        return this._addCheck({
            kind: "length",
            value: e,
            ...vt.errToObj(t)
        })
    }
    nonempty(e) {
        return this.min(1, vt.errToObj(e))
    }
    trim() {
        return new Sa({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "trim"
            }]
        })
    }
    toLowerCase() {
        return new Sa({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "toLowerCase"
            }]
        })
    }
    toUpperCase() {
        return new Sa({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "toUpperCase"
            }]
        })
    }
    get isDatetime() {
        return !!this._def.checks.find(e => e.kind === "datetime")
    }
    get isDate() {
        return !!this._def.checks.find(e => e.kind === "date")
    }
    get isTime() {
        return !!this._def.checks.find(e => e.kind === "time")
    }
    get isDuration() {
        return !!this._def.checks.find(e => e.kind === "duration")
    }
    get isEmail() {
        return !!this._def.checks.find(e => e.kind === "email")
    }
    get isURL() {
        return !!this._def.checks.find(e => e.kind === "url")
    }
    get isEmoji() {
        return !!this._def.checks.find(e => e.kind === "emoji")
    }
    get isUUID() {
        return !!this._def.checks.find(e => e.kind === "uuid")
    }
    get isNANOID() {
        return !!this._def.checks.find(e => e.kind === "nanoid")
    }
    get isCUID() {
        return !!this._def.checks.find(e => e.kind === "cuid")
    }
    get isCUID2() {
        return !!this._def.checks.find(e => e.kind === "cuid2")
    }
    get isULID() {
        return !!this._def.checks.find(e => e.kind === "ulid")
    }
    get isIP() {
        return !!this._def.checks.find(e => e.kind === "ip")
    }
    get isCIDR() {
        return !!this._def.checks.find(e => e.kind === "cidr")
    }
    get isBase64() {
        return !!this._def.checks.find(e => e.kind === "base64")
    }
    get isBase64url() {
        return !!this._def.checks.find(e => e.kind === "base64url")
    }
    get minLength() {
        let e = null;
        for (const t of this._def.checks)
            t.kind === "min" && (e === null || t.value > e) && (e = t.value);
        return e
    }
    get maxLength() {
        let e = null;
        for (const t of this._def.checks)
            t.kind === "max" && (e === null || t.value < e) && (e = t.value);
        return e
    }
}
Sa.create = n => {
    var e;
    return new Sa({
        checks: [],
        typeName: Ot.ZodString,
        coerce: (e = n == null ? void 0 : n.coerce) !== null && e !== void 0 ? e : !1,
        ...Ft(n)
    })
}
;
function Fk(n, e) {
    const t = (n.toString().split(".")[1] || "").length
      , r = (e.toString().split(".")[1] || "").length
      , s = t > r ? t : r
      , o = parseInt(n.toFixed(s).replace(".", ""))
      , u = parseInt(e.toFixed(s).replace(".", ""));
    return o % u / Math.pow(10, s)
}
class xl extends tn {
    constructor() {
        super(...arguments),
        this.min = this.gte,
        this.max = this.lte,
        this.step = this.multipleOf
    }
    _parse(e) {
        if (this._def.coerce && (e.data = Number(e.data)),
        this._getType(e) !== st.number) {
            const o = this._getOrReturnCtx(e);
            return tt(o, {
                code: Fe.invalid_type,
                expected: st.number,
                received: o.parsedType
            }),
            It
        }
        let r;
        const s = new Ti;
        for (const o of this._def.checks)
            o.kind === "int" ? un.isInteger(e.data) || (r = this._getOrReturnCtx(e, r),
            tt(r, {
                code: Fe.invalid_type,
                expected: "integer",
                received: "float",
                message: o.message
            }),
            s.dirty()) : o.kind === "min" ? (o.inclusive ? e.data < o.value : e.data <= o.value) && (r = this._getOrReturnCtx(e, r),
            tt(r, {
                code: Fe.too_small,
                minimum: o.value,
                type: "number",
                inclusive: o.inclusive,
                exact: !1,
                message: o.message
            }),
            s.dirty()) : o.kind === "max" ? (o.inclusive ? e.data > o.value : e.data >= o.value) && (r = this._getOrReturnCtx(e, r),
            tt(r, {
                code: Fe.too_big,
                maximum: o.value,
                type: "number",
                inclusive: o.inclusive,
                exact: !1,
                message: o.message
            }),
            s.dirty()) : o.kind === "multipleOf" ? Fk(e.data, o.value) !== 0 && (r = this._getOrReturnCtx(e, r),
            tt(r, {
                code: Fe.not_multiple_of,
                multipleOf: o.value,
                message: o.message
            }),
            s.dirty()) : o.kind === "finite" ? Number.isFinite(e.data) || (r = this._getOrReturnCtx(e, r),
            tt(r, {
                code: Fe.not_finite,
                message: o.message
            }),
            s.dirty()) : un.assertNever(o);
        return {
            status: s.value,
            value: e.data
        }
    }
    gte(e, t) {
        return this.setLimit("min", e, !0, vt.toString(t))
    }
    gt(e, t) {
        return this.setLimit("min", e, !1, vt.toString(t))
    }
    lte(e, t) {
        return this.setLimit("max", e, !0, vt.toString(t))
    }
    lt(e, t) {
        return this.setLimit("max", e, !1, vt.toString(t))
    }
    setLimit(e, t, r, s) {
        return new xl({
            ...this._def,
            checks: [...this._def.checks, {
                kind: e,
                value: t,
                inclusive: r,
                message: vt.toString(s)
            }]
        })
    }
    _addCheck(e) {
        return new xl({
            ...this._def,
            checks: [...this._def.checks, e]
        })
    }
    int(e) {
        return this._addCheck({
            kind: "int",
            message: vt.toString(e)
        })
    }
    positive(e) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !1,
            message: vt.toString(e)
        })
    }
    negative(e) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !1,
            message: vt.toString(e)
        })
    }
    nonpositive(e) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !0,
            message: vt.toString(e)
        })
    }
    nonnegative(e) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !0,
            message: vt.toString(e)
        })
    }
    multipleOf(e, t) {
        return this._addCheck({
            kind: "multipleOf",
            value: e,
            message: vt.toString(t)
        })
    }
    finite(e) {
        return this._addCheck({
            kind: "finite",
            message: vt.toString(e)
        })
    }
    safe(e) {
        return this._addCheck({
            kind: "min",
            inclusive: !0,
            value: Number.MIN_SAFE_INTEGER,
            message: vt.toString(e)
        })._addCheck({
            kind: "max",
            inclusive: !0,
            value: Number.MAX_SAFE_INTEGER,
            message: vt.toString(e)
        })
    }
    get minValue() {
        let e = null;
        for (const t of this._def.checks)
            t.kind === "min" && (e === null || t.value > e) && (e = t.value);
        return e
    }
    get maxValue() {
        let e = null;
        for (const t of this._def.checks)
            t.kind === "max" && (e === null || t.value < e) && (e = t.value);
        return e
    }
    get isInt() {
        return !!this._def.checks.find(e => e.kind === "int" || e.kind === "multipleOf" && un.isInteger(e.value))
    }
    get isFinite() {
        let e = null
          , t = null;
        for (const r of this._def.checks) {
            if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
                return !0;
            r.kind === "min" ? (t === null || r.value > t) && (t = r.value) : r.kind === "max" && (e === null || r.value < e) && (e = r.value)
        }
        return Number.isFinite(t) && Number.isFinite(e)
    }
}
xl.create = n => new xl({
    checks: [],
    typeName: Ot.ZodNumber,
    coerce: (n == null ? void 0 : n.coerce) || !1,
    ...Ft(n)
});
class bl extends tn {
    constructor() {
        super(...arguments),
        this.min = this.gte,
        this.max = this.lte
    }
    _parse(e) {
        if (this._def.coerce)
            try {
                e.data = BigInt(e.data)
            } catch {
                return this._getInvalidInput(e)
            }
        if (this._getType(e) !== st.bigint)
            return this._getInvalidInput(e);
        let r;
        const s = new Ti;
        for (const o of this._def.checks)
            o.kind === "min" ? (o.inclusive ? e.data < o.value : e.data <= o.value) && (r = this._getOrReturnCtx(e, r),
            tt(r, {
                code: Fe.too_small,
                type: "bigint",
                minimum: o.value,
                inclusive: o.inclusive,
                message: o.message
            }),
            s.dirty()) : o.kind === "max" ? (o.inclusive ? e.data > o.value : e.data >= o.value) && (r = this._getOrReturnCtx(e, r),
            tt(r, {
                code: Fe.too_big,
                type: "bigint",
                maximum: o.value,
                inclusive: o.inclusive,
                message: o.message
            }),
            s.dirty()) : o.kind === "multipleOf" ? e.data % o.value !== BigInt(0) && (r = this._getOrReturnCtx(e, r),
            tt(r, {
                code: Fe.not_multiple_of,
                multipleOf: o.value,
                message: o.message
            }),
            s.dirty()) : un.assertNever(o);
        return {
            status: s.value,
            value: e.data
        }
    }
    _getInvalidInput(e) {
        const t = this._getOrReturnCtx(e);
        return tt(t, {
            code: Fe.invalid_type,
            expected: st.bigint,
            received: t.parsedType
        }),
        It
    }
    gte(e, t) {
        return this.setLimit("min", e, !0, vt.toString(t))
    }
    gt(e, t) {
        return this.setLimit("min", e, !1, vt.toString(t))
    }
    lte(e, t) {
        return this.setLimit("max", e, !0, vt.toString(t))
    }
    lt(e, t) {
        return this.setLimit("max", e, !1, vt.toString(t))
    }
    setLimit(e, t, r, s) {
        return new bl({
            ...this._def,
            checks: [...this._def.checks, {
                kind: e,
                value: t,
                inclusive: r,
                message: vt.toString(s)
            }]
        })
    }
    _addCheck(e) {
        return new bl({
            ...this._def,
            checks: [...this._def.checks, e]
        })
    }
    positive(e) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !1,
            message: vt.toString(e)
        })
    }
    negative(e) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !1,
            message: vt.toString(e)
        })
    }
    nonpositive(e) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !0,
            message: vt.toString(e)
        })
    }
    nonnegative(e) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !0,
            message: vt.toString(e)
        })
    }
    multipleOf(e, t) {
        return this._addCheck({
            kind: "multipleOf",
            value: e,
            message: vt.toString(t)
        })
    }
    get minValue() {
        let e = null;
        for (const t of this._def.checks)
            t.kind === "min" && (e === null || t.value > e) && (e = t.value);
        return e
    }
    get maxValue() {
        let e = null;
        for (const t of this._def.checks)
            t.kind === "max" && (e === null || t.value < e) && (e = t.value);
        return e
    }
}
bl.create = n => {
    var e;
    return new bl({
        checks: [],
        typeName: Ot.ZodBigInt,
        coerce: (e = n == null ? void 0 : n.coerce) !== null && e !== void 0 ? e : !1,
        ...Ft(n)
    })
}
;
class Ov extends tn {
    _parse(e) {
        if (this._def.coerce && (e.data = !!e.data),
        this._getType(e) !== st.boolean) {
            const r = this._getOrReturnCtx(e);
            return tt(r, {
                code: Fe.invalid_type,
                expected: st.boolean,
                received: r.parsedType
            }),
            It
        }
        return Oi(e.data)
    }
}
Ov.create = n => new Ov({
    typeName: Ot.ZodBoolean,
    coerce: (n == null ? void 0 : n.coerce) || !1,
    ...Ft(n)
});
class ru extends tn {
    _parse(e) {
        if (this._def.coerce && (e.data = new Date(e.data)),
        this._getType(e) !== st.date) {
            const o = this._getOrReturnCtx(e);
            return tt(o, {
                code: Fe.invalid_type,
                expected: st.date,
                received: o.parsedType
            }),
            It
        }
        if (isNaN(e.data.getTime())) {
            const o = this._getOrReturnCtx(e);
            return tt(o, {
                code: Fe.invalid_date
            }),
            It
        }
        const r = new Ti;
        let s;
        for (const o of this._def.checks)
            o.kind === "min" ? e.data.getTime() < o.value && (s = this._getOrReturnCtx(e, s),
            tt(s, {
                code: Fe.too_small,
                message: o.message,
                inclusive: !0,
                exact: !1,
                minimum: o.value,
                type: "date"
            }),
            r.dirty()) : o.kind === "max" ? e.data.getTime() > o.value && (s = this._getOrReturnCtx(e, s),
            tt(s, {
                code: Fe.too_big,
                message: o.message,
                inclusive: !0,
                exact: !1,
                maximum: o.value,
                type: "date"
            }),
            r.dirty()) : un.assertNever(o);
        return {
            status: r.value,
            value: new Date(e.data.getTime())
        }
    }
    _addCheck(e) {
        return new ru({
            ...this._def,
            checks: [...this._def.checks, e]
        })
    }
    min(e, t) {
        return this._addCheck({
            kind: "min",
            value: e.getTime(),
            message: vt.toString(t)
        })
    }
    max(e, t) {
        return this._addCheck({
            kind: "max",
            value: e.getTime(),
            message: vt.toString(t)
        })
    }
    get minDate() {
        let e = null;
        for (const t of this._def.checks)
            t.kind === "min" && (e === null || t.value > e) && (e = t.value);
        return e != null ? new Date(e) : null
    }
    get maxDate() {
        let e = null;
        for (const t of this._def.checks)
            t.kind === "max" && (e === null || t.value < e) && (e = t.value);
        return e != null ? new Date(e) : null
    }
}
ru.create = n => new ru({
    checks: [],
    coerce: (n == null ? void 0 : n.coerce) || !1,
    typeName: Ot.ZodDate,
    ...Ft(n)
});
class Pv extends tn {
    _parse(e) {
        if (this._getType(e) !== st.symbol) {
            const r = this._getOrReturnCtx(e);
            return tt(r, {
                code: Fe.invalid_type,
                expected: st.symbol,
                received: r.parsedType
            }),
            It
        }
        return Oi(e.data)
    }
}
Pv.create = n => new Pv({
    typeName: Ot.ZodSymbol,
    ...Ft(n)
});
class Nf extends tn {
    _parse(e) {
        if (this._getType(e) !== st.undefined) {
            const r = this._getOrReturnCtx(e);
            return tt(r, {
                code: Fe.invalid_type,
                expected: st.undefined,
                received: r.parsedType
            }),
            It
        }
        return Oi(e.data)
    }
}
Nf.create = n => new Nf({
    typeName: Ot.ZodUndefined,
    ...Ft(n)
});
class Of extends tn {
    _parse(e) {
        if (this._getType(e) !== st.null) {
            const r = this._getOrReturnCtx(e);
            return tt(r, {
                code: Fe.invalid_type,
                expected: st.null,
                received: r.parsedType
            }),
            It
        }
        return Oi(e.data)
    }
}
Of.create = n => new Of({
    typeName: Ot.ZodNull,
    ...Ft(n)
});
class Iv extends tn {
    constructor() {
        super(...arguments),
        this._any = !0
    }
    _parse(e) {
        return Oi(e.data)
    }
}
Iv.create = n => new Iv({
    typeName: Ot.ZodAny,
    ...Ft(n)
});
class fl extends tn {
    constructor() {
        super(...arguments),
        this._unknown = !0
    }
    _parse(e) {
        return Oi(e.data)
    }
}
fl.create = n => new fl({
    typeName: Ot.ZodUnknown,
    ...Ft(n)
});
class xs extends tn {
    _parse(e) {
        const t = this._getOrReturnCtx(e);
        return tt(t, {
            code: Fe.invalid_type,
            expected: st.never,
            received: t.parsedType
        }),
        It
    }
}
xs.create = n => new xs({
    typeName: Ot.ZodNever,
    ...Ft(n)
});
class zv extends tn {
    _parse(e) {
        if (this._getType(e) !== st.undefined) {
            const r = this._getOrReturnCtx(e);
            return tt(r, {
                code: Fe.invalid_type,
                expected: st.void,
                received: r.parsedType
            }),
            It
        }
        return Oi(e.data)
    }
}
zv.create = n => new zv({
    typeName: Ot.ZodVoid,
    ...Ft(n)
});
class Pr extends tn {
    _parse(e) {
        const {ctx: t, status: r} = this._processInputParams(e)
          , s = this._def;
        if (t.parsedType !== st.array)
            return tt(t, {
                code: Fe.invalid_type,
                expected: st.array,
                received: t.parsedType
            }),
            It;
        if (s.exactLength !== null) {
            const u = t.data.length > s.exactLength.value
              , d = t.data.length < s.exactLength.value;
            (u || d) && (tt(t, {
                code: u ? Fe.too_big : Fe.too_small,
                minimum: d ? s.exactLength.value : void 0,
                maximum: u ? s.exactLength.value : void 0,
                type: "array",
                inclusive: !0,
                exact: !0,
                message: s.exactLength.message
            }),
            r.dirty())
        }
        if (s.minLength !== null && t.data.length < s.minLength.value && (tt(t, {
            code: Fe.too_small,
            minimum: s.minLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: s.minLength.message
        }),
        r.dirty()),
        s.maxLength !== null && t.data.length > s.maxLength.value && (tt(t, {
            code: Fe.too_big,
            maximum: s.maxLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: s.maxLength.message
        }),
        r.dirty()),
        t.common.async)
            return Promise.all([...t.data].map( (u, d) => s.type._parseAsync(new zr(t,u,t.path,d)))).then(u => Ti.mergeArray(r, u));
        const o = [...t.data].map( (u, d) => s.type._parseSync(new zr(t,u,t.path,d)));
        return Ti.mergeArray(r, o)
    }
    get element() {
        return this._def.type
    }
    min(e, t) {
        return new Pr({
            ...this._def,
            minLength: {
                value: e,
                message: vt.toString(t)
            }
        })
    }
    max(e, t) {
        return new Pr({
            ...this._def,
            maxLength: {
                value: e,
                message: vt.toString(t)
            }
        })
    }
    length(e, t) {
        return new Pr({
            ...this._def,
            exactLength: {
                value: e,
                message: vt.toString(t)
            }
        })
    }
    nonempty(e) {
        return this.min(1, e)
    }
}
Pr.create = (n, e) => new Pr({
    type: n,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: Ot.ZodArray,
    ...Ft(e)
});
function ol(n) {
    if (n instanceof In) {
        const e = {};
        for (const t in n.shape) {
            const r = n.shape[t];
            e[t] = Ma.create(ol(r))
        }
        return new In({
            ...n._def,
            shape: () => e
        })
    } else
        return n instanceof Pr ? new Pr({
            ...n._def,
            type: ol(n.element)
        }) : n instanceof Ma ? Ma.create(ol(n.unwrap())) : n instanceof ao ? ao.create(ol(n.unwrap())) : n instanceof Ra ? Ra.create(n.items.map(e => ol(e))) : n
}
class In extends tn {
    constructor() {
        super(...arguments),
        this._cached = null,
        this.nonstrict = this.passthrough,
        this.augment = this.extend
    }
    _getCached() {
        if (this._cached !== null)
            return this._cached;
        const e = this._def.shape()
          , t = un.objectKeys(e);
        return this._cached = {
            shape: e,
            keys: t
        }
    }
    _parse(e) {
        if (this._getType(e) !== st.object) {
            const h = this._getOrReturnCtx(e);
            return tt(h, {
                code: Fe.invalid_type,
                expected: st.object,
                received: h.parsedType
            }),
            It
        }
        const {status: r, ctx: s} = this._processInputParams(e)
          , {shape: o, keys: u} = this._getCached()
          , d = [];
        if (!(this._def.catchall instanceof xs && this._def.unknownKeys === "strip"))
            for (const h in s.data)
                u.includes(h) || d.push(h);
        const f = [];
        for (const h of u) {
            const m = o[h]
              , g = s.data[h];
            f.push({
                key: {
                    status: "valid",
                    value: h
                },
                value: m._parse(new zr(s,g,s.path,h)),
                alwaysSet: h in s.data
            })
        }
        if (this._def.catchall instanceof xs) {
            const h = this._def.unknownKeys;
            if (h === "passthrough")
                for (const m of d)
                    f.push({
                        key: {
                            status: "valid",
                            value: m
                        },
                        value: {
                            status: "valid",
                            value: s.data[m]
                        }
                    });
            else if (h === "strict")
                d.length > 0 && (tt(s, {
                    code: Fe.unrecognized_keys,
                    keys: d
                }),
                r.dirty());
            else if (h !== "strip")
                throw new Error("Internal ZodObject error: invalid unknownKeys value.")
        } else {
            const h = this._def.catchall;
            for (const m of d) {
                const g = s.data[m];
                f.push({
                    key: {
                        status: "valid",
                        value: m
                    },
                    value: h._parse(new zr(s,g,s.path,m)),
                    alwaysSet: m in s.data
                })
            }
        }
        return s.common.async ? Promise.resolve().then(async () => {
            const h = [];
            for (const m of f) {
                const g = await m.key
                  , _ = await m.value;
                h.push({
                    key: g,
                    value: _,
                    alwaysSet: m.alwaysSet
                })
            }
            return h
        }
        ).then(h => Ti.mergeObjectSync(r, h)) : Ti.mergeObjectSync(r, f)
    }
    get shape() {
        return this._def.shape()
    }
    strict(e) {
        return vt.errToObj,
        new In({
            ...this._def,
            unknownKeys: "strict",
            ...e !== void 0 ? {
                errorMap: (t, r) => {
                    var s, o, u, d;
                    const f = (u = (o = (s = this._def).errorMap) === null || o === void 0 ? void 0 : o.call(s, t, r).message) !== null && u !== void 0 ? u : r.defaultError;
                    return t.code === "unrecognized_keys" ? {
                        message: (d = vt.errToObj(e).message) !== null && d !== void 0 ? d : f
                    } : {
                        message: f
                    }
                }
            } : {}
        })
    }
    strip() {
        return new In({
            ...this._def,
            unknownKeys: "strip"
        })
    }
    passthrough() {
        return new In({
            ...this._def,
            unknownKeys: "passthrough"
        })
    }
    extend(e) {
        return new In({
            ...this._def,
            shape: () => ({
                ...this._def.shape(),
                ...e
            })
        })
    }
    merge(e) {
        return new In({
            unknownKeys: e._def.unknownKeys,
            catchall: e._def.catchall,
            shape: () => ({
                ...this._def.shape(),
                ...e._def.shape()
            }),
            typeName: Ot.ZodObject
        })
    }
    setKey(e, t) {
        return this.augment({
            [e]: t
        })
    }
    catchall(e) {
        return new In({
            ...this._def,
            catchall: e
        })
    }
    pick(e) {
        const t = {};
        return un.objectKeys(e).forEach(r => {
            e[r] && this.shape[r] && (t[r] = this.shape[r])
        }
        ),
        new In({
            ...this._def,
            shape: () => t
        })
    }
    omit(e) {
        const t = {};
        return un.objectKeys(this.shape).forEach(r => {
            e[r] || (t[r] = this.shape[r])
        }
        ),
        new In({
            ...this._def,
            shape: () => t
        })
    }
    deepPartial() {
        return ol(this)
    }
    partial(e) {
        const t = {};
        return un.objectKeys(this.shape).forEach(r => {
            const s = this.shape[r];
            e && !e[r] ? t[r] = s : t[r] = s.optional()
        }
        ),
        new In({
            ...this._def,
            shape: () => t
        })
    }
    required(e) {
        const t = {};
        return un.objectKeys(this.shape).forEach(r => {
            if (e && !e[r])
                t[r] = this.shape[r];
            else {
                let o = this.shape[r];
                for (; o instanceof Ma; )
                    o = o._def.innerType;
                t[r] = o
            }
        }
        ),
        new In({
            ...this._def,
            shape: () => t
        })
    }
    keyof() {
        return tT(un.objectKeys(this.shape))
    }
}
In.create = (n, e) => new In({
    shape: () => n,
    unknownKeys: "strip",
    catchall: xs.create(),
    typeName: Ot.ZodObject,
    ...Ft(e)
});
In.strictCreate = (n, e) => new In({
    shape: () => n,
    unknownKeys: "strict",
    catchall: xs.create(),
    typeName: Ot.ZodObject,
    ...Ft(e)
});
In.lazycreate = (n, e) => new In({
    shape: n,
    unknownKeys: "strip",
    catchall: xs.create(),
    typeName: Ot.ZodObject,
    ...Ft(e)
});
class Pf extends tn {
    _parse(e) {
        const {ctx: t} = this._processInputParams(e)
          , r = this._def.options;
        function s(o) {
            for (const d of o)
                if (d.result.status === "valid")
                    return d.result;
            for (const d of o)
                if (d.result.status === "dirty")
                    return t.common.issues.push(...d.ctx.common.issues),
                    d.result;
            const u = o.map(d => new sr(d.ctx.common.issues));
            return tt(t, {
                code: Fe.invalid_union,
                unionErrors: u
            }),
            It
        }
        if (t.common.async)
            return Promise.all(r.map(async o => {
                const u = {
                    ...t,
                    common: {
                        ...t.common,
                        issues: []
                    },
                    parent: null
                };
                return {
                    result: await o._parseAsync({
                        data: t.data,
                        path: t.path,
                        parent: u
                    }),
                    ctx: u
                }
            }
            )).then(s);
        {
            let o;
            const u = [];
            for (const f of r) {
                const h = {
                    ...t,
                    common: {
                        ...t.common,
                        issues: []
                    },
                    parent: null
                }
                  , m = f._parseSync({
                    data: t.data,
                    path: t.path,
                    parent: h
                });
                if (m.status === "valid")
                    return m;
                m.status === "dirty" && !o && (o = {
                    result: m,
                    ctx: h
                }),
                h.common.issues.length && u.push(h.common.issues)
            }
            if (o)
                return t.common.issues.push(...o.ctx.common.issues),
                o.result;
            const d = u.map(f => new sr(f));
            return tt(t, {
                code: Fe.invalid_union,
                unionErrors: d
            }),
            It
        }
    }
    get options() {
        return this._def.options
    }
}
Pf.create = (n, e) => new Pf({
    options: n,
    typeName: Ot.ZodUnion,
    ...Ft(e)
});
const da = n => n instanceof kf ? da(n.schema) : n instanceof Ca ? da(n.innerType()) : n instanceof Ff ? [n.value] : n instanceof ro ? n.options : n instanceof Bf ? un.objectValues(n.enum) : n instanceof Vf ? da(n._def.innerType) : n instanceof Nf ? [void 0] : n instanceof Of ? [null] : n instanceof Ma ? [void 0, ...da(n.unwrap())] : n instanceof ao ? [null, ...da(n.unwrap())] : n instanceof nT || n instanceof Gf ? da(n.unwrap()) : n instanceof Hf ? da(n._def.innerType) : [];
class x_ extends tn {
    _parse(e) {
        const {ctx: t} = this._processInputParams(e);
        if (t.parsedType !== st.object)
            return tt(t, {
                code: Fe.invalid_type,
                expected: st.object,
                received: t.parsedType
            }),
            It;
        const r = this.discriminator
          , s = t.data[r]
          , o = this.optionsMap.get(s);
        return o ? t.common.async ? o._parseAsync({
            data: t.data,
            path: t.path,
            parent: t
        }) : o._parseSync({
            data: t.data,
            path: t.path,
            parent: t
        }) : (tt(t, {
            code: Fe.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [r]
        }),
        It)
    }
    get discriminator() {
        return this._def.discriminator
    }
    get options() {
        return this._def.options
    }
    get optionsMap() {
        return this._def.optionsMap
    }
    static create(e, t, r) {
        const s = new Map;
        for (const o of t) {
            const u = da(o.shape[e]);
            if (!u.length)
                throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`);
            for (const d of u) {
                if (s.has(d))
                    throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(d)}`);
                s.set(d, o)
            }
        }
        return new x_({
            typeName: Ot.ZodDiscriminatedUnion,
            discriminator: e,
            options: t,
            optionsMap: s,
            ...Ft(r)
        })
    }
}
function kv(n, e) {
    const t = us(n)
      , r = us(e);
    if (n === e)
        return {
            valid: !0,
            data: n
        };
    if (t === st.object && r === st.object) {
        const s = un.objectKeys(e)
          , o = un.objectKeys(n).filter(d => s.indexOf(d) !== -1)
          , u = {
            ...n,
            ...e
        };
        for (const d of o) {
            const f = kv(n[d], e[d]);
            if (!f.valid)
                return {
                    valid: !1
                };
            u[d] = f.data
        }
        return {
            valid: !0,
            data: u
        }
    } else if (t === st.array && r === st.array) {
        if (n.length !== e.length)
            return {
                valid: !1
            };
        const s = [];
        for (let o = 0; o < n.length; o++) {
            const u = n[o]
              , d = e[o]
              , f = kv(u, d);
            if (!f.valid)
                return {
                    valid: !1
                };
            s.push(f.data)
        }
        return {
            valid: !0,
            data: s
        }
    } else
        return t === st.date && r === st.date && +n == +e ? {
            valid: !0,
            data: n
        } : {
            valid: !1
        }
}
class If extends tn {
    _parse(e) {
        const {status: t, ctx: r} = this._processInputParams(e)
          , s = (o, u) => {
            if (bE(o) || bE(u))
                return It;
            const d = kv(o.value, u.value);
            return d.valid ? ((SE(o) || SE(u)) && t.dirty(),
            {
                status: t.value,
                value: d.data
            }) : (tt(r, {
                code: Fe.invalid_intersection_types
            }),
            It)
        }
        ;
        return r.common.async ? Promise.all([this._def.left._parseAsync({
            data: r.data,
            path: r.path,
            parent: r
        }), this._def.right._parseAsync({
            data: r.data,
            path: r.path,
            parent: r
        })]).then( ([o,u]) => s(o, u)) : s(this._def.left._parseSync({
            data: r.data,
            path: r.path,
            parent: r
        }), this._def.right._parseSync({
            data: r.data,
            path: r.path,
            parent: r
        }))
    }
}
If.create = (n, e, t) => new If({
    left: n,
    right: e,
    typeName: Ot.ZodIntersection,
    ...Ft(t)
});
class Ra extends tn {
    _parse(e) {
        const {status: t, ctx: r} = this._processInputParams(e);
        if (r.parsedType !== st.array)
            return tt(r, {
                code: Fe.invalid_type,
                expected: st.array,
                received: r.parsedType
            }),
            It;
        if (r.data.length < this._def.items.length)
            return tt(r, {
                code: Fe.too_small,
                minimum: this._def.items.length,
                inclusive: !0,
                exact: !1,
                type: "array"
            }),
            It;
        !this._def.rest && r.data.length > this._def.items.length && (tt(r, {
            code: Fe.too_big,
            maximum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }),
        t.dirty());
        const o = [...r.data].map( (u, d) => {
            const f = this._def.items[d] || this._def.rest;
            return f ? f._parse(new zr(r,u,r.path,d)) : null
        }
        ).filter(u => !!u);
        return r.common.async ? Promise.all(o).then(u => Ti.mergeArray(t, u)) : Ti.mergeArray(t, o)
    }
    get items() {
        return this._def.items
    }
    rest(e) {
        return new Ra({
            ...this._def,
            rest: e
        })
    }
}
Ra.create = (n, e) => {
    if (!Array.isArray(n))
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new Ra({
        items: n,
        typeName: Ot.ZodTuple,
        rest: null,
        ...Ft(e)
    })
}
;
class zf extends tn {
    get keySchema() {
        return this._def.keyType
    }
    get valueSchema() {
        return this._def.valueType
    }
    _parse(e) {
        const {status: t, ctx: r} = this._processInputParams(e);
        if (r.parsedType !== st.object)
            return tt(r, {
                code: Fe.invalid_type,
                expected: st.object,
                received: r.parsedType
            }),
            It;
        const s = []
          , o = this._def.keyType
          , u = this._def.valueType;
        for (const d in r.data)
            s.push({
                key: o._parse(new zr(r,d,r.path,d)),
                value: u._parse(new zr(r,r.data[d],r.path,d)),
                alwaysSet: d in r.data
            });
        return r.common.async ? Ti.mergeObjectAsync(t, s) : Ti.mergeObjectSync(t, s)
    }
    get element() {
        return this._def.valueType
    }
    static create(e, t, r) {
        return t instanceof tn ? new zf({
            keyType: e,
            valueType: t,
            typeName: Ot.ZodRecord,
            ...Ft(r)
        }) : new zf({
            keyType: Sa.create(),
            valueType: e,
            typeName: Ot.ZodRecord,
            ...Ft(t)
        })
    }
}
class Fv extends tn {
    get keySchema() {
        return this._def.keyType
    }
    get valueSchema() {
        return this._def.valueType
    }
    _parse(e) {
        const {status: t, ctx: r} = this._processInputParams(e);
        if (r.parsedType !== st.map)
            return tt(r, {
                code: Fe.invalid_type,
                expected: st.map,
                received: r.parsedType
            }),
            It;
        const s = this._def.keyType
          , o = this._def.valueType
          , u = [...r.data.entries()].map( ([d,f], h) => ({
            key: s._parse(new zr(r,d,r.path,[h, "key"])),
            value: o._parse(new zr(r,f,r.path,[h, "value"]))
        }));
        if (r.common.async) {
            const d = new Map;
            return Promise.resolve().then(async () => {
                for (const f of u) {
                    const h = await f.key
                      , m = await f.value;
                    if (h.status === "aborted" || m.status === "aborted")
                        return It;
                    (h.status === "dirty" || m.status === "dirty") && t.dirty(),
                    d.set(h.value, m.value)
                }
                return {
                    status: t.value,
                    value: d
                }
            }
            )
        } else {
            const d = new Map;
            for (const f of u) {
                const h = f.key
                  , m = f.value;
                if (h.status === "aborted" || m.status === "aborted")
                    return It;
                (h.status === "dirty" || m.status === "dirty") && t.dirty(),
                d.set(h.value, m.value)
            }
            return {
                status: t.value,
                value: d
            }
        }
    }
}
Fv.create = (n, e, t) => new Fv({
    valueType: e,
    keyType: n,
    typeName: Ot.ZodMap,
    ...Ft(t)
});
class Sl extends tn {
    _parse(e) {
        const {status: t, ctx: r} = this._processInputParams(e);
        if (r.parsedType !== st.set)
            return tt(r, {
                code: Fe.invalid_type,
                expected: st.set,
                received: r.parsedType
            }),
            It;
        const s = this._def;
        s.minSize !== null && r.data.size < s.minSize.value && (tt(r, {
            code: Fe.too_small,
            minimum: s.minSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: s.minSize.message
        }),
        t.dirty()),
        s.maxSize !== null && r.data.size > s.maxSize.value && (tt(r, {
            code: Fe.too_big,
            maximum: s.maxSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: s.maxSize.message
        }),
        t.dirty());
        const o = this._def.valueType;
        function u(f) {
            const h = new Set;
            for (const m of f) {
                if (m.status === "aborted")
                    return It;
                m.status === "dirty" && t.dirty(),
                h.add(m.value)
            }
            return {
                status: t.value,
                value: h
            }
        }
        const d = [...r.data.values()].map( (f, h) => o._parse(new zr(r,f,r.path,h)));
        return r.common.async ? Promise.all(d).then(f => u(f)) : u(d)
    }
    min(e, t) {
        return new Sl({
            ...this._def,
            minSize: {
                value: e,
                message: vt.toString(t)
            }
        })
    }
    max(e, t) {
        return new Sl({
            ...this._def,
            maxSize: {
                value: e,
                message: vt.toString(t)
            }
        })
    }
    size(e, t) {
        return this.min(e, t).max(e, t)
    }
    nonempty(e) {
        return this.min(1, e)
    }
}
Sl.create = (n, e) => new Sl({
    valueType: n,
    minSize: null,
    maxSize: null,
    typeName: Ot.ZodSet,
    ...Ft(e)
});
class Yc extends tn {
    constructor() {
        super(...arguments),
        this.validate = this.implement
    }
    _parse(e) {
        const {ctx: t} = this._processInputParams(e);
        if (t.parsedType !== st.function)
            return tt(t, {
                code: Fe.invalid_type,
                expected: st.function,
                received: t.parsedType
            }),
            It;
        function r(d, f) {
            return Nv({
                data: d,
                path: t.path,
                errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, Lv(), iu].filter(h => !!h),
                issueData: {
                    code: Fe.invalid_arguments,
                    argumentsError: f
                }
            })
        }
        function s(d, f) {
            return Nv({
                data: d,
                path: t.path,
                errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, Lv(), iu].filter(h => !!h),
                issueData: {
                    code: Fe.invalid_return_type,
                    returnTypeError: f
                }
            })
        }
        const o = {
            errorMap: t.common.contextualErrorMap
        }
          , u = t.data;
        if (this._def.returns instanceof au) {
            const d = this;
            return Oi(async function(...f) {
                const h = new sr([])
                  , m = await d._def.args.parseAsync(f, o).catch(x => {
                    throw h.addIssue(r(f, x)),
                    h
                }
                )
                  , g = await Reflect.apply(u, this, m);
                return await d._def.returns._def.type.parseAsync(g, o).catch(x => {
                    throw h.addIssue(s(g, x)),
                    h
                }
                )
            })
        } else {
            const d = this;
            return Oi(function(...f) {
                const h = d._def.args.safeParse(f, o);
                if (!h.success)
                    throw new sr([r(f, h.error)]);
                const m = Reflect.apply(u, this, h.data)
                  , g = d._def.returns.safeParse(m, o);
                if (!g.success)
                    throw new sr([s(m, g.error)]);
                return g.data
            })
        }
    }
    parameters() {
        return this._def.args
    }
    returnType() {
        return this._def.returns
    }
    args(...e) {
        return new Yc({
            ...this._def,
            args: Ra.create(e).rest(fl.create())
        })
    }
    returns(e) {
        return new Yc({
            ...this._def,
            returns: e
        })
    }
    implement(e) {
        return this.parse(e)
    }
    strictImplement(e) {
        return this.parse(e)
    }
    static create(e, t, r) {
        return new Yc({
            args: e || Ra.create([]).rest(fl.create()),
            returns: t || fl.create(),
            typeName: Ot.ZodFunction,
            ...Ft(r)
        })
    }
}
class kf extends tn {
    get schema() {
        return this._def.getter()
    }
    _parse(e) {
        const {ctx: t} = this._processInputParams(e);
        return this._def.getter()._parse({
            data: t.data,
            path: t.path,
            parent: t
        })
    }
}
kf.create = (n, e) => new kf({
    getter: n,
    typeName: Ot.ZodLazy,
    ...Ft(e)
});
class Ff extends tn {
    _parse(e) {
        if (e.data !== this._def.value) {
            const t = this._getOrReturnCtx(e);
            return tt(t, {
                received: t.data,
                code: Fe.invalid_literal,
                expected: this._def.value
            }),
            It
        }
        return {
            status: "valid",
            value: e.data
        }
    }
    get value() {
        return this._def.value
    }
}
Ff.create = (n, e) => new Ff({
    value: n,
    typeName: Ot.ZodLiteral,
    ...Ft(e)
});
function tT(n, e) {
    return new ro({
        values: n,
        typeName: Ot.ZodEnum,
        ...Ft(e)
    })
}
class ro extends tn {
    constructor() {
        super(...arguments),
        Bc.set(this, void 0)
    }
    _parse(e) {
        if (typeof e.data != "string") {
            const t = this._getOrReturnCtx(e)
              , r = this._def.values;
            return tt(t, {
                expected: un.joinValues(r),
                received: t.parsedType,
                code: Fe.invalid_type
            }),
            It
        }
        if (Lf(this, Bc) || Qw(this, Bc, new Set(this._def.values)),
        !Lf(this, Bc).has(e.data)) {
            const t = this._getOrReturnCtx(e)
              , r = this._def.values;
            return tt(t, {
                received: t.data,
                code: Fe.invalid_enum_value,
                options: r
            }),
            It
        }
        return Oi(e.data)
    }
    get options() {
        return this._def.values
    }
    get enum() {
        const e = {};
        for (const t of this._def.values)
            e[t] = t;
        return e
    }
    get Values() {
        const e = {};
        for (const t of this._def.values)
            e[t] = t;
        return e
    }
    get Enum() {
        const e = {};
        for (const t of this._def.values)
            e[t] = t;
        return e
    }
    extract(e, t=this._def) {
        return ro.create(e, {
            ...this._def,
            ...t
        })
    }
    exclude(e, t=this._def) {
        return ro.create(this.options.filter(r => !e.includes(r)), {
            ...this._def,
            ...t
        })
    }
}
Bc = new WeakMap;
ro.create = tT;
class Bf extends tn {
    constructor() {
        super(...arguments),
        Vc.set(this, void 0)
    }
    _parse(e) {
        const t = un.getValidEnumValues(this._def.values)
          , r = this._getOrReturnCtx(e);
        if (r.parsedType !== st.string && r.parsedType !== st.number) {
            const s = un.objectValues(t);
            return tt(r, {
                expected: un.joinValues(s),
                received: r.parsedType,
                code: Fe.invalid_type
            }),
            It
        }
        if (Lf(this, Vc) || Qw(this, Vc, new Set(un.getValidEnumValues(this._def.values))),
        !Lf(this, Vc).has(e.data)) {
            const s = un.objectValues(t);
            return tt(r, {
                received: r.data,
                code: Fe.invalid_enum_value,
                options: s
            }),
            It
        }
        return Oi(e.data)
    }
    get enum() {
        return this._def.values
    }
}
Vc = new WeakMap;
Bf.create = (n, e) => new Bf({
    values: n,
    typeName: Ot.ZodNativeEnum,
    ...Ft(e)
});
class au extends tn {
    unwrap() {
        return this._def.type
    }
    _parse(e) {
        const {ctx: t} = this._processInputParams(e);
        if (t.parsedType !== st.promise && t.common.async === !1)
            return tt(t, {
                code: Fe.invalid_type,
                expected: st.promise,
                received: t.parsedType
            }),
            It;
        const r = t.parsedType === st.promise ? t.data : Promise.resolve(t.data);
        return Oi(r.then(s => this._def.type.parseAsync(s, {
            path: t.path,
            errorMap: t.common.contextualErrorMap
        })))
    }
}
au.create = (n, e) => new au({
    type: n,
    typeName: Ot.ZodPromise,
    ...Ft(e)
});
class Ca extends tn {
    innerType() {
        return this._def.schema
    }
    sourceType() {
        return this._def.schema._def.typeName === Ot.ZodEffects ? this._def.schema.sourceType() : this._def.schema
    }
    _parse(e) {
        const {status: t, ctx: r} = this._processInputParams(e)
          , s = this._def.effect || null
          , o = {
            addIssue: u => {
                tt(r, u),
                u.fatal ? t.abort() : t.dirty()
            }
            ,
            get path() {
                return r.path
            }
        };
        if (o.addIssue = o.addIssue.bind(o),
        s.type === "preprocess") {
            const u = s.transform(r.data, o);
            if (r.common.async)
                return Promise.resolve(u).then(async d => {
                    if (t.value === "aborted")
                        return It;
                    const f = await this._def.schema._parseAsync({
                        data: d,
                        path: r.path,
                        parent: r
                    });
                    return f.status === "aborted" ? It : f.status === "dirty" || t.value === "dirty" ? Fc(f.value) : f
                }
                );
            {
                if (t.value === "aborted")
                    return It;
                const d = this._def.schema._parseSync({
                    data: u,
                    path: r.path,
                    parent: r
                });
                return d.status === "aborted" ? It : d.status === "dirty" || t.value === "dirty" ? Fc(d.value) : d
            }
        }
        if (s.type === "refinement") {
            const u = d => {
                const f = s.refinement(d, o);
                if (r.common.async)
                    return Promise.resolve(f);
                if (f instanceof Promise)
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                return d
            }
            ;
            if (r.common.async === !1) {
                const d = this._def.schema._parseSync({
                    data: r.data,
                    path: r.path,
                    parent: r
                });
                return d.status === "aborted" ? It : (d.status === "dirty" && t.dirty(),
                u(d.value),
                {
                    status: t.value,
                    value: d.value
                })
            } else
                return this._def.schema._parseAsync({
                    data: r.data,
                    path: r.path,
                    parent: r
                }).then(d => d.status === "aborted" ? It : (d.status === "dirty" && t.dirty(),
                u(d.value).then( () => ({
                    status: t.value,
                    value: d.value
                }))))
        }
        if (s.type === "transform")
            if (r.common.async === !1) {
                const u = this._def.schema._parseSync({
                    data: r.data,
                    path: r.path,
                    parent: r
                });
                if (!yl(u))
                    return u;
                const d = s.transform(u.value, o);
                if (d instanceof Promise)
                    throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
                return {
                    status: t.value,
                    value: d
                }
            } else
                return this._def.schema._parseAsync({
                    data: r.data,
                    path: r.path,
                    parent: r
                }).then(u => yl(u) ? Promise.resolve(s.transform(u.value, o)).then(d => ({
                    status: t.value,
                    value: d
                })) : u);
        un.assertNever(s)
    }
}
Ca.create = (n, e, t) => new Ca({
    schema: n,
    typeName: Ot.ZodEffects,
    effect: e,
    ...Ft(t)
});
Ca.createWithPreprocess = (n, e, t) => new Ca({
    schema: e,
    effect: {
        type: "preprocess",
        transform: n
    },
    typeName: Ot.ZodEffects,
    ...Ft(t)
});
class Ma extends tn {
    _parse(e) {
        return this._getType(e) === st.undefined ? Oi(void 0) : this._def.innerType._parse(e)
    }
    unwrap() {
        return this._def.innerType
    }
}
Ma.create = (n, e) => new Ma({
    innerType: n,
    typeName: Ot.ZodOptional,
    ...Ft(e)
});
class ao extends tn {
    _parse(e) {
        return this._getType(e) === st.null ? Oi(null) : this._def.innerType._parse(e)
    }
    unwrap() {
        return this._def.innerType
    }
}
ao.create = (n, e) => new ao({
    innerType: n,
    typeName: Ot.ZodNullable,
    ...Ft(e)
});
class Vf extends tn {
    _parse(e) {
        const {ctx: t} = this._processInputParams(e);
        let r = t.data;
        return t.parsedType === st.undefined && (r = this._def.defaultValue()),
        this._def.innerType._parse({
            data: r,
            path: t.path,
            parent: t
        })
    }
    removeDefault() {
        return this._def.innerType
    }
}
Vf.create = (n, e) => new Vf({
    innerType: n,
    typeName: Ot.ZodDefault,
    defaultValue: typeof e.default == "function" ? e.default : () => e.default,
    ...Ft(e)
});
class Hf extends tn {
    _parse(e) {
        const {ctx: t} = this._processInputParams(e)
          , r = {
            ...t,
            common: {
                ...t.common,
                issues: []
            }
        }
          , s = this._def.innerType._parse({
            data: r.data,
            path: r.path,
            parent: {
                ...r
            }
        });
        return Uf(s) ? s.then(o => ({
            status: "valid",
            value: o.status === "valid" ? o.value : this._def.catchValue({
                get error() {
                    return new sr(r.common.issues)
                },
                input: r.data
            })
        })) : {
            status: "valid",
            value: s.status === "valid" ? s.value : this._def.catchValue({
                get error() {
                    return new sr(r.common.issues)
                },
                input: r.data
            })
        }
    }
    removeCatch() {
        return this._def.innerType
    }
}
Hf.create = (n, e) => new Hf({
    innerType: n,
    typeName: Ot.ZodCatch,
    catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
    ...Ft(e)
});
class Bv extends tn {
    _parse(e) {
        if (this._getType(e) !== st.nan) {
            const r = this._getOrReturnCtx(e);
            return tt(r, {
                code: Fe.invalid_type,
                expected: st.nan,
                received: r.parsedType
            }),
            It
        }
        return {
            status: "valid",
            value: e.data
        }
    }
}
Bv.create = n => new Bv({
    typeName: Ot.ZodNaN,
    ...Ft(n)
});
class nT extends tn {
    _parse(e) {
        const {ctx: t} = this._processInputParams(e)
          , r = t.data;
        return this._def.type._parse({
            data: r,
            path: t.path,
            parent: t
        })
    }
    unwrap() {
        return this._def.type
    }
}
class lh extends tn {
    _parse(e) {
        const {status: t, ctx: r} = this._processInputParams(e);
        if (r.common.async)
            return (async () => {
                const o = await this._def.in._parseAsync({
                    data: r.data,
                    path: r.path,
                    parent: r
                });
                return o.status === "aborted" ? It : o.status === "dirty" ? (t.dirty(),
                Fc(o.value)) : this._def.out._parseAsync({
                    data: o.value,
                    path: r.path,
                    parent: r
                })
            }
            )();
        {
            const s = this._def.in._parseSync({
                data: r.data,
                path: r.path,
                parent: r
            });
            return s.status === "aborted" ? It : s.status === "dirty" ? (t.dirty(),
            {
                status: "dirty",
                value: s.value
            }) : this._def.out._parseSync({
                data: s.value,
                path: r.path,
                parent: r
            })
        }
    }
    static create(e, t) {
        return new lh({
            in: e,
            out: t,
            typeName: Ot.ZodPipeline
        })
    }
}
class Gf extends tn {
    _parse(e) {
        const t = this._def.innerType._parse(e)
          , r = s => (yl(s) && (s.value = Object.freeze(s.value)),
        s);
        return Uf(t) ? t.then(s => r(s)) : r(t)
    }
    unwrap() {
        return this._def.innerType
    }
}
Gf.create = (n, e) => new Gf({
    innerType: n,
    typeName: Ot.ZodReadonly,
    ...Ft(e)
});
In.lazycreate;
var Ot;
(function(n) {
    n.ZodString = "ZodString",
    n.ZodNumber = "ZodNumber",
    n.ZodNaN = "ZodNaN",
    n.ZodBigInt = "ZodBigInt",
    n.ZodBoolean = "ZodBoolean",
    n.ZodDate = "ZodDate",
    n.ZodSymbol = "ZodSymbol",
    n.ZodUndefined = "ZodUndefined",
    n.ZodNull = "ZodNull",
    n.ZodAny = "ZodAny",
    n.ZodUnknown = "ZodUnknown",
    n.ZodNever = "ZodNever",
    n.ZodVoid = "ZodVoid",
    n.ZodArray = "ZodArray",
    n.ZodObject = "ZodObject",
    n.ZodUnion = "ZodUnion",
    n.ZodDiscriminatedUnion = "ZodDiscriminatedUnion",
    n.ZodIntersection = "ZodIntersection",
    n.ZodTuple = "ZodTuple",
    n.ZodRecord = "ZodRecord",
    n.ZodMap = "ZodMap",
    n.ZodSet = "ZodSet",
    n.ZodFunction = "ZodFunction",
    n.ZodLazy = "ZodLazy",
    n.ZodLiteral = "ZodLiteral",
    n.ZodEnum = "ZodEnum",
    n.ZodEffects = "ZodEffects",
    n.ZodNativeEnum = "ZodNativeEnum",
    n.ZodOptional = "ZodOptional",
    n.ZodNullable = "ZodNullable",
    n.ZodDefault = "ZodDefault",
    n.ZodCatch = "ZodCatch",
    n.ZodPromise = "ZodPromise",
    n.ZodBranded = "ZodBranded",
    n.ZodPipeline = "ZodPipeline",
    n.ZodReadonly = "ZodReadonly"
}
)(Ot || (Ot = {}));
const va = Sa.create;
xl.create;
Bv.create;
bl.create;
Ov.create;
ru.create;
Pv.create;
Nf.create;
Of.create;
Iv.create;
fl.create;
xs.create;
zv.create;
Pr.create;
const iT = In.create;
In.strictCreate;
Pf.create;
x_.create;
If.create;
Ra.create;
zf.create;
Fv.create;
Sl.create;
Yc.create;
kf.create;
Ff.create;
ro.create;
Bf.create;
au.create;
Ca.create;
Ma.create;
ao.create;
Ca.createWithPreprocess;
lh.create;
const Bk = iT({
    username: va().min(1, "Full name is required"),
    rollNumber: va().min(5, "Roll number is required and input your full roll number"),
    email: va().min(3, "Invalid email format"),
    branch: va().min(1, "Branch is required"),
    course: va().min(1, "Course is required"),
    phoneNumber: va().regex(/^\d{10}$/, "Must be 10 digit number"),
    yog: va().min(4, "Year of graduation must be valid")
})
  , Vk = "https://xunback.manantechnosurge.tech"
  , Hk = () => {
    const [n,e] = $.useState(!1)
      , [t,r] = $.useState("")
      , s = Ml()
      , {isLoaded: o, signUp: u, setActive: d} = lC()
      , {isSignedIn: f} = ZE()
      , [h,m] = $.useState(!1)
      , [g,_] = $.useState("")
      , [x,E] = $.useState(null)
      , M = jw({
        resolver: Kw(Bk),
        defaultValues: {
            username: "",
            rollNumber: "",
            email: "",
            branch: "",
            course: "",
            phoneNumber: "",
            yog: ""
        }
    });
    $.useEffect( () => {
        f && s("/quiz")
    }
    );
    const b = async T => {
        var D, C;
        if (o) {
            e(!0),
            r(""),
            E(T);
            try {
                const P = T.email.substring(0, 5).toLowerCase() + "@" + T.rollNumber.slice(-5).toLowerCase();
                await u.create({
                    emailAddress: T.email,
                    password: P
                }),
                await u.prepareEmailAddressVerification({
                    strategy: "email_code"
                }),
                m(!0)
            } catch (P) {
                console.error(JSON.stringify(P, null, 2));
                const A = (C = (D = P.errors) == null ? void 0 : D[0]) == null ? void 0 : C.code;
                r(A === "form_identifier_exists" ? "This email is already registered." : A === "form_password_pwned" ? "This password is not secure. Please choose a stronger one." : "Signup failed. Please try again.")
            } finally {
                e(!1)
            }
        }
    }
      , y = async T => {
        if (T.preventDefault(),
        !(!o || !x)) {
            if (!/^\d{6}$/.test(g)) {
                r("Verification code must be a 6-digit number.");
                return
            }
            e(!0);
            try {
                const D = await u.attemptEmailAddressVerification({
                    code: g
                });
                if (D.status === "complete") {
                    await d({
                        session: D.createdSessionId
                    });
                    const C = await fetch(`${Vk}/api/user/create`, {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json"
                        },
                        body: JSON.stringify({
                            ...x,
                            userId: D.createdUserId
                        })
                    });
                    if (!C.ok) {
                        console.error("Backend registration failed:", await C.text()),
                        r("Failed to complete registration. Please try again later.");
                        return
                    }
                    M.reset(),
                    s("/quiz")
                } else
                    r("Verification incomplete. Try again.")
            } catch (D) {
                console.error("Verification error:", JSON.stringify(D, null, 2)),
                r("Verification failed. Check your code.")
            } finally {
                e(!1)
            }
        }
    }
    ;
    return h ? Z.jsxs("div", {
        className: "relative z-10 flex flex-col items-center justify-center min-h-screen px-4 space-y-8",
        children: [Z.jsx("h1", {
            className: "text-2xl font-bold text-white",
            children: "Verify your email"
        }), Z.jsxs("form", {
            onSubmit: y,
            className: "space-y-4 w-full max-w-sm",
            children: [Z.jsx("label", {
                htmlFor: "code",
                className: "text-white",
                children: "Enter your verification code"
            }), Z.jsx(Cr, {
                id: "code",
                name: "code",
                value: g,
                onChange: T => _(T.target.value),
                className: "text-white",
                "aria-describedby": "code-error",
                required: !0
            }), t && Z.jsx("p", {
                id: "code-error",
                className: "text-red-500 text-sm",
                children: t
            }), Z.jsx(Iz, {
                type: "submit",
                className: "w-full",
                disabled: n,
                children: n ? Z.jsxs(Z.Fragment, {
                    children: [Z.jsx(Uv, {
                        className: "mr-2 h-4 w-4 animate-spin"
                    }), "Verifying..."]
                }) : "Verify"
            })]
        })]
    }) : Z.jsxs("div", {
        className: "absolute w-full top-1/6 z-10 flex flex-col items-center justify-center px-4 space-y-8",
        children: [Z.jsx("h1", {
            className: "text-xl md:text-2xl lg:text-3xl font-semibold underline text-white text-center",
            children: "Registration Form"
        }), Z.jsxs("div", {
            className: "w-full max-w-md backdrop-blur-md border border-white/20 p-8 rounded-2xl shadow-2xl",
            children: [Z.jsx(Xw, {
                ...M,
                children: Z.jsxs("form", {
                    onSubmit: M.handleSubmit(b),
                    className: "space-y-4",
                    children: [Z.jsx(fa, {
                        control: M.control,
                        name: "username",
                        render: ({field: T}) => Z.jsxs(ha, {
                            children: [Z.jsx(pa, {
                                className: "text-white",
                                children: "Username"
                            }), Z.jsx(ma, {
                                children: Z.jsx(Cr, {
                                    autoFocus: !0,
                                    className: "text-white",
                                    placeholder: "Name...",
                                    ...T
                                })
                            }), Z.jsx(ga, {})]
                        })
                    }), Z.jsx(fa, {
                        control: M.control,
                        name: "rollNumber",
                        render: ({field: T}) => Z.jsxs(ha, {
                            children: [Z.jsx(pa, {
                                className: "text-white",
                                children: "Roll Number"
                            }), Z.jsx(ma, {
                                children: Z.jsx(Cr, {
                                    className: "text-white",
                                    placeholder: "Roll Number",
                                    ...T
                                })
                            }), Z.jsx(ga, {})]
                        })
                    }), Z.jsx(fa, {
                        control: M.control,
                        name: "email",
                        render: ({field: T}) => Z.jsxs(ha, {
                            children: [Z.jsx(pa, {
                                className: "text-white",
                                children: "Email"
                            }), Z.jsx(ma, {
                                children: Z.jsx(Cr, {
                                    className: "text-white",
                                    type: "email",
                                    placeholder: "example@domain.com",
                                    ...T
                                })
                            }), Z.jsx(ga, {})]
                        })
                    }), Z.jsx(fa, {
                        control: M.control,
                        name: "branch",
                        render: ({field: T}) => Z.jsxs(ha, {
                            children: [Z.jsx(pa, {
                                className: "text-white",
                                children: "Branch"
                            }), Z.jsx(ma, {
                                children: Z.jsx(Cr, {
                                    className: "text-white",
                                    placeholder: "Computer Science",
                                    ...T
                                })
                            }), Z.jsx(ga, {})]
                        })
                    }), Z.jsx(fa, {
                        control: M.control,
                        name: "course",
                        render: ({field: T}) => Z.jsxs(ha, {
                            children: [Z.jsx(pa, {
                                className: "text-white",
                                children: "Course"
                            }), Z.jsx(ma, {
                                children: Z.jsx(Cr, {
                                    className: "text-white",
                                    placeholder: "B.TECH",
                                    ...T
                                })
                            }), Z.jsx(ga, {})]
                        })
                    }), Z.jsx(fa, {
                        control: M.control,
                        name: "phoneNumber",
                        render: ({field: T}) => Z.jsxs(ha, {
                            children: [Z.jsx(pa, {
                                className: "text-white",
                                children: "Phone Number"
                            }), Z.jsx(ma, {
                                children: Z.jsx(Cr, {
                                    className: "text-white",
                                    placeholder: "9876543210",
                                    ...T
                                })
                            }), Z.jsx(ga, {})]
                        })
                    }), Z.jsx(fa, {
                        control: M.control,
                        name: "yog",
                        render: ({field: T}) => Z.jsxs(ha, {
                            children: [Z.jsx(pa, {
                                className: "text-white",
                                children: "Year of Graduation"
                            }), Z.jsx(ma, {
                                children: Z.jsx(Cr, {
                                    className: "text-white",
                                    placeholder: "e.g., 2027",
                                    ...T
                                })
                            }), Z.jsx(ga, {})]
                        })
                    }), Z.jsx("div", {
                        id: "clerk-captcha",
                        "data-cl-theme": "dark",
                        "data-cl-size": "flexible",
                        "data-cl-language": "es-ES"
                    }), Z.jsx("div", {
                        className: "flex items-center",
                        children: Z.jsx(to, {
                            type: "submit",
                            disabled: n,
                            className: "text-white rounded-md border px-3 py-2 w-full text-lg sm:text-xl font-semibold transition-colors duration-300 shadow-[3px_4px_0_white] active:shadow-[1px_2px_0_white]",
                            children: n ? Z.jsxs(Z.Fragment, {
                                children: [Z.jsx(Uv, {
                                    className: "mr-2 h-4 w-4 animate-spin"
                                }), "Registering..."]
                            }) : "Register"
                        })
                    })]
                })
            }), Z.jsxs("p", {
                className: "text-center text-white mt-4",
                children: ["Already Have an Account? ", Z.jsx("a", {
                    className: "text-white hover:underline font-bold",
                    href: "/signin",
                    children: "Sign In"
                })]
            }), t && Z.jsx("p", {
                className: "mt-2 text-sm text-red-500 text-center",
                children: t
            })]
        })]
    })
}
  , Gk = ({LeaderBoard: n, timeLeft: e, clerkUserId: t, userRank: r}) => {
    const s = [...n].sort( (o, u) => o.rank - u.rank);
    return Z.jsx("div", {
        className: "fixed inset-0 z-30 flex items-center justify-center px-4 text-white overflow-auto",
        children: Z.jsxs("div", {
            className: "relative border p-5 rounded-md max-w-3xl w-full text-center backdrop-blur bg-black/50",
            children: [Z.jsxs("div", {
                className: "max-w-prose mx-auto",
                children: [Z.jsx("h2", {
                    className: "font-bold underline text-xl lgtext-3xl",
                    children: "LeaderBoard"
                }), Z.jsxs("h2", {
                    className: "font-bold underline text-xl mt-5",
                    children: ["Your current rank is ", r]
                }), Z.jsxs("div", {
                    className: "text-sm mt-4",
                    children: ["Next question in ", e]
                })]
            }), Z.jsx("div", {
                className: "mt-5 max-h-[60vh] overflow-y-auto",
                children: Z.jsxs("table", {
                    className: "w-full divide-y divide-gray-200",
                    children: [Z.jsx("thead", {
                        className: "sticky top-0 bg-black/70 backdrop-blur",
                        children: Z.jsxs("tr", {
                            children: [Z.jsx("th", {
                                scope: "col",
                                className: "px-4 py-3 text-left text-xs font-medium uppercase tracking-wider text-center border",
                                children: "Rank"
                            }), Z.jsx("th", {
                                scope: "col",
                                className: "px-4 py-3 text-left text-xs font-medium uppercase tracking-wider text-center border",
                                children: "Player"
                            })]
                        })
                    }), Z.jsx("tbody", {
                        className: "divide-y divide-gray-200",
                        children: s.length === 0 ? Z.jsx("tr", {
                            children: Z.jsx("td", {
                                colSpan: 3,
                                className: "px-4 py-3 text-sm text-center",
                                children: "No leaderboard data available"
                            })
                        }) : s.map(o => Z.jsxs("tr", {
                            className: o.userId === t ? "bg-zinc-200/20" : "",
                            children: [Z.jsxs("td", {
                                className: "px-4 py-3 whitespace-nowrap text-sm font-medium",
                                children: ["#", o.rank]
                            }), Z.jsx("td", {
                                className: "px-4 py-3 whitespace-nowrap text-sm",
                                children: o.username
                            })]
                        }, o.userId))
                    })]
                })
            })]
        })
    })
}
  , _g = "https://xunback.manantechnosurge.tech"
  , jk = n => {
    const [e,t] = $.useState(null)
      , [r,s] = $.useState(0)
      , [o,u] = $.useState(!0)
      , [d,f] = $.useState("")
      , [h,m] = $.useState(!1)
      , [g,_] = $.useState(!1)
      , [x,E] = $.useState(20)
      , [M,b] = $.useState(10)
      , [y,T] = $.useState([])
      , [D,C] = $.useState("")
      , P = Ml();
    $.useEffect( () => {
        if (!n) {
            u(!1);
            return
        }
        (async () => {
            u(!0),
            f("");
            try {
                const Q = await fetch(`${_g}/api/question/user/${n}`);
                if (!Q.ok) {
                    console.error(`Failed to fetch questions: ${Q.status}`),
                    f("Failed to fetch questions"),
                    u(!1);
                    return
                }
                const X = await Q.json();
                if (!X.data || !X.data.unansweredQuestions || X.data.unansweredQuestions.length === 0) {
                    console.log("redirecting to /leaderboard"),
                    m(!0),
                    u(!1),
                    P("/leaderboard");
                    return
                }
                const oe = X.data.unansweredQuestions;
                let le = 0;
                for (let W = 0; W < oe.length; W++) {
                    if (!oe[W].answered) {
                        le = W;
                        break
                    }
                    if (W === oe.length - 1) {
                        console.log("redirecting to /leaderboard"),
                        m(!0),
                        u(!1),
                        P("/leaderboard");
                        return
                    }
                }
                const O = {
                    userId: n,
                    questions: oe.map(W => ({
                        ...W,
                        answered: W.answered || !1,
                        selectedOption: W.selectedOption || null,
                        displayedAt: W.displayedAt || null,
                        answeredAt: W.answeredAt || null,
                        timeLeft: W.timeLeft || 20
                    })),
                    lastFetchedAt: Date.now()
                };
                localStorage.setItem("quiz-session", JSON.stringify(O)),
                console.log("Saving into the current session"),
                t(O),
                s(le)
            } catch (Q) {
                console.error("Error loading quiz session: ", Q),
                f("Failed to load quiz session")
            } finally {
                u(!1)
            }
        }
        )()
    }
    , [n, P, h]),
    $.useEffect( () => {
        if (!e || g || r >= e.questions.length)
            return;
        const V = e.questions[r];
        if (!V.displayedAt) {
            const X = {
                ...e
            };
            X.questions[r] = {
                ...V,
                displayedAt: Date.now()
            },
            t(X),
            localStorage.setItem("quiz-session", JSON.stringify(X)),
            E(20)
        }
        const Q = setInterval( () => {
            const X = Date.now()
              , oe = V.displayedAt || X
              , le = Math.floor((X - oe) / 1e3)
              , O = Math.max(0, 20 - le);
            E(O),
            O === 0 && (clearInterval(Q),
            V.answered || F(),
            z(),
            _(!0),
            b(10))
        }
        , 1e3);
        return () => clearInterval(Q)
    }
    , [r, e, g]);
    const A = () => {
        if (!e)
            return;
        const V = r + 1;
        if (console.log("Incrementing Questiong index"),
        V >= e.questions.length) {
            P("/leaderboard");
            return
        }
        s(V),
        E(20)
    }
    ;
    $.useEffect( () => {
        if (!g)
            return;
        const V = setInterval( () => {
            b(Q => Q <= 1 ? (clearInterval(V),
            _(!1),
            A(),
            0) : Q - 1)
        }
        , 1e3);
        return () => clearInterval(V)
    }
    , [g]);
    const F = () => {
        if (!e)
            return;
        const V = {
            ...e
        };
        V.questions[r] = {
            ...V.questions[r],
            answered: !0,
            selectedOption: "Timeout",
            answeredAt: Date.now(),
            timeLeft: 0
        },
        localStorage.setItem("quiz-session", JSON.stringify(V)),
        t(V),
        U(V.questions[r])
    }
      , z = async () => {
        var V;
        try {
            const Q = await fetch(`${_g}/api/leaderboard/${n}`);
            if (!Q.ok)
                throw console.error(`Failed to fetch leaderboard: ${Q.status}`),
                new Error(`Failed to fetch leaderboard: ${Q.status}`);
            const X = await Q.json();
            T(X.data.leaderboard || []),
            C(String(((V = X.data.user) == null ? void 0 : V.rank) || "N/A"))
        } catch (Q) {
            console.error("Error fetching leaderboard: ", Q),
            f("Failed to fetch leaderboards")
        }
    }
      , U = async V => {
        try {
            const Q = await fetch(`${_g}/api/submit/${n}`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({
                    questionId: V.questionId,
                    selectedOption: V.selectedOption,
                    timeLeft: V.timeLeft
                })
            });
            if (!Q.ok)
                throw new Error(`Failed to submit answer: ${Q.status}`)
        } catch (Q) {
            console.error("Error submitting answer: ", Q),
            f("Failed to submit answer")
        }
    }
    ;
    return {
        session: e,
        currentIndex: r,
        timeLeft: x,
        answerQuestion: V => {
            if (!e || e.questions[r].answered)
                return;
            const Q = {
                ...e
            };
            Q.questions[r] = {
                ...Q.questions[r],
                answered: !0,
                selectedOption: V,
                answeredAt: Date.now(),
                timeLeft: x
            },
            localStorage.setItem("quiz-session", JSON.stringify(Q)),
            t(Q),
            U(Q.questions[r])
        }
        ,
        loading: o,
        error: d,
        leaderboard: y,
        showingLeaderboard: g,
        leaderboardTimeLeft: M,
        setError: f,
        userRank: D
    }
}
  , Wk = () => {
    const {user: n} = qE()
      , e = n == null ? void 0 : n.id
      , t = Ml()
      , {session: r, currentIndex: s, timeLeft: o, answerQuestion: u, loading: d, error: f, leaderboard: h, showingLeaderboard: m, leaderboardTimeLeft: g, setError: _, userRank: x} = jk(e);
    $.useEffect( () => {
        pw(f),
        _("")
    }
    , [f, _]);
    const E = () => {
        t("/signin")
    }
    ;
    if (!e)
        return Z.jsx("div", {
            className: "absolute w-full h-screen z-10 flex items-center justify-center px-4 text-white",
            children: Z.jsxs("div", {
                className: "relative border p-5 rounded-md w-3xl text-center backdrop-blur flex flex-col items-center",
                children: [Z.jsx("h2", {
                    className: "font-bold text-2xl mb-3",
                    children: "Sign in to take the quiz"
                }), Z.jsx(to, {
                    onClick: E,
                    className: "text-white rounded-md border px-3 py-2 w-full text-lg sm:text-xl font-semibold transition-colors duration-300 shadow-[3px_4px_0_white] active:shadow-[1px_2px_0_white]",
                    children: "Sign In"
                })]
            })
        });
    if (d)
        return Z.jsx("div", {
            className: "absolute w-full h-screen z-10 flex items-center justify-center px-4 text-white",
            children: Z.jsx("div", {
                className: "relative border p-5 rounded-md w-3xl text-center  backdrop-blur",
                children: "Loading Quiz. Please Wait"
            })
        });
    if (!r || !r.questions || r.questions.length === 0)
        return Z.jsx("div", {
            className: "absolute w-full h-screen z-10 flex items-center justify-center px-4 text-white",
            children: Z.jsx("div", {
                className: "relative border p-5 rounded-md w-3xl text-center  backdrop-blur",
                children: "NO QUESTIONS AVAILABLE."
            })
        });
    s >= (r == null ? void 0 : r.questions.length) && t("/leaderboard");
    const M = r == null ? void 0 : r.questions[s];
    return m ? Z.jsx(Gk, {
        LeaderBoard: h,
        timeLeft: g,
        clerkUserId: e,
        userRank: x
    }) : Z.jsx("div", {
        className: "absolute w-full h-screen z-10 flex items-center justify-center px-4 text-white",
        children: Z.jsxs("div", {
            className: "relative border p-5 rounded-md w-3xl text-center  backdrop-blur",
            children: [Z.jsxs("h2", {
                className: "absolute -top-3 left-1/3 lg:left-1/5 transform -translate-x-1/2 px-4 text-sm font-bold bg-black",
                children: ["Question Left: ", (r == null ? void 0 : r.questions.length) - s]
            }), Z.jsx("p", {
                className: "text-lg mb-6 mt-4 border-b pb-2",
                children: M == null ? void 0 : M.question
            }), Z.jsx("div", {
                className: "w-full flex justify-center",
                children: Z.jsxs("div", {
                    className: "w-1/2 my-3",
                    children: [Z.jsx("div", {
                        className: "flex justify-center rounded-full h-2 mb-2",
                        children: Z.jsx("div", {
                            className: "bg-white h-2 rounded-full transition-all duration-300 mt-[-10px]",
                            style: {
                                width: `${o / 20 * 100}%`
                            }
                        })
                    }), Z.jsx("div", {
                        className: "text-center text-xs",
                        children: Z.jsxs("span", {
                            children: ["Time Left: ", o, "s"]
                        })
                    })]
                })
            }), Z.jsx("div", {
                className: "space-y-3",
                children: M == null ? void 0 : M.options.map( (b, y) => Z.jsx("button", {
                    onClick: () => u(b),
                    disabled: M.answered,
                    className: `w-full text-left px-5 py-2 border rounded-md shadow shadow-[3px_4px_0_white] font-bold transition-colors duration-200 active:shadow-[1px_2px_0_white] active:top-[3px] cursor-pointer transition-all relative hover:bg-zinc-300/20 ${M.answered ? "bg-zinc-300/30" : ""}`,
                    children: b
                }, y))
            }), (M == null ? void 0 : M.answered) && o > 0 && Z.jsxs("div", {
                className: "mt-3 p-4 border border-white rounded-md text-center text-white",
                children: [Z.jsx("p", {
                    children: "Your answer has been submitted!"
                }), Z.jsx("p", {
                    children: "Leaderboard will appear when the timer reaches 0"
                })]
            })]
        })
    })
}
  , Xk = iT({
    email: va().email("Invalid email format"),
    password: va().min(6, "Password must be at least 6 characters")
})
  , qk = () => {
    const [n,e] = $.useState(!1)
      , [t,r] = $.useState("")
      , s = Ml()
      , {isLoaded: o, signIn: u, setActive: d} = oC()
      , {isSignedIn: f} = ZE()
      , h = jw({
        resolver: Kw(Xk),
        defaultValues: {
            email: "",
            password: ""
        }
    });
    $.useEffect( () => {
        f && s("/quiz")
    }
    , [f, s]);
    const m = async g => {
        if (o) {
            e(!0),
            r("");
            try {
                const _ = await u.create({
                    identifier: g.email,
                    password: g.password
                });
                _.status === "complete" ? (await d({
                    session: _.createdSessionId
                }),
                s("/quiz")) : (r("Incomplete sign-in. Please try again."),
                console.error("Sign-in not complete:", _))
            } catch (_) {
                console.error(JSON.stringify(_, null, 2)),
                r("Sign-in failed. Please try again.")
            } finally {
                e(!1)
            }
        }
    }
    ;
    return Z.jsxs("div", {
        className: "absolute w-full h-screen z-10 flex flex-col items-center justify-center px-4 text-white",
        children: [Z.jsx("h1", {
            className: "text-xl md:text-2xl lg:text-3xl font-semibold underline text-white text-center mb-5",
            children: "Sign In"
        }), Z.jsxs("div", {
            className: "w-full max-w-md backdrop-blur-md border border-white/20 p-8 rounded-2xl shadow-2xl",
            children: [Z.jsx(Xw, {
                ...h,
                children: Z.jsxs("form", {
                    onSubmit: h.handleSubmit(m),
                    className: "space-y-4",
                    children: [Z.jsx(fa, {
                        control: h.control,
                        name: "email",
                        render: ({field: g}) => Z.jsxs(ha, {
                            children: [Z.jsx(pa, {
                                className: "text-white",
                                children: "Email"
                            }), Z.jsx(ma, {
                                children: Z.jsx(Cr, {
                                    className: "text-white",
                                    type: "email",
                                    placeholder: "example@domain.com",
                                    ...g
                                })
                            }), Z.jsx(ga, {})]
                        })
                    }), Z.jsx(fa, {
                        control: h.control,
                        name: "password",
                        render: ({field: g}) => Z.jsxs(ha, {
                            children: [Z.jsxs(pa, {
                                className: "text-white flex flex-col items-start",
                                children: ["Password", Z.jsx("span", {
                                    className: "text-xs",
                                    children: "first 5 letters of email + @ + last 5 letter of rollnumber"
                                })]
                            }), Z.jsx(ma, {
                                children: Z.jsx(Cr, {
                                    className: "text-white",
                                    type: "password",
                                    placeholder: "",
                                    ...g
                                })
                            }), Z.jsx(ga, {})]
                        })
                    }), Z.jsx("div", {
                        id: "clerk-captcha",
                        "data-cl-theme": "dark",
                        "data-cl-size": "flexible"
                    }), Z.jsx("div", {
                        className: "flex items-center",
                        children: Z.jsx(to, {
                            type: "submit",
                            disabled: n,
                            className: "text-white rounded-md border px-3 py-2 w-full text-lg sm:text-xl font-semibold transition-colors duration-300 shadow-[3px_4px_0_white] active:shadow-[1px_2px_0_white]",
                            children: n ? Z.jsxs(Z.Fragment, {
                                children: [Z.jsx(Uv, {
                                    className: "mr-2 h-4 w-4 animate-spin"
                                }), "Signing in..."]
                            }) : "Sign In"
                        })
                    })]
                })
            }), Z.jsxs("p", {
                className: "text-center text-white mt-4",
                children: ["Don't have an account?", " ", Z.jsx("a", {
                    className: "text-blue-500 hover:underline font-bold",
                    href: "/register",
                    children: "Register"
                })]
            }), t && Z.jsx("p", {
                className: "mt-2 text-sm text-red-500 text-center",
                children: t
            })]
        })]
    })
}
  , Yk = "https://xunback.manantechnosurge.tech"
  , Zk = () => {
    const [n,e] = $.useState([])
      , [t,r] = $.useState("N/A")
      , [s,o] = $.useState(!0)
      , [u,d] = $.useState(null)
      , {user: f} = qE()
      , h = (f == null ? void 0 : f.id) || ""
      , m = Ml()
      , g = async () => {
        o(!0),
        d(null);
        try {
            if (!h)
                throw new Error("User not authenticated. Please sign in.");
            const x = await fetch(`${Yk}/api/leaderboard/${h}`);
            if (!x.ok)
                throw new Error(`HTTP error! Status: ${x.status} ${x.statusText}`);
            const E = await x.json();
            if (E.status === "success" && E.data && Array.isArray(E.data.leaderboard) && E.data.user)
                e(E.data.leaderboard),
                r(E.data.user.rank ?? "N/A");
            else
                throw console.error("Invalid API response:", E),
                new Error("Invalid data format received from server")
        } catch (x) {
            const E = x instanceof Error ? x.message : "Unknown error occurred";
            d(E),
            console.error("Leaderboard fetch error:", x)
        } finally {
            o(!1)
        }
    }
    ;
    $.useEffect( () => {
        g()
    }
    , [h]),
    $.useEffect( () => {
        u && pw.error(u)
    }
    , [u]);
    const _ = () => {
        m("/signin")
    }
    ;
    return s ? Z.jsx("div", {
        className: "fixed inset-0 z-30 flex items-center justify-center px-4 text-white bg-black/50",
        children: Z.jsx("div", {
            className: "text-center p-5 rounded-md bg-black/70 backdrop-blur",
            children: "Loading leaderboard..."
        })
    }) : h ? u ? Z.jsx("div", {
        className: "fixed inset-0 z-30 flex items-center justify-center px-4 text-white bg-black/50",
        children: Z.jsxs("div", {
            className: "text-center p-5 rounded-md bg-black/70 backdrop-blur text-red-400",
            children: [Z.jsxs("p", {
                children: ["Error: ", u]
            }), Z.jsx("button", {
                onClick: g,
                className: "mt-3 px-4 py-2 border rounded-md hover:bg-zinc-300/20",
                children: "Retry"
            })]
        })
    }) : Z.jsx("div", {
        className: "fixed inset-0 z-30 flex items-center justify-center px-4 text-white overflow-auto",
        children: Z.jsxs("div", {
            className: "relative border p-5 rounded-md max-w-3xl w-full text-center backdrop-blur bg-black/50",
            children: [Z.jsxs("div", {
                className: "max-w-prose mx-auto",
                children: [Z.jsx("h2", {
                    className: "font-bold underline text-xl lg:text-3xl",
                    children: "Leaderboard"
                }), Z.jsxs("h2", {
                    className: "font-bold underline text-lg lg:text-xl mt-5",
                    children: ["Your current position is ", t]
                })]
            }), Z.jsx("div", {
                className: "mt-5 max-h-[60vh] overflow-y-auto",
                children: Z.jsxs("table", {
                    className: "w-full divide-y divide-gray-200",
                    children: [Z.jsx("thead", {
                        className: "sticky top-0 bg-black/70 backdrop-blur",
                        children: Z.jsxs("tr", {
                            children: [Z.jsx("th", {
                                className: "px-4 py-3 text-xs font-medium uppercase tracking-wider text-center border",
                                children: "Rank"
                            }), Z.jsx("th", {
                                className: "px-4 py-3 text-xs font-medium uppercase tracking-wider text-center border",
                                children: "Player"
                            })]
                        })
                    }), Z.jsx("tbody", {
                        className: "divide-y divide-gray-200",
                        children: n.length === 0 ? Z.jsx("tr", {
                            children: Z.jsx("td", {
                                colSpan: 3,
                                className: "px-4 py-3 text-sm text-center",
                                children: "No leaderboard data available"
                            })
                        }) : n.map(x => Z.jsxs("tr", {
                            className: x.userId === h ? "bg-zinc-200/20" : "",
                            children: [Z.jsxs("td", {
                                className: "border px-4 py-3 whitespace-nowrap text-sm font-medium text-center",
                                children: ["#", x.rank]
                            }), Z.jsx("td", {
                                className: "border px-4 py-3 whitespace-nowrap text-sm text-center",
                                children: x.username
                            })]
                        }, x.userId))
                    })]
                })
            })]
        })
    }) : Z.jsx("div", {
        className: "absolute w-full h-screen z-10 flex items-center justify-center px-4 text-white",
        children: Z.jsxs("div", {
            className: "relative border p-5 rounded-md w-3xl text-center backdrop-blur flex flex-col items-center",
            children: [Z.jsx("h2", {
                className: "font-bold text-2xl mb-3",
                children: "Sign in to view leaderboards"
            }), Z.jsx(to, {
                onClick: _,
                className: "text-white rounded-md border px-3 py-2 w-full text-lg sm:text-xl font-semibold transition-colors duration-300 shadow-[3px_4px_0_white] active:shadow-[1px_2px_0_white]",
                children: "Sign In"
            })]
        })
    })
}
  , $k = () => Z.jsx("div", {
    className: "text-white text-3xl",
    children: "NotFound"
})
  , Kk = () => {
    const n = () => {
        window.location.href = "https://chat.whatsapp.com/KEL3vs60wAqKzcnctxlTSL"
    }
    ;
    return Z.jsx("div", {
        className: "fixed h-full w-full z-30",
        children: Z.jsx("div", {
            className: "min-h-screen flex justify-center items-center px-6",
            children: Z.jsx("button", {
                onClick: n,
                className: "border py-3 px-6 rounded bg-green-500 text-white text-xl shadow-[3px_4px_0_white] hover:bg-green-600 transition",
                children: "Join Whatsapp Group"
            })
        })
    })
}
  , Qk = "pk_live_Y2xlcmsueHVuYmFvLm1hbmFudGVjaG5vc3VyZ2UudGVjaCQ"
  , Jk = WD([{
    path: "/",
    element: Z.jsx(XI, {}),
    children: [{
        index: !0,
        element: Z.jsx(qI, {})
    }, {
        path: "register",
        element: Z.jsx(Hk, {})
    }, {
        path: "quiz",
        element: Z.jsx(Wk, {})
    }, {
        path: "signin",
        element: Z.jsx(qk, {})
    }, {
        path: "leaderboard",
        element: Z.jsx(Zk, {})
    }, {
        path: "whatsapp",
        element: Z.jsx(Kk, {})
    }, {
        path: "*",
        element: Z.jsx($k, {})
    }]
}]);
p1.createRoot(document.getElementById("root")).render(Z.jsx($.StrictMode, {
    children: Z.jsx(fM, {
        publishableKey: Qk,
        afterSignOutUrl: "/",
        children: Z.jsx(vD, {
            router: Jk
        })
    })
}));
